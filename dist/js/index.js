(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@pixi/constants/lib/index.mjs
  var ENV, RENDERER_TYPE, BUFFER_BITS, BLEND_MODES, DRAW_MODES, FORMATS, TARGETS, TYPES, SAMPLER_TYPES, SCALE_MODES, WRAP_MODES, MIPMAP_MODES, ALPHA_MODES, CLEAR_MODES, GC_MODES, PRECISION, MASK_TYPES, MSAA_QUALITY, BUFFER_TYPE;
  var init_lib = __esm({
    "node_modules/@pixi/constants/lib/index.mjs"() {
      ENV = /* @__PURE__ */ ((ENV2) => (ENV2[ENV2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", ENV2[ENV2.WEBGL = 1] = "WEBGL", ENV2[ENV2.WEBGL2 = 2] = "WEBGL2", ENV2))(ENV || {});
      RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => (RENDERER_TYPE2[RENDERER_TYPE2.UNKNOWN = 0] = "UNKNOWN", RENDERER_TYPE2[RENDERER_TYPE2.WEBGL = 1] = "WEBGL", RENDERER_TYPE2[RENDERER_TYPE2.CANVAS = 2] = "CANVAS", RENDERER_TYPE2))(RENDERER_TYPE || {});
      BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => (BUFFER_BITS2[BUFFER_BITS2.COLOR = 16384] = "COLOR", BUFFER_BITS2[BUFFER_BITS2.DEPTH = 256] = "DEPTH", BUFFER_BITS2[BUFFER_BITS2.STENCIL = 1024] = "STENCIL", BUFFER_BITS2))(BUFFER_BITS || {});
      BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => (BLEND_MODES2[BLEND_MODES2.NORMAL = 0] = "NORMAL", BLEND_MODES2[BLEND_MODES2.ADD = 1] = "ADD", BLEND_MODES2[BLEND_MODES2.MULTIPLY = 2] = "MULTIPLY", BLEND_MODES2[BLEND_MODES2.SCREEN = 3] = "SCREEN", BLEND_MODES2[BLEND_MODES2.OVERLAY = 4] = "OVERLAY", BLEND_MODES2[BLEND_MODES2.DARKEN = 5] = "DARKEN", BLEND_MODES2[BLEND_MODES2.LIGHTEN = 6] = "LIGHTEN", BLEND_MODES2[BLEND_MODES2.COLOR_DODGE = 7] = "COLOR_DODGE", BLEND_MODES2[BLEND_MODES2.COLOR_BURN = 8] = "COLOR_BURN", BLEND_MODES2[BLEND_MODES2.HARD_LIGHT = 9] = "HARD_LIGHT", BLEND_MODES2[BLEND_MODES2.SOFT_LIGHT = 10] = "SOFT_LIGHT", BLEND_MODES2[BLEND_MODES2.DIFFERENCE = 11] = "DIFFERENCE", BLEND_MODES2[BLEND_MODES2.EXCLUSION = 12] = "EXCLUSION", BLEND_MODES2[BLEND_MODES2.HUE = 13] = "HUE", BLEND_MODES2[BLEND_MODES2.SATURATION = 14] = "SATURATION", BLEND_MODES2[BLEND_MODES2.COLOR = 15] = "COLOR", BLEND_MODES2[BLEND_MODES2.LUMINOSITY = 16] = "LUMINOSITY", BLEND_MODES2[BLEND_MODES2.NORMAL_NPM = 17] = "NORMAL_NPM", BLEND_MODES2[BLEND_MODES2.ADD_NPM = 18] = "ADD_NPM", BLEND_MODES2[BLEND_MODES2.SCREEN_NPM = 19] = "SCREEN_NPM", BLEND_MODES2[BLEND_MODES2.NONE = 20] = "NONE", BLEND_MODES2[BLEND_MODES2.SRC_OVER = 0] = "SRC_OVER", BLEND_MODES2[BLEND_MODES2.SRC_IN = 21] = "SRC_IN", BLEND_MODES2[BLEND_MODES2.SRC_OUT = 22] = "SRC_OUT", BLEND_MODES2[BLEND_MODES2.SRC_ATOP = 23] = "SRC_ATOP", BLEND_MODES2[BLEND_MODES2.DST_OVER = 24] = "DST_OVER", BLEND_MODES2[BLEND_MODES2.DST_IN = 25] = "DST_IN", BLEND_MODES2[BLEND_MODES2.DST_OUT = 26] = "DST_OUT", BLEND_MODES2[BLEND_MODES2.DST_ATOP = 27] = "DST_ATOP", BLEND_MODES2[BLEND_MODES2.ERASE = 26] = "ERASE", BLEND_MODES2[BLEND_MODES2.SUBTRACT = 28] = "SUBTRACT", BLEND_MODES2[BLEND_MODES2.XOR = 29] = "XOR", BLEND_MODES2))(BLEND_MODES || {});
      DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => (DRAW_MODES2[DRAW_MODES2.POINTS = 0] = "POINTS", DRAW_MODES2[DRAW_MODES2.LINES = 1] = "LINES", DRAW_MODES2[DRAW_MODES2.LINE_LOOP = 2] = "LINE_LOOP", DRAW_MODES2[DRAW_MODES2.LINE_STRIP = 3] = "LINE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLES = 4] = "TRIANGLES", DRAW_MODES2[DRAW_MODES2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", DRAW_MODES2[DRAW_MODES2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", DRAW_MODES2))(DRAW_MODES || {});
      FORMATS = /* @__PURE__ */ ((FORMATS2) => (FORMATS2[FORMATS2.RGBA = 6408] = "RGBA", FORMATS2[FORMATS2.RGB = 6407] = "RGB", FORMATS2[FORMATS2.RG = 33319] = "RG", FORMATS2[FORMATS2.RED = 6403] = "RED", FORMATS2[FORMATS2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", FORMATS2[FORMATS2.RGB_INTEGER = 36248] = "RGB_INTEGER", FORMATS2[FORMATS2.RG_INTEGER = 33320] = "RG_INTEGER", FORMATS2[FORMATS2.RED_INTEGER = 36244] = "RED_INTEGER", FORMATS2[FORMATS2.ALPHA = 6406] = "ALPHA", FORMATS2[FORMATS2.LUMINANCE = 6409] = "LUMINANCE", FORMATS2[FORMATS2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", FORMATS2[FORMATS2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", FORMATS2[FORMATS2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", FORMATS2))(FORMATS || {});
      TARGETS = /* @__PURE__ */ ((TARGETS2) => (TARGETS2[TARGETS2.TEXTURE_2D = 3553] = "TEXTURE_2D", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", TARGETS2[TARGETS2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", TARGETS2[TARGETS2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", TARGETS2))(TARGETS || {});
      TYPES = /* @__PURE__ */ ((TYPES2) => (TYPES2[TYPES2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", TYPES2[TYPES2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", TYPES2[TYPES2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", TYPES2[TYPES2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", TYPES2[TYPES2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", TYPES2[TYPES2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", TYPES2[TYPES2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", TYPES2[TYPES2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", TYPES2[TYPES2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", TYPES2[TYPES2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", TYPES2[TYPES2.BYTE = 5120] = "BYTE", TYPES2[TYPES2.SHORT = 5122] = "SHORT", TYPES2[TYPES2.INT = 5124] = "INT", TYPES2[TYPES2.FLOAT = 5126] = "FLOAT", TYPES2[TYPES2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", TYPES2[TYPES2.HALF_FLOAT = 36193] = "HALF_FLOAT", TYPES2))(TYPES || {});
      SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => (SAMPLER_TYPES2[SAMPLER_TYPES2.FLOAT = 0] = "FLOAT", SAMPLER_TYPES2[SAMPLER_TYPES2.INT = 1] = "INT", SAMPLER_TYPES2[SAMPLER_TYPES2.UINT = 2] = "UINT", SAMPLER_TYPES2))(SAMPLER_TYPES || {});
      SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => (SCALE_MODES2[SCALE_MODES2.NEAREST = 0] = "NEAREST", SCALE_MODES2[SCALE_MODES2.LINEAR = 1] = "LINEAR", SCALE_MODES2))(SCALE_MODES || {});
      WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => (WRAP_MODES2[WRAP_MODES2.CLAMP = 33071] = "CLAMP", WRAP_MODES2[WRAP_MODES2.REPEAT = 10497] = "REPEAT", WRAP_MODES2[WRAP_MODES2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", WRAP_MODES2))(WRAP_MODES || {});
      MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => (MIPMAP_MODES2[MIPMAP_MODES2.OFF = 0] = "OFF", MIPMAP_MODES2[MIPMAP_MODES2.POW2 = 1] = "POW2", MIPMAP_MODES2[MIPMAP_MODES2.ON = 2] = "ON", MIPMAP_MODES2[MIPMAP_MODES2.ON_MANUAL = 3] = "ON_MANUAL", MIPMAP_MODES2))(MIPMAP_MODES || {});
      ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => (ALPHA_MODES2[ALPHA_MODES2.NPM = 0] = "NPM", ALPHA_MODES2[ALPHA_MODES2.UNPACK = 1] = "UNPACK", ALPHA_MODES2[ALPHA_MODES2.PMA = 2] = "PMA", ALPHA_MODES2[ALPHA_MODES2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", ALPHA_MODES2[ALPHA_MODES2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", ALPHA_MODES2))(ALPHA_MODES || {});
      CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => (CLEAR_MODES2[CLEAR_MODES2.NO = 0] = "NO", CLEAR_MODES2[CLEAR_MODES2.YES = 1] = "YES", CLEAR_MODES2[CLEAR_MODES2.AUTO = 2] = "AUTO", CLEAR_MODES2[CLEAR_MODES2.BLEND = 0] = "BLEND", CLEAR_MODES2[CLEAR_MODES2.CLEAR = 1] = "CLEAR", CLEAR_MODES2[CLEAR_MODES2.BLIT = 2] = "BLIT", CLEAR_MODES2))(CLEAR_MODES || {});
      GC_MODES = /* @__PURE__ */ ((GC_MODES2) => (GC_MODES2[GC_MODES2.AUTO = 0] = "AUTO", GC_MODES2[GC_MODES2.MANUAL = 1] = "MANUAL", GC_MODES2))(GC_MODES || {});
      PRECISION = /* @__PURE__ */ ((PRECISION2) => (PRECISION2.LOW = "lowp", PRECISION2.MEDIUM = "mediump", PRECISION2.HIGH = "highp", PRECISION2))(PRECISION || {});
      MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => (MASK_TYPES2[MASK_TYPES2.NONE = 0] = "NONE", MASK_TYPES2[MASK_TYPES2.SCISSOR = 1] = "SCISSOR", MASK_TYPES2[MASK_TYPES2.STENCIL = 2] = "STENCIL", MASK_TYPES2[MASK_TYPES2.SPRITE = 3] = "SPRITE", MASK_TYPES2[MASK_TYPES2.COLOR = 4] = "COLOR", MASK_TYPES2))(MASK_TYPES || {});
      MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => (MSAA_QUALITY2[MSAA_QUALITY2.NONE = 0] = "NONE", MSAA_QUALITY2[MSAA_QUALITY2.LOW = 2] = "LOW", MSAA_QUALITY2[MSAA_QUALITY2.MEDIUM = 4] = "MEDIUM", MSAA_QUALITY2[MSAA_QUALITY2.HIGH = 8] = "HIGH", MSAA_QUALITY2))(MSAA_QUALITY || {});
      BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE22) => (BUFFER_TYPE22[BUFFER_TYPE22.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", BUFFER_TYPE22[BUFFER_TYPE22.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", BUFFER_TYPE22[BUFFER_TYPE22.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", BUFFER_TYPE22))(BUFFER_TYPE || {});
    }
  });

  // node_modules/@pixi/settings/lib/adapter.mjs
  var BrowserAdapter;
  var init_adapter = __esm({
    "node_modules/@pixi/settings/lib/adapter.mjs"() {
      BrowserAdapter = {
        createCanvas: (width, height) => {
          const canvas = document.createElement("canvas");
          return canvas.width = width, canvas.height = height, canvas;
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (url2, options) => fetch(url2, options),
        parseXML: (xml) => new DOMParser().parseFromString(xml, "text/xml")
      };
    }
  });

  // node_modules/@pixi/settings/lib/settings.mjs
  var settings;
  var init_settings = __esm({
    "node_modules/@pixi/settings/lib/settings.mjs"() {
      init_adapter();
      settings = {
        ADAPTER: BrowserAdapter,
        RESOLUTION: 1,
        CREATE_IMAGE_BITMAP: false,
        ROUND_PIXELS: false
      };
    }
  });

  // node_modules/ismobilejs/esm/isMobile.js
  function createMatch(userAgent) {
    return function(regex) {
      return regex.test(userAgent);
    };
  }
  function isMobile(param) {
    var nav = {
      userAgent: "",
      platform: "",
      maxTouchPoints: 0
    };
    if (!param && typeof navigator !== "undefined") {
      nav = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
      };
    } else if (typeof param === "string") {
      nav.userAgent = param;
    } else if (param && param.userAgent) {
      nav = {
        userAgent: param.userAgent,
        platform: param.platform,
        maxTouchPoints: param.maxTouchPoints || 0
      };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    tmp = userAgent.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
      apple: {
        phone: match(appleIphone) && !match(windowsPhone),
        ipod: match(appleIpod),
        tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
        universal: match(appleUniversal),
        device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
      },
      amazon: {
        phone: match(amazonPhone),
        tablet: !match(amazonPhone) && match(amazonTablet),
        device: match(amazonPhone) || match(amazonTablet)
      },
      android: {
        phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
        tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
        device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
      },
      windows: {
        phone: match(windowsPhone),
        tablet: match(windowsTablet),
        device: match(windowsPhone) || match(windowsTablet)
      },
      other: {
        blackberry: match(otherBlackBerry),
        blackberry10: match(otherBlackBerry10),
        opera: match(otherOpera),
        firefox: match(otherFirefox),
        chrome: match(otherChrome),
        device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
      },
      any: false,
      phone: false,
      tablet: false
    };
    result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
    result.phone = result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
  }
  var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
  var init_isMobile = __esm({
    "node_modules/ismobilejs/esm/isMobile.js"() {
      appleIphone = /iPhone/i;
      appleIpod = /iPod/i;
      appleTablet = /iPad/i;
      appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
      androidPhone = /\bAndroid(?:.+)Mobile\b/i;
      androidTablet = /Android/i;
      amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
      amazonTablet = /Silk/i;
      windowsPhone = /Windows Phone/i;
      windowsTablet = /\bWindows(?:.+)ARM\b/i;
      otherBlackBerry = /BlackBerry/i;
      otherBlackBerry10 = /BB10/i;
      otherOpera = /Opera Mini/i;
      otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
      otherFirefox = /Mobile(?:.+)Firefox\b/i;
      isAppleTabletOnIos13 = function(navigator2) {
        return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
      };
    }
  });

  // node_modules/ismobilejs/esm/index.js
  var init_esm = __esm({
    "node_modules/ismobilejs/esm/index.js"() {
      init_isMobile();
      init_isMobile();
    }
  });

  // node_modules/@pixi/settings/lib/utils/isMobile.mjs
  var isMobileCall, isMobile2;
  var init_isMobile2 = __esm({
    "node_modules/@pixi/settings/lib/utils/isMobile.mjs"() {
      init_esm();
      isMobileCall = isMobile.default ?? isMobile;
      isMobile2 = isMobileCall(globalThis.navigator);
    }
  });

  // node_modules/@pixi/settings/lib/index.mjs
  var init_lib2 = __esm({
    "node_modules/@pixi/settings/lib/index.mjs"() {
      init_adapter();
      init_settings();
      init_isMobile2();
    }
  });

  // node_modules/@pixi/utils/lib/settings.mjs
  var init_settings2 = __esm({
    "node_modules/@pixi/utils/lib/settings.mjs"() {
      init_lib2();
      init_lib2();
      settings.RETINA_PREFIX = /@([0-9\.]+)x/;
      settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context3, once) {
        this.fn = fn;
        this.context = context3;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context3, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context3 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context3) {
        return addListener(this, event, fn, context3, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context3) {
        return addListener(this, event, fn, context3, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context3, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context3 || listeners.context === context3)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context3 && listeners[i2].context !== context3) {
              events.push(listeners[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i2 = dim; i2 < outerLen; i2 += dim) {
            x2 = data[i2];
            y2 = data[i2 + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i2, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i2 = start; i2 < end; i2 += dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        } else {
          for (i2 = end - dim; i2 >= start; i2 -= dim)
            last = insertNode(i2, data[i2], data[i2 + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p2 = start, again;
        do {
          again = false;
          if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
            removeNode(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next)
              break;
            again = true;
          } else {
            p2 = p2.next;
          }
        } while (again || p2 !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p2 = c2.next;
        while (p2 !== a2) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b2 = ear, c2 = ear.next;
        if (area(a2, b2, c2) >= 0)
          return false;
        var ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p2 = ear.prevZ, n2 = ear.nextZ;
        while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        while (p2 && p2.z >= minZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p2 = start;
        do {
          var a2 = p2.prev, b2 = p2.next.next;
          if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p2.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode(p2);
            removeNode(p2.next);
            p2 = start = b2;
          }
          p2 = p2.next;
        } while (p2 !== start);
        return filterPoints(p2);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a2 = start;
        do {
          var b2 = a2.next.next;
          while (b2 !== a2.prev) {
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
              var c2 = splitPolygon(a2, b2);
              a2 = filterPoints(a2, a2.next);
              c2 = filterPoints(c2, c2.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a2 = a2.next;
        } while (a2 !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i2, len, start, end, list;
        for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          start = holeIndices[i2] * dim;
          end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i2 = 0; i2 < queue.length; i2++) {
          outerNode = eliminateHole(queue[i2], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b2) {
        return a2.x - b2.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m2 = p2.x < p2.next.x ? p2 : p2.next;
              if (x2 === hx)
                return m2;
            }
          }
          p2 = p2.next;
        } while (p2 !== outerNode);
        if (!m2)
          return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
        p2 = m2;
        do {
          if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
              m2 = p2;
              tanMin = tan;
            }
          }
          p2 = p2.next;
        } while (p2 !== stop);
        return m2;
      }
      function sectorContainsSector(m2, p2) {
        return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p2 = start;
        do {
          if (p2.z === 0)
            p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
          p2.prevZ = p2.prev;
          p2.nextZ = p2.next;
          p2 = p2.next;
        } while (p2 !== start);
        p2.prevZ.nextZ = null;
        p2.prevZ = null;
        sortLinked(p2);
      }
      function sortLinked(list) {
        var i2, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p2 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p2) {
            numMerges++;
            q = p2;
            pSize = 0;
            for (i2 = 0; i2 < inSize; i2++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
                e2 = p2;
                p2 = p2.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e2;
              else
                list = e2;
              e2.prevZ = tail;
              tail = e2;
            }
            p2 = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p2 = start, leftmost = start;
        do {
          if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
            leftmost = p2;
          p2 = p2.next;
        } while (p2 !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b2) {
        return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
      }
      function area(p2, q, r2) {
        return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign2(area(p1, q1, p2));
        var o2 = sign2(area(p1, q1, q2));
        var o3 = sign2(area(p2, q2, p1));
        var o4 = sign2(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p2, q, r2) {
        return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b2) {
        var p2 = a2;
        do {
          if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
            return true;
          p2 = p2.next;
        } while (p2 !== a2);
        return false;
      }
      function locallyInside(a2, b2) {
        return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
      }
      function middleInside(a2, b2) {
        var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
        do {
          if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
            inside = !inside;
          p2 = p2.next;
        } while (p2 !== a2);
        return inside;
      }
      function splitPolygon(a2, b2) {
        var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
        a2.next = b2;
        b2.prev = a2;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode(i2, x2, y2, last) {
        var p2 = new Node(i2, x2, y2);
        if (!last) {
          p2.prev = p2;
          p2.next = p2;
        } else {
          p2.next = last.next;
          p2.prev = last;
          last.next.prev = p2;
          last.next = p2;
        }
        return p2;
      }
      function removeNode(p2) {
        p2.next.prev = p2.prev;
        p2.prev.next = p2.next;
        if (p2.prevZ)
          p2.prevZ.nextZ = p2.nextZ;
        if (p2.nextZ)
          p2.nextZ.prevZ = p2.prevZ;
      }
      function Node(i2, x2, y2) {
        this.i = i2;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
            var start = holeIndices[i2] * dim;
            var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i2 = 0; i2 < triangles.length; i2 += 3) {
          var a2 = triangles[i2] * dim;
          var b2 = triangles[i2 + 1] * dim;
          var c2 = triangles[i2 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
          sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
          j2 = i2;
        }
        return sum;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i2 = 0; i2 < data.length; i2++) {
          for (var j2 = 0; j2 < data[i2].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++)
              result.vertices.push(data[i2][j2][d2]);
          }
          if (i2 > 0) {
            holeIndex += data[i2 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/punycode/punycode.js
  var require_punycode = __commonJS({
    "node_modules/punycode/punycode.js"(exports, module) {
      (function(root) {
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = typeof module == "object" && module && !module.nodeType && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw new RangeError(errors[type]);
        }
        function map4(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map4(labels, fn).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map4(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k2 = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode(input) {
          var output = [], inputLength = input.length, out2, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w2, k2, digit, t2, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j2 = 0; j2 < basic; ++j2) {
            if (input.charCodeAt(j2) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j2));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
              if (index >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i2) / w2)) {
                error("overflow");
              }
              i2 += digit * w2;
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (digit < t2) {
                break;
              }
              baseMinusT = base - t2;
              if (w2 > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w2 *= baseMinusT;
            }
            out2 = output.length + 1;
            bias = adapt(i2 - oldi, out2, oldi == 0);
            if (floor(i2 / out2) > maxInt - n2) {
              error("overflow");
            }
            n2 += floor(i2 / out2);
            i2 %= out2;
            output.splice(i2++, 0, n2);
          }
          return ucs2encode(output);
        }
        function encode(input) {
          var n2, delta, handledCPCount, basicLength, bias, j2, m2, q, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n2 = initialN;
          delta = 0;
          bias = initialBias;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
              currentValue = input[j2];
              if (currentValue >= n2 && currentValue < m2) {
                m2 = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m2 - n2) * handledCPCountPlusOne;
            n2 = m2;
            for (j2 = 0; j2 < inputLength; ++j2) {
              currentValue = input[j2];
              if (currentValue < n2 && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n2) {
                for (q = delta, k2 = base; ; k2 += base) {
                  t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                  if (q < t2) {
                    break;
                  }
                  qMinusT = q - t2;
                  baseMinusT = base - t2;
                  output.push(
                    stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                  );
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n2;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        }
        punycode = {
          "version": "1.4.1",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            freeModule.exports = punycode;
          } else {
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          root.punycode = punycode;
        }
      })(exports);
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs.push("$" + i2);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x2) {
        return x2.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i2 + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e2) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // (disabled):node_modules/object-inspect/util.inspect
  var require_util = __commonJS({
    "(disabled):node_modules/object-inspect/util.inspect"() {
    }
  });

  // node_modules/object-inspect/index.js
  var require_object_inspect = __commonJS({
    "node_modules/object-inspect/index.js"(exports, module) {
      var hasMap = typeof Map === "function" && Map.prototype;
      var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
      var mapSize2 = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
      var mapForEach = hasMap && Map.prototype.forEach;
      var hasSet = typeof Set === "function" && Set.prototype;
      var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
      var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
      var setForEach = hasSet && Set.prototype.forEach;
      var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
      var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
      var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
      var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
      var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
      var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
      var booleanValueOf = Boolean.prototype.valueOf;
      var objectToString = Object.prototype.toString;
      var functionToString = Function.prototype.toString;
      var $match = String.prototype.match;
      var $slice = String.prototype.slice;
      var $replace = String.prototype.replace;
      var $toUpperCase = String.prototype.toUpperCase;
      var $toLowerCase = String.prototype.toLowerCase;
      var $test = RegExp.prototype.test;
      var $concat = Array.prototype.concat;
      var $join = Array.prototype.join;
      var $arrSlice = Array.prototype.slice;
      var $floor = Math.floor;
      var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
      var gOPS = Object.getOwnPropertySymbols;
      var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
      var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
      var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
        return O.__proto__;
      } : null);
      function addNumericSeparator(num, str) {
        if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
          return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
          var int = num < 0 ? -$floor(-num) : $floor(num);
          if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return $replace.call(str, sepRegex, "$&_");
      }
      var utilInspect = require_util();
      var inspectCustom = utilInspect.custom;
      var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
      module.exports = function inspect_(obj, options, depth, seen) {
        var opts = options || {};
        if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }
        if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") {
          return "undefined";
        }
        if (obj === null) {
          return "null";
        }
        if (typeof obj === "boolean") {
          return obj ? "true" : "false";
        }
        if (typeof obj === "string") {
          return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
          if (obj === 0) {
            return Infinity / obj > 0 ? "0" : "-0";
          }
          var str = String(obj);
          return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
          var bigIntStr = String(obj) + "n";
          return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
          depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
          return isArray(obj) ? "[Array]" : "[Object]";
        }
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") {
          seen = [];
        } else if (indexOf(seen, obj) >= 0) {
          return "[Circular]";
        }
        function inspect(value, from, noIndent) {
          if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
          }
          if (noIndent) {
            var newOpts = {
              depth: opts.depth
            };
            if (has(opts, "quoteStyle")) {
              newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
          }
          return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function" && !isRegExp(obj)) {
          var name = nameOf(obj);
          var keys = arrObjKeys(obj, inspect);
          return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
        }
        if (isSymbol(obj)) {
          var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
          return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement(obj)) {
          var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
          var attrs = obj.attributes || [];
          for (var i2 = 0; i2 < attrs.length; i2++) {
            s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
          }
          s2 += ">";
          if (obj.childNodes && obj.childNodes.length) {
            s2 += "...";
          }
          s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
          return s2;
        }
        if (isArray(obj)) {
          if (obj.length === 0) {
            return "[]";
          }
          var xs = arrObjKeys(obj, inspect);
          if (indent && !singleLineValues(xs)) {
            return "[" + indentedJoin(xs, indent) + "]";
          }
          return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
          var parts = arrObjKeys(obj, inspect);
          if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
            return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
          }
          if (parts.length === 0) {
            return "[" + String(obj) + "]";
          }
          return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
          if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
          } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
            return obj.inspect();
          }
        }
        if (isMap(obj)) {
          var mapParts = [];
          if (mapForEach) {
            mapForEach.call(obj, function(value, key) {
              mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
            });
          }
          return collectionOf("Map", mapSize2.call(obj), mapParts, indent);
        }
        if (isSet(obj)) {
          var setParts = [];
          if (setForEach) {
            setForEach.call(obj, function(value) {
              setParts.push(inspect(value, obj));
            });
          }
          return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) {
          return weakCollectionOf("WeakMap");
        }
        if (isWeakSet(obj)) {
          return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
          return weakCollectionOf("WeakRef");
        }
        if (isNumber(obj)) {
          return markBoxed(inspect(Number(obj)));
        }
        if (isBigInt(obj)) {
          return markBoxed(inspect(bigIntValueOf.call(obj)));
        }
        if (isBoolean(obj)) {
          return markBoxed(booleanValueOf.call(obj));
        }
        if (isString(obj)) {
          return markBoxed(inspect(String(obj)));
        }
        if (!isDate(obj) && !isRegExp(obj)) {
          var ys = arrObjKeys(obj, inspect);
          var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
          var protoTag = obj instanceof Object ? "" : "null prototype";
          var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
          var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
          var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
          if (ys.length === 0) {
            return tag + "{}";
          }
          if (indent) {
            return tag + "{" + indentedJoin(ys, indent) + "}";
          }
          return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
      };
      function wrapQuotes(s2, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s2 + quoteChar;
      }
      function quote(s2) {
        return $replace.call(String(s2), /"/g, "&quot;");
      }
      function isArray(obj) {
        return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isDate(obj) {
        return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isRegExp(obj) {
        return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isError(obj) {
        return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isString(obj) {
        return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isNumber(obj) {
        return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isBoolean(obj) {
        return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isSymbol(obj) {
        if (hasShammedSymbols) {
          return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
          return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
          return false;
        }
        try {
          symToString.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) {
          return false;
        }
        try {
          bigIntValueOf.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      var hasOwn = Object.prototype.hasOwnProperty || function(key) {
        return key in this;
      };
      function has(obj, key) {
        return hasOwn.call(obj, key);
      }
      function toStr(obj) {
        return objectToString.call(obj);
      }
      function nameOf(f2) {
        if (f2.name) {
          return f2.name;
        }
        var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
        if (m2) {
          return m2[1];
        }
        return null;
      }
      function indexOf(xs, x2) {
        if (xs.indexOf) {
          return xs.indexOf(x2);
        }
        for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
          if (xs[i2] === x2) {
            return i2;
          }
        }
        return -1;
      }
      function isMap(x2) {
        if (!mapSize2 || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          mapSize2.call(x2);
          try {
            setSize.call(x2);
          } catch (s2) {
            return true;
          }
          return x2 instanceof Map;
        } catch (e2) {
        }
        return false;
      }
      function isWeakMap(x2) {
        if (!weakMapHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakMapHas.call(x2, weakMapHas);
          try {
            weakSetHas.call(x2, weakSetHas);
          } catch (s2) {
            return true;
          }
          return x2 instanceof WeakMap;
        } catch (e2) {
        }
        return false;
      }
      function isWeakRef(x2) {
        if (!weakRefDeref || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakRefDeref.call(x2);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isSet(x2) {
        if (!setSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          setSize.call(x2);
          try {
            mapSize2.call(x2);
          } catch (m2) {
            return true;
          }
          return x2 instanceof Set;
        } catch (e2) {
        }
        return false;
      }
      function isWeakSet(x2) {
        if (!weakSetHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakSetHas.call(x2, weakSetHas);
          try {
            weakMapHas.call(x2, weakMapHas);
          } catch (s2) {
            return true;
          }
          return x2 instanceof WeakSet;
        } catch (e2) {
        }
        return false;
      }
      function isElement(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
          return true;
        }
        return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
      }
      function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
          var remaining = str.length - opts.maxStringLength;
          var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
          return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s2, "single", opts);
      }
      function lowbyte(c2) {
        var n2 = c2.charCodeAt(0);
        var x2 = {
          8: "b",
          9: "t",
          10: "n",
          12: "f",
          13: "r"
        }[n2];
        if (x2) {
          return "\\" + x2;
        }
        return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
      }
      function markBoxed(str) {
        return "Object(" + str + ")";
      }
      function weakCollectionOf(type) {
        return type + " { ? }";
      }
      function collectionOf(type, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type + " (" + size + ") {" + joinedEntries + "}";
      }
      function singleLineValues(xs) {
        for (var i2 = 0; i2 < xs.length; i2++) {
          if (indexOf(xs[i2], "\n") >= 0) {
            return false;
          }
        }
        return true;
      }
      function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") {
          baseIndent = "	";
        } else if (typeof opts.indent === "number" && opts.indent > 0) {
          baseIndent = $join.call(Array(opts.indent + 1), " ");
        } else {
          return null;
        }
        return {
          base: baseIndent,
          prev: $join.call(Array(depth + 1), baseIndent)
        };
      }
      function indentedJoin(xs, indent) {
        if (xs.length === 0) {
          return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
      }
      function arrObjKeys(obj, inspect) {
        var isArr = isArray(obj);
        var xs = [];
        if (isArr) {
          xs.length = obj.length;
          for (var i2 = 0; i2 < obj.length; i2++) {
            xs[i2] = has(obj, i2) ? inspect(obj[i2], obj) : "";
          }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
          symMap = {};
          for (var k2 = 0; k2 < syms.length; k2++) {
            symMap["$" + syms[k2]] = syms[k2];
          }
        }
        for (var key in obj) {
          if (!has(obj, key)) {
            continue;
          }
          if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
          }
          if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
            continue;
          } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
          } else {
            xs.push(key + ": " + inspect(obj[key], obj));
          }
        }
        if (typeof gOPS === "function") {
          for (var j2 = 0; j2 < syms.length; j2++) {
            if (isEnumerable.call(obj, syms[j2])) {
              xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
            }
          }
        }
        return xs;
      }
    }
  });

  // node_modules/side-channel/index.js
  var require_side_channel = __commonJS({
    "node_modules/side-channel/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBound = require_callBound();
      var inspect = require_object_inspect();
      var $TypeError = GetIntrinsic("%TypeError%");
      var $WeakMap = GetIntrinsic("%WeakMap%", true);
      var $Map = GetIntrinsic("%Map%", true);
      var $weakMapGet = callBound("WeakMap.prototype.get", true);
      var $weakMapSet = callBound("WeakMap.prototype.set", true);
      var $weakMapHas = callBound("WeakMap.prototype.has", true);
      var $mapGet = callBound("Map.prototype.get", true);
      var $mapSet = callBound("Map.prototype.set", true);
      var $mapHas = callBound("Map.prototype.has", true);
      var listGetNode = function(list, key) {
        for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
          if (curr.key === key) {
            prev.next = curr.next;
            curr.next = list.next;
            list.next = curr;
            return curr;
          }
        }
      };
      var listGet = function(objects, key) {
        var node = listGetNode(objects, key);
        return node && node.value;
      };
      var listSet = function(objects, key, value) {
        var node = listGetNode(objects, key);
        if (node) {
          node.value = value;
        } else {
          objects.next = {
            key,
            next: objects.next,
            value
          };
        }
      };
      var listHas = function(objects, key) {
        return !!listGetNode(objects, key);
      };
      module.exports = function getSideChannel() {
        var $wm;
        var $m;
        var $o;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapGet($m, key);
              }
            } else {
              if ($o) {
                return listGet($o, key);
              }
            }
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapHas($m, key);
              }
            } else {
              if ($o) {
                return listHas($o, key);
              }
            }
            return false;
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if ($Map) {
              if (!$m) {
                $m = new $Map();
              }
              $mapSet($m, key, value);
            } else {
              if (!$o) {
                $o = { key: {}, next: null };
              }
              listSet($o, key, value);
            }
          }
        };
        return channel;
      };
    }
  });

  // node_modules/qs/lib/formats.js
  var require_formats = __commonJS({
    "node_modules/qs/lib/formats.js"(exports, module) {
      "use strict";
      var replace = String.prototype.replace;
      var percentTwenties = /%20/g;
      var Format = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
      };
      module.exports = {
        "default": Format.RFC3986,
        formatters: {
          RFC1738: function(value) {
            return replace.call(value, percentTwenties, "+");
          },
          RFC3986: function(value) {
            return String(value);
          }
        },
        RFC1738: Format.RFC1738,
        RFC3986: Format.RFC3986
      };
    }
  });

  // node_modules/qs/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/qs/lib/utils.js"(exports, module) {
      "use strict";
      var formats2 = require_formats();
      var has = Object.prototype.hasOwnProperty;
      var isArray = Array.isArray;
      var hexTable = function() {
        var array = [];
        for (var i2 = 0; i2 < 256; ++i2) {
          array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
        }
        return array;
      }();
      var compactQueue = function compactQueue2(queue) {
        while (queue.length > 1) {
          var item = queue.pop();
          var obj = item.obj[item.prop];
          if (isArray(obj)) {
            var compacted = [];
            for (var j2 = 0; j2 < obj.length; ++j2) {
              if (typeof obj[j2] !== "undefined") {
                compacted.push(obj[j2]);
              }
            }
            item.obj[item.prop] = compacted;
          }
        }
      };
      var arrayToObject = function arrayToObject2(source2, options) {
        var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        for (var i2 = 0; i2 < source2.length; ++i2) {
          if (typeof source2[i2] !== "undefined") {
            obj[i2] = source2[i2];
          }
        }
        return obj;
      };
      var merge = function merge2(target, source2, options) {
        if (!source2) {
          return target;
        }
        if (typeof source2 !== "object") {
          if (isArray(target)) {
            target.push(source2);
          } else if (target && typeof target === "object") {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source2)) {
              target[source2] = true;
            }
          } else {
            return [target, source2];
          }
          return target;
        }
        if (!target || typeof target !== "object") {
          return [target].concat(source2);
        }
        var mergeTarget = target;
        if (isArray(target) && !isArray(source2)) {
          mergeTarget = arrayToObject(target, options);
        }
        if (isArray(target) && isArray(source2)) {
          source2.forEach(function(item, i2) {
            if (has.call(target, i2)) {
              var targetItem = target[i2];
              if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                target[i2] = merge2(targetItem, item, options);
              } else {
                target.push(item);
              }
            } else {
              target[i2] = item;
            }
          });
          return target;
        }
        return Object.keys(source2).reduce(function(acc, key) {
          var value = source2[key];
          if (has.call(acc, key)) {
            acc[key] = merge2(acc[key], value, options);
          } else {
            acc[key] = value;
          }
          return acc;
        }, mergeTarget);
      };
      var assign = function assignSingleSource(target, source2) {
        return Object.keys(source2).reduce(function(acc, key) {
          acc[key] = source2[key];
          return acc;
        }, target);
      };
      var decode = function(str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, " ");
        if (charset === "iso-8859-1") {
          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        try {
          return decodeURIComponent(strWithoutPlus);
        } catch (e2) {
          return strWithoutPlus;
        }
      };
      var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
        if (str.length === 0) {
          return str;
        }
        var string = str;
        if (typeof str === "symbol") {
          string = Symbol.prototype.toString.call(str);
        } else if (typeof str !== "string") {
          string = String(str);
        }
        if (charset === "iso-8859-1") {
          return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
          });
        }
        var out2 = "";
        for (var i2 = 0; i2 < string.length; ++i2) {
          var c2 = string.charCodeAt(i2);
          if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats2.RFC1738 && (c2 === 40 || c2 === 41)) {
            out2 += string.charAt(i2);
            continue;
          }
          if (c2 < 128) {
            out2 = out2 + hexTable[c2];
            continue;
          }
          if (c2 < 2048) {
            out2 = out2 + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
            continue;
          }
          if (c2 < 55296 || c2 >= 57344) {
            out2 = out2 + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
            continue;
          }
          i2 += 1;
          c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i2) & 1023);
          out2 += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        }
        return out2;
      };
      var compact = function compact2(value) {
        var queue = [{ obj: { o: value }, prop: "o" }];
        var refs = [];
        for (var i2 = 0; i2 < queue.length; ++i2) {
          var item = queue[i2];
          var obj = item.obj[item.prop];
          var keys = Object.keys(obj);
          for (var j2 = 0; j2 < keys.length; ++j2) {
            var key = keys[j2];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
              queue.push({ obj, prop: key });
              refs.push(val);
            }
          }
        }
        compactQueue(queue);
        return value;
      };
      var isRegExp = function isRegExp2(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      };
      var isBuffer = function isBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
      };
      var combine = function combine2(a2, b2) {
        return [].concat(a2, b2);
      };
      var maybeMap = function maybeMap2(val, fn) {
        if (isArray(val)) {
          var mapped = [];
          for (var i2 = 0; i2 < val.length; i2 += 1) {
            mapped.push(fn(val[i2]));
          }
          return mapped;
        }
        return fn(val);
      };
      module.exports = {
        arrayToObject,
        assign,
        combine,
        compact,
        decode,
        encode,
        isBuffer,
        isRegExp,
        maybeMap,
        merge
      };
    }
  });

  // node_modules/qs/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/qs/lib/stringify.js"(exports, module) {
      "use strict";
      var getSideChannel = require_side_channel();
      var utils = require_utils();
      var formats2 = require_formats();
      var has = Object.prototype.hasOwnProperty;
      var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
          return prefix + "[]";
        },
        comma: "comma",
        indices: function indices2(prefix, key) {
          return prefix + "[" + key + "]";
        },
        repeat: function repeat(prefix) {
          return prefix;
        }
      };
      var isArray = Array.isArray;
      var push = Array.prototype.push;
      var pushToArray = function(arr, valueOrArray) {
        push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
      };
      var toISO = Date.prototype.toISOString;
      var defaultFormat = formats2["default"];
      var defaults = {
        addQueryPrefix: false,
        allowDots: false,
        charset: "utf-8",
        charsetSentinel: false,
        delimiter: "&",
        encode: true,
        encoder: utils.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats2.formatters[defaultFormat],
        indices: false,
        serializeDate: function serializeDate(date) {
          return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
      };
      var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
        return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
      };
      var sentinel = {};
      var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
        var obj = object;
        var tmpSc = sideChannel;
        var step = 0;
        var findFlag = false;
        while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
          var pos = tmpSc.get(object);
          step += 1;
          if (typeof pos !== "undefined") {
            if (pos === step) {
              throw new RangeError("Cyclic object value");
            } else {
              findFlag = true;
            }
          }
          if (typeof tmpSc.get(sentinel) === "undefined") {
            step = 0;
          }
        }
        if (typeof filter === "function") {
          obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
          obj = serializeDate(obj);
        } else if (generateArrayPrefix === "comma" && isArray(obj)) {
          obj = utils.maybeMap(obj, function(value2) {
            if (value2 instanceof Date) {
              return serializeDate(value2);
            }
            return value2;
          });
        }
        if (obj === null) {
          if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format2) : prefix;
          }
          obj = "";
        }
        if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
          if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format2);
            return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format2))];
          }
          return [formatter(prefix) + "=" + formatter(String(obj))];
        }
        var values = [];
        if (typeof obj === "undefined") {
          return values;
        }
        var objKeys;
        if (generateArrayPrefix === "comma" && isArray(obj)) {
          if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
          }
          objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
        } else if (isArray(filter)) {
          objKeys = filter;
        } else {
          var keys = Object.keys(obj);
          objKeys = sort ? keys.sort(sort) : keys;
        }
        var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
        for (var j2 = 0; j2 < objKeys.length; ++j2) {
          var key = objKeys[j2];
          var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
          if (skipNulls && value === null) {
            continue;
          }
          var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
          sideChannel.set(object, step);
          var valueSideChannel = getSideChannel();
          valueSideChannel.set(sentinel, sideChannel);
          pushToArray(values, stringify2(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format2,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
          ));
        }
        return values;
      };
      var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
        if (!opts) {
          return defaults;
        }
        if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
          throw new TypeError("Encoder has to be a function.");
        }
        var charset = opts.charset || defaults.charset;
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var format2 = formats2["default"];
        if (typeof opts.format !== "undefined") {
          if (!has.call(formats2.formatters, opts.format)) {
            throw new TypeError("Unknown format option provided.");
          }
          format2 = opts.format;
        }
        var formatter = formats2.formatters[format2];
        var filter = defaults.filter;
        if (typeof opts.filter === "function" || isArray(opts.filter)) {
          filter = opts.filter;
        }
        return {
          addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
          encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
          encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
          encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
          filter,
          format: format2,
          formatter,
          serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
          skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
          sort: typeof opts.sort === "function" ? opts.sort : null,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };
      module.exports = function(object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);
        var objKeys;
        var filter;
        if (typeof options.filter === "function") {
          filter = options.filter;
          obj = filter("", obj);
        } else if (isArray(options.filter)) {
          filter = options.filter;
          objKeys = filter;
        }
        var keys = [];
        if (typeof obj !== "object" || obj === null) {
          return "";
        }
        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
          arrayFormat = opts.arrayFormat;
        } else if (opts && "indices" in opts) {
          arrayFormat = opts.indices ? "indices" : "repeat";
        } else {
          arrayFormat = "indices";
        }
        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
          throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        }
        var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
        if (!objKeys) {
          objKeys = Object.keys(obj);
        }
        if (options.sort) {
          objKeys.sort(options.sort);
        }
        var sideChannel = getSideChannel();
        for (var i2 = 0; i2 < objKeys.length; ++i2) {
          var key = objKeys[i2];
          if (options.skipNulls && obj[key] === null) {
            continue;
          }
          pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
          ));
        }
        var joined = keys.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? "?" : "";
        if (options.charsetSentinel) {
          if (options.charset === "iso-8859-1") {
            prefix += "utf8=%26%2310003%3B&";
          } else {
            prefix += "utf8=%E2%9C%93&";
          }
        }
        return joined.length > 0 ? prefix + joined : "";
      };
    }
  });

  // node_modules/qs/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/qs/lib/parse.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var has = Object.prototype.hasOwnProperty;
      var isArray = Array.isArray;
      var defaults = {
        allowDots: false,
        allowPrototypes: false,
        allowSparse: false,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: false,
        comma: false,
        decoder: utils.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1e3,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
      };
      var interpretNumericEntities = function(str) {
        return str.replace(/&#(\d+);/g, function($0, numberStr) {
          return String.fromCharCode(parseInt(numberStr, 10));
        });
      };
      var parseArrayValue = function(val, options) {
        if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
          return val.split(",");
        }
        return val;
      };
      var isoSentinel = "utf8=%26%2310003%3B";
      var charsetSentinel = "utf8=%E2%9C%93";
      var parseValues = function parseQueryStringValues(str, options) {
        var obj = { __proto__: null };
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
        var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1;
        var i2;
        var charset = options.charset;
        if (options.charsetSentinel) {
          for (i2 = 0; i2 < parts.length; ++i2) {
            if (parts[i2].indexOf("utf8=") === 0) {
              if (parts[i2] === charsetSentinel) {
                charset = "utf-8";
              } else if (parts[i2] === isoSentinel) {
                charset = "iso-8859-1";
              }
              skipIndex = i2;
              i2 = parts.length;
            }
          }
        }
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (i2 === skipIndex) {
            continue;
          }
          var part = parts[i2];
          var bracketEqualsPos = part.indexOf("]=");
          var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
          var key, val;
          if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, "key");
            val = options.strictNullHandling ? null : "";
          } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
            val = utils.maybeMap(
              parseArrayValue(part.slice(pos + 1), options),
              function(encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, "value");
              }
            );
          }
          if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
            val = interpretNumericEntities(val);
          }
          if (part.indexOf("[]=") > -1) {
            val = isArray(val) ? [val] : val;
          }
          if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
          } else {
            obj[key] = val;
          }
        }
        return obj;
      };
      var parseObject = function(chain, val, options, valuesParsed) {
        var leaf = valuesParsed ? val : parseArrayValue(val, options);
        for (var i2 = chain.length - 1; i2 >= 0; --i2) {
          var obj;
          var root = chain[i2];
          if (root === "[]" && options.parseArrays) {
            obj = [].concat(leaf);
          } else {
            obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") {
              obj = { 0: leaf };
            } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
              obj = [];
              obj[index] = leaf;
            } else if (cleanRoot !== "__proto__") {
              obj[cleanRoot] = leaf;
            }
          }
          leaf = obj;
        }
        return leaf;
      };
      var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
        if (!givenKey) {
          return;
        }
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;
        var segment = options.depth > 0 && brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;
        var keys = [];
        if (parent) {
          if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys.push(parent);
        }
        var i2 = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
          i2 += 1;
          if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys.push(segment[1]);
        }
        if (segment) {
          keys.push("[" + key.slice(segment.index) + "]");
        }
        return parseObject(keys, val, options, valuesParsed);
      };
      var normalizeParseOptions = function normalizeParseOptions2(opts) {
        if (!opts) {
          return defaults;
        }
        if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
          throw new TypeError("Decoder has to be a function.");
        }
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
        return {
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
          allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
          arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
          decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
          delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
          depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
          ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
          interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
          parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
          parseArrays: opts.parseArrays !== false,
          plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };
      module.exports = function(str, opts) {
        var options = normalizeParseOptions(opts);
        if (str === "" || str === null || typeof str === "undefined") {
          return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        }
        var tempObj = typeof str === "string" ? parseValues(str, options) : str;
        var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var keys = Object.keys(tempObj);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
          obj = utils.merge(obj, newObj, options);
        }
        if (options.allowSparse === true) {
          return obj;
        }
        return utils.compact(obj);
      };
    }
  });

  // node_modules/qs/lib/index.js
  var require_lib = __commonJS({
    "node_modules/qs/lib/index.js"(exports, module) {
      "use strict";
      var stringify = require_stringify();
      var parse3 = require_parse();
      var formats2 = require_formats();
      module.exports = {
        formats: formats2,
        parse: parse3,
        stringify
      };
    }
  });

  // node_modules/url/url.js
  var require_url = __commonJS({
    "node_modules/url/url.js"(exports) {
      "use strict";
      var punycode = require_punycode();
      function Url() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
      }
      var protocolPattern = /^([a-z0-9.+-]+:)/i;
      var portPattern = /:[0-9]*$/;
      var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
      var delims = [
        "<",
        ">",
        '"',
        "`",
        " ",
        "\r",
        "\n",
        "	"
      ];
      var unwise = [
        "{",
        "}",
        "|",
        "\\",
        "^",
        "`"
      ].concat(delims);
      var autoEscape = ["'"].concat(unwise);
      var nonHostChars = [
        "%",
        "/",
        "?",
        ";",
        "#"
      ].concat(autoEscape);
      var hostEndingChars = [
        "/",
        "?",
        "#"
      ];
      var hostnameMaxLen = 255;
      var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
      var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      var unsafeProtocol = {
        javascript: true,
        "javascript:": true
      };
      var hostlessProtocol = {
        javascript: true,
        "javascript:": true
      };
      var slashedProtocol = {
        http: true,
        https: true,
        ftp: true,
        gopher: true,
        file: true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      var querystring = require_lib();
      function urlParse(url2, parseQueryString, slashesDenoteHost) {
        if (url2 && typeof url2 === "object" && url2 instanceof Url) {
          return url2;
        }
        var u2 = new Url();
        u2.parse(url2, parseQueryString, slashesDenoteHost);
        return u2;
      }
      Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
        if (typeof url2 !== "string") {
          throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
        }
        var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, "/");
        url2 = uSplit.join(splitter);
        var rest = url2;
        rest = rest.trim();
        if (!slashesDenoteHost && url2.split("#").length === 1) {
          var simplePath = simplePathPattern.exec(rest);
          if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
              this.search = simplePath[2];
              if (parseQueryString) {
                this.query = querystring.parse(this.search.substr(1));
              } else {
                this.query = this.search.substr(1);
              }
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            return this;
          }
        }
        var proto = protocolPattern.exec(rest);
        if (proto) {
          proto = proto[0];
          var lowerProto = proto.toLowerCase();
          this.protocol = lowerProto;
          rest = rest.substr(proto.length);
        }
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
          var slashes = rest.substr(0, 2) === "//";
          if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
          }
        }
        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
          var hostEnd = -1;
          for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
            var hec = rest.indexOf(hostEndingChars[i2]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
              hostEnd = hec;
            }
          }
          var auth, atSign;
          if (hostEnd === -1) {
            atSign = rest.lastIndexOf("@");
          } else {
            atSign = rest.lastIndexOf("@", hostEnd);
          }
          if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
          }
          hostEnd = -1;
          for (var i2 = 0; i2 < nonHostChars.length; i2++) {
            var hec = rest.indexOf(nonHostChars[i2]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
              hostEnd = hec;
            }
          }
          if (hostEnd === -1) {
            hostEnd = rest.length;
          }
          this.host = rest.slice(0, hostEnd);
          rest = rest.slice(hostEnd);
          this.parseHost();
          this.hostname = this.hostname || "";
          var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
              var part = hostparts[i2];
              if (!part) {
                continue;
              }
              if (!part.match(hostnamePartPattern)) {
                var newpart = "";
                for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
                  if (part.charCodeAt(j2) > 127) {
                    newpart += "x";
                  } else {
                    newpart += part[j2];
                  }
                }
                if (!newpart.match(hostnamePartPattern)) {
                  var validParts = hostparts.slice(0, i2);
                  var notHost = hostparts.slice(i2 + 1);
                  var bit = part.match(hostnamePartStart);
                  if (bit) {
                    validParts.push(bit[1]);
                    notHost.unshift(bit[2]);
                  }
                  if (notHost.length) {
                    rest = "/" + notHost.join(".") + rest;
                  }
                  this.hostname = validParts.join(".");
                  break;
                }
              }
            }
          }
          if (this.hostname.length > hostnameMaxLen) {
            this.hostname = "";
          } else {
            this.hostname = this.hostname.toLowerCase();
          }
          if (!ipv6Hostname) {
            this.hostname = punycode.toASCII(this.hostname);
          }
          var p2 = this.port ? ":" + this.port : "";
          var h2 = this.hostname || "";
          this.host = h2 + p2;
          this.href += this.host;
          if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") {
              rest = "/" + rest;
            }
          }
        }
        if (!unsafeProtocol[lowerProto]) {
          for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
            var ae = autoEscape[i2];
            if (rest.indexOf(ae) === -1) {
              continue;
            }
            var esc = encodeURIComponent(ae);
            if (esc === ae) {
              esc = escape(ae);
            }
            rest = rest.split(ae).join(esc);
          }
        }
        var hash = rest.indexOf("#");
        if (hash !== -1) {
          this.hash = rest.substr(hash);
          rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf("?");
        if (qm !== -1) {
          this.search = rest.substr(qm);
          this.query = rest.substr(qm + 1);
          if (parseQueryString) {
            this.query = querystring.parse(this.query);
          }
          rest = rest.slice(0, qm);
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        if (rest) {
          this.pathname = rest;
        }
        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
          this.pathname = "/";
        }
        if (this.pathname || this.search) {
          var p2 = this.pathname || "";
          var s2 = this.search || "";
          this.path = p2 + s2;
        }
        this.href = this.format();
        return this;
      };
      function urlFormat(obj) {
        if (typeof obj === "string") {
          obj = urlParse(obj);
        }
        if (!(obj instanceof Url)) {
          return Url.prototype.format.call(obj);
        }
        return obj.format();
      }
      Url.prototype.format = function() {
        var auth = this.auth || "";
        if (auth) {
          auth = encodeURIComponent(auth);
          auth = auth.replace(/%3A/i, ":");
          auth += "@";
        }
        var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
        if (this.host) {
          host = auth + this.host;
        } else if (this.hostname) {
          host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
          if (this.port) {
            host += ":" + this.port;
          }
        }
        if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
          query = querystring.stringify(this.query, {
            arrayFormat: "repeat",
            addQueryPrefix: false
          });
        }
        var search = this.search || query && "?" + query || "";
        if (protocol && protocol.substr(-1) !== ":") {
          protocol += ":";
        }
        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
          host = "//" + (host || "");
          if (pathname && pathname.charAt(0) !== "/") {
            pathname = "/" + pathname;
          }
        } else if (!host) {
          host = "";
        }
        if (hash && hash.charAt(0) !== "#") {
          hash = "#" + hash;
        }
        if (search && search.charAt(0) !== "?") {
          search = "?" + search;
        }
        pathname = pathname.replace(/[?#]/g, function(match) {
          return encodeURIComponent(match);
        });
        search = search.replace("#", "%23");
        return protocol + host + pathname + search + hash;
      };
      function urlResolve(source2, relative) {
        return urlParse(source2, false, true).resolve(relative);
      }
      Url.prototype.resolve = function(relative) {
        return this.resolveObject(urlParse(relative, false, true)).format();
      };
      function urlResolveObject(source2, relative) {
        if (!source2) {
          return relative;
        }
        return urlParse(source2, false, true).resolveObject(relative);
      }
      Url.prototype.resolveObject = function(relative) {
        if (typeof relative === "string") {
          var rel = new Url();
          rel.parse(relative, false, true);
          relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative.slashes && !relative.protocol) {
          var rkeys = Object.keys(relative);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol") {
              result[rkey] = relative[rkey];
            }
          }
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.pathname = "/";
            result.path = result.pathname;
          }
          result.href = result.format();
          return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
          if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for (var v2 = 0; v2 < keys.length; v2++) {
              var k2 = keys[v2];
              result[k2] = relative[k2];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative.protocol;
          if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift())) {
            }
            if (!relative.host) {
              relative.host = "";
            }
            if (!relative.hostname) {
              relative.hostname = "";
            }
            if (relPath[0] !== "") {
              relPath.unshift("");
            }
            if (relPath.length < 2) {
              relPath.unshift("");
            }
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative.pathname;
          }
          result.search = relative.search;
          result.query = relative.query;
          result.host = relative.host || "";
          result.auth = relative.auth;
          result.hostname = relative.hostname || relative.host;
          result.port = relative.port;
          if (result.pathname || result.search) {
            var p2 = result.pathname || "";
            var s2 = result.search || "";
            result.path = p2 + s2;
          }
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "") {
              srcPath[0] = result.host;
            } else {
              srcPath.unshift(result.host);
            }
          }
          result.host = "";
          if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
              if (relPath[0] === "") {
                relPath[0] = relative.host;
              } else {
                relPath.unshift(relative.host);
              }
            }
            relative.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
          result.host = relative.host || relative.host === "" ? relative.host : result.host;
          result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
          result.search = relative.search;
          result.query = relative.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath) {
            srcPath = [];
          }
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative.search;
          result.query = relative.query;
        } else if (relative.search != null) {
          if (psychotic) {
            result.host = srcPath.shift();
            result.hostname = result.host;
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.hostname = authInHost.shift();
              result.host = result.hostname;
            }
          }
          result.search = relative.search;
          result.query = relative.query;
          if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        var up = 0;
        for (var i2 = srcPath.length; i2 >= 0; i2--) {
          last = srcPath[i2];
          if (last === ".") {
            srcPath.splice(i2, 1);
          } else if (last === "..") {
            srcPath.splice(i2, 1);
            up++;
          } else if (up) {
            srcPath.splice(i2, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
          result.host = result.hostname;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
          srcPath.unshift("");
        }
        if (srcPath.length > 0) {
          result.pathname = srcPath.join("/");
        } else {
          result.pathname = null;
          result.path = null;
        }
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      };
      Url.prototype.parseHost = function() {
        var host = this.host;
        var port = portPattern.exec(host);
        if (port) {
          port = port[0];
          if (port !== ":") {
            this.port = port.substr(1);
          }
          host = host.substr(0, host.length - port.length);
        }
        if (host) {
          this.hostname = host;
        }
      };
      exports.parse = urlParse;
      exports.resolve = urlResolve;
      exports.resolveObject = urlResolveObject;
      exports.format = urlFormat;
      exports.Url = Url;
    }
  });

  // node_modules/@pixi/utils/lib/logging/deprecation.mjs
  function deprecation(version, message, ignoreDepth = 3) {
    if (warnings[message])
      return;
    let stack = new Error().stack;
    typeof stack > "u" ? console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`) : (stack = stack.split(`
`).splice(ignoreDepth).join(`
`), console.groupCollapsed ? (console.groupCollapsed(
      "%cPixiJS Deprecation Warning: %c%s",
      "color:#614108;background:#fffbe6",
      "font-weight:normal;color:#614108;background:#fffbe6",
      `${message}
Deprecated since v${version}`
    ), console.warn(stack), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`), console.warn(stack))), warnings[message] = true;
  }
  var warnings;
  var init_deprecation = __esm({
    "node_modules/@pixi/utils/lib/logging/deprecation.mjs"() {
      warnings = {};
    }
  });

  // node_modules/@pixi/utils/lib/url.mjs
  var import_url, url;
  var init_url = __esm({
    "node_modules/@pixi/utils/lib/url.mjs"() {
      import_url = __toESM(require_url(), 1);
      init_deprecation();
      url = {
        get parse() {
          return deprecation("7.3.0", "utils.url.parse is deprecated, use native URL API instead."), import_url.parse;
        },
        get format() {
          return deprecation("7.3.0", "utils.url.format is deprecated, use native URL API instead."), import_url.format;
        },
        get resolve() {
          return deprecation("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."), import_url.resolve;
        }
      };
    }
  });

  // node_modules/@pixi/utils/lib/path.mjs
  function assertPath(path22) {
    if (typeof path22 != "string")
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path22)}`);
  }
  function removeUrlParams(url2) {
    return url2.split("?")[0].split("#")[0];
  }
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
  }
  function normalizeStringPosix(path22, allowAboveRoot) {
    let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code = -1;
    for (let i2 = 0; i2 <= path22.length; ++i2) {
      if (i2 < path22.length)
        code = path22.charCodeAt(i2);
      else {
        if (code === 47)
          break;
        code = 47;
      }
      if (code === 47) {
        if (!(lastSlash === i2 - 1 || dots === 1))
          if (lastSlash !== i2 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                const lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = i2, dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "", lastSegmentLength = 0, lastSlash = i2, dots = 0;
                continue;
              }
            }
            allowAboveRoot && (res.length > 0 ? res += "/.." : res = "..", lastSegmentLength = 2);
          } else
            res.length > 0 ? res += `/${path22.slice(lastSlash + 1, i2)}` : res = path22.slice(lastSlash + 1, i2), lastSegmentLength = i2 - lastSlash - 1;
        lastSlash = i2, dots = 0;
      } else
        code === 46 && dots !== -1 ? ++dots : dots = -1;
    }
    return res;
  }
  var path;
  var init_path = __esm({
    "node_modules/@pixi/utils/lib/path.mjs"() {
      init_lib2();
      path = {
        toPosix(path22) {
          return replaceAll(path22, "\\", "/");
        },
        isUrl(path22) {
          return /^https?:/.test(this.toPosix(path22));
        },
        isDataUrl(path22) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path22);
        },
        isBlobUrl(path22) {
          return path22.startsWith("blob:");
        },
        hasProtocol(path22) {
          return /^[^/:]+:/.test(this.toPosix(path22));
        },
        getProtocol(path22) {
          assertPath(path22), path22 = this.toPosix(path22);
          const matchFile = /^file:\/\/\//.exec(path22);
          if (matchFile)
            return matchFile[0];
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path22);
          return matchProtocol ? matchProtocol[0] : "";
        },
        toAbsolute(url2, customBaseUrl, customRootUrl) {
          if (assertPath(url2), this.isDataUrl(url2) || this.isBlobUrl(url2))
            return url2;
          const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl())), rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
          return url2 = this.toPosix(url2), url2.startsWith("/") ? path.join(rootUrl, url2.slice(1)) : this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
        },
        normalize(path22) {
          if (assertPath(path22), path22.length === 0)
            return ".";
          if (this.isDataUrl(path22) || this.isBlobUrl(path22))
            return path22;
          path22 = this.toPosix(path22);
          let protocol = "";
          const isAbsolute = path22.startsWith("/");
          this.hasProtocol(path22) && (protocol = this.rootname(path22), path22 = path22.slice(protocol.length));
          const trailingSeparator = path22.endsWith("/");
          return path22 = normalizeStringPosix(path22, false), path22.length > 0 && trailingSeparator && (path22 += "/"), isAbsolute ? `/${path22}` : protocol + path22;
        },
        isAbsolute(path22) {
          return assertPath(path22), path22 = this.toPosix(path22), this.hasProtocol(path22) ? true : path22.startsWith("/");
        },
        join(...segments) {
          if (segments.length === 0)
            return ".";
          let joined;
          for (let i2 = 0; i2 < segments.length; ++i2) {
            const arg = segments[i2];
            if (assertPath(arg), arg.length > 0)
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = segments[i2 - 1] ?? "";
                this.extname(prevArg) ? joined += `/../${arg}` : joined += `/${arg}`;
              }
          }
          return joined === void 0 ? "." : this.normalize(joined);
        },
        dirname(path22) {
          if (assertPath(path22), path22.length === 0)
            return ".";
          path22 = this.toPosix(path22);
          let code = path22.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1, matchedSlash = true;
          const proto = this.getProtocol(path22), origpath = path22;
          path22 = path22.slice(proto.length);
          for (let i2 = path22.length - 1; i2 >= 1; --i2)
            if (code = path22.charCodeAt(i2), code === 47) {
              if (!matchedSlash) {
                end = i2;
                break;
              }
            } else
              matchedSlash = false;
          return end === -1 ? hasRoot ? "/" : this.isUrl(origpath) ? proto + path22 : proto : hasRoot && end === 1 ? "//" : proto + path22.slice(0, end);
        },
        rootname(path22) {
          assertPath(path22), path22 = this.toPosix(path22);
          let root = "";
          if (path22.startsWith("/") ? root = "/" : root = this.getProtocol(path22), this.isUrl(path22)) {
            const index = path22.indexOf("/", root.length);
            index !== -1 ? root = path22.slice(0, index) : root = path22, root.endsWith("/") || (root += "/");
          }
          return root;
        },
        basename(path22, ext) {
          assertPath(path22), ext && assertPath(ext), path22 = removeUrlParams(this.toPosix(path22));
          let start = 0, end = -1, matchedSlash = true, i2;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
            if (ext.length === path22.length && ext === path22)
              return "";
            let extIdx = ext.length - 1, firstNonSlashEnd = -1;
            for (i2 = path22.length - 1; i2 >= 0; --i2) {
              const code = path22.charCodeAt(i2);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i2 + 1;
                  break;
                }
              } else
                firstNonSlashEnd === -1 && (matchedSlash = false, firstNonSlashEnd = i2 + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx === -1 && (end = i2) : (extIdx = -1, end = firstNonSlashEnd));
            }
            return start === end ? end = firstNonSlashEnd : end === -1 && (end = path22.length), path22.slice(start, end);
          }
          for (i2 = path22.length - 1; i2 >= 0; --i2)
            if (path22.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else
              end === -1 && (matchedSlash = false, end = i2 + 1);
          return end === -1 ? "" : path22.slice(start, end);
        },
        extname(path22) {
          assertPath(path22), path22 = removeUrlParams(this.toPosix(path22));
          let startDot = -1, startPart = 0, end = -1, matchedSlash = true, preDotState = 0;
          for (let i2 = path22.length - 1; i2 >= 0; --i2) {
            const code = path22.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            end === -1 && (matchedSlash = false, end = i2 + 1), code === 46 ? startDot === -1 ? startDot = i2 : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
          }
          return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path22.slice(startDot, end);
        },
        parse(path22) {
          assertPath(path22);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path22.length === 0)
            return ret;
          path22 = removeUrlParams(this.toPosix(path22));
          let code = path22.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path22);
          let start;
          const protocol = "";
          ret.root = this.rootname(path22), isAbsolute || this.hasProtocol(path22) ? start = 1 : start = 0;
          let startDot = -1, startPart = 0, end = -1, matchedSlash = true, i2 = path22.length - 1, preDotState = 0;
          for (; i2 >= start; --i2) {
            if (code = path22.charCodeAt(i2), code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            end === -1 && (matchedSlash = false, end = i2 + 1), code === 46 ? startDot === -1 ? startDot = i2 : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -1);
          }
          return startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (startPart === 0 && isAbsolute ? ret.base = ret.name = path22.slice(1, end) : ret.base = ret.name = path22.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path22.slice(1, startDot), ret.base = path22.slice(1, end)) : (ret.name = path22.slice(startPart, startDot), ret.base = path22.slice(startPart, end)), ret.ext = path22.slice(startDot, end)), ret.dir = this.dirname(path22), protocol && (ret.dir = protocol + ret.dir), ret;
        },
        sep: "/",
        delimiter: ":"
      };
    }
  });

  // node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.mjs
  async function detectVideoAlphaMode() {
    return promise ?? (promise = (async () => {
      const gl = document.createElement("canvas").getContext("webgl");
      if (!gl)
        return ALPHA_MODES.UNPACK;
      const video = await new Promise((resolve2) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve2(video2), video2.onerror = () => resolve2(null), video2.autoplay = false, video2.crossOrigin = "anonymous", video2.preload = "auto", video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", video2.load();
      });
      if (!video)
        return ALPHA_MODES.UNPACK;
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer), gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      ), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      return gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel), gl.deleteFramebuffer(framebuffer), gl.deleteTexture(texture), gl.getExtension("WEBGL_lose_context")?.loseContext(), pixel[0] <= pixel[3] ? ALPHA_MODES.PMA : ALPHA_MODES.UNPACK;
    })()), promise;
  }
  var promise;
  var init_detectVideoAlphaMode = __esm({
    "node_modules/@pixi/utils/lib/browser/detectVideoAlphaMode.mjs"() {
      init_lib();
    }
  });

  // node_modules/@pixi/utils/lib/browser/hello.mjs
  function skipHello() {
    deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
  }
  function sayHello() {
    deprecation("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
  }
  var init_hello = __esm({
    "node_modules/@pixi/utils/lib/browser/hello.mjs"() {
      init_deprecation();
    }
  });

  // node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs
  function isWebGLSupported() {
    return typeof supported > "u" && (supported = function() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!settings.ADAPTER.getWebGLRenderingContext())
          return false;
        const canvas = settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          loseContext && loseContext.loseContext();
        }
        return gl = null, success;
      } catch {
        return false;
      }
    }()), supported;
  }
  var supported;
  var init_isWebGLSupported = __esm({
    "node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs"() {
      init_settings2();
      init_lib2();
    }
  });

  // node_modules/@pixi/colord/index.mjs
  var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "node_modules/@pixi/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t2 = r2.toString(16);
        return t2.length < 2 ? "0" + t2 : t2;
      };
      h = function(r2) {
        var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
        return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
        var t2, n2, e2;
      };
      c = function(r2) {
        return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
        var t2, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t2 = i.exec(r2);
        return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t2 = v.exec(r2) || m.exec(r2);
        return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t2) {
        var n2 = l.exec(t2) || p.exec(t2);
        if (!n2)
          return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2))
          return null;
        var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i2);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
        if (!t(n2) || !t(a2) || !t(o2))
          return null;
        var h2 = function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var e2 = t2[n2][0](r2);
          if (e2)
            return [e2, t2[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
      };
      j = function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
          var r3, t2, e2, u2, a2, i2;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
          var t2;
        }, r2.prototype.hue = function(r3) {
          var t2 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      }();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // node_modules/@pixi/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d2 in a2)
      r2[a2[d2]] = d2;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d3, i2, n2 = r2[this.toHex()];
      if (n2)
        return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length)
          for (var c2 in a2)
            l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
      return d3 ? new e2(d3).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "node_modules/@pixi/colord/plugins/names.mjs"() {
    }
  });

  // node_modules/@pixi/color/lib/Color.mjs
  var _Color, Color;
  var init_Color = __esm({
    "node_modules/@pixi/color/lib/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color = class _Color2 {
        constructor(value = 16777215) {
          this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = value;
        }
        get red() {
          return this._components[0];
        }
        get green() {
          return this._components[1];
        }
        get blue() {
          return this._components[2];
        }
        get alpha() {
          return this._components[3];
        }
        setValue(value) {
          return this.value = value, this;
        }
        set value(value) {
          if (value instanceof _Color2)
            this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);
          else {
            if (value === null)
              throw new Error("Cannot set PIXI.Color#value to null");
            (this._value === null || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));
          }
        }
        get value() {
          return this._value;
        }
        cloneSource(value) {
          return typeof value == "string" || typeof value == "number" || value instanceof Number || value === null ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : typeof value == "object" && value !== null ? { ...value } : value;
        }
        isSourceEqual(value1, value2) {
          const type1 = typeof value1;
          if (type1 !== typeof value2)
            return false;
          if (type1 === "number" || type1 === "string" || value1 instanceof Number)
            return value1 === value2;
          if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))
            return value1.length !== value2.length ? false : value1.every((v2, i2) => v2 === value2[i2]);
          if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1), keys2 = Object.keys(value2);
            return keys1.length !== keys2.length ? false : keys1.every((key) => value1[key] === value2[key]);
          }
          return value1 === value2;
        }
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          return out2 = out2 ?? [], out2[0] = Math.round(r2 * 255), out2[1] = Math.round(g2 * 255), out2[2] = Math.round(b2 * 255), out2;
        }
        toRgbArray(out2) {
          out2 = out2 ?? [];
          const [r2, g2, b2] = this._components;
          return out2[0] = r2, out2[1] = g2, out2[2] = b2, out2;
        }
        toNumber() {
          return this._int;
        }
        toLittleEndianNumber() {
          const value = this._int;
          return (value >> 16) + (value & 65280) + ((value & 255) << 16);
        }
        multiply(value) {
          const [r2, g2, b2, a2] = _Color2.temp.setValue(value)._components;
          return this._components[0] *= r2, this._components[1] *= g2, this._components[2] *= b2, this._components[3] *= a2, this.refreshInt(), this._value = null, this;
        }
        premultiply(alpha, applyToRGB = true) {
          return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;
        }
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1)
            return (255 << 24) + this._int;
          if (alpha === 0)
            return applyToRGB ? 0 : this._int;
          let r2 = this._int >> 16 & 255, g2 = this._int >> 8 & 255, b2 = this._int & 255;
          return applyToRGB && (r2 = r2 * alpha + 0.5 | 0, g2 = g2 * alpha + 0.5 | 0, b2 = b2 * alpha + 0.5 | 0), (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        toHexa() {
          const alphaString = Math.round(this._components[3] * 255).toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        setAlpha(alpha) {
          return this._components[3] = this._clamp(alpha), this;
        }
        round(steps) {
          const [r2, g2, b2] = this._components;
          return this._components[0] = Math.round(r2 * steps) / steps, this._components[1] = Math.round(g2 * steps) / steps, this._components[2] = Math.round(b2 * steps) / steps, this.refreshInt(), this._value = null, this;
        }
        toArray(out2) {
          out2 = out2 ?? [];
          const [r2, g2, b2, a2] = this._components;
          return out2[0] = r2, out2[1] = g2, out2[2] = b2, out2[3] = a2, out2;
        }
        normalize(value) {
          let r2, g2, b2, a2;
          if ((typeof value == "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r2 = (int >> 16 & 255) / 255, g2 = (int >> 8 & 255) / 255, b2 = (int & 255) / 255, a2 = 1;
          } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4)
            value = this._clamp(value), [r2, g2, b2, a2 = 1] = value;
          else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4)
            value = this._clamp(value, 0, 255), [r2, g2, b2, a2 = 255] = value, r2 /= 255, g2 /= 255, b2 /= 255, a2 /= 255;
          else if (typeof value == "string" || typeof value == "object") {
            if (typeof value == "string") {
              const match = _Color2.HEX_PATTERN.exec(value);
              match && (value = `#${match[2]}`);
            }
            const color = w(value);
            color.isValid() && ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba, r2 /= 255, g2 /= 255, b2 /= 255);
          }
          if (r2 !== void 0)
            this._components[0] = r2, this._components[1] = g2, this._components[2] = b2, this._components[3] = a2, this.refreshInt();
          else
            throw new Error(`Unable to convert color ${value}`);
        }
        refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        _clamp(value, min = 0, max = 1) {
          return typeof value == "number" ? Math.min(Math.max(value, min), max) : (value.forEach((v2, i2) => {
            value[i2] = Math.min(Math.max(v2, min), max);
          }), value);
        }
      };
      _Color.shared = new _Color(), _Color.temp = new _Color(), _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
      Color = _Color;
    }
  });

  // node_modules/@pixi/color/lib/index.mjs
  var init_lib3 = __esm({
    "node_modules/@pixi/color/lib/index.mjs"() {
      init_Color();
    }
  });

  // node_modules/@pixi/utils/lib/color/hex.mjs
  function hex2rgb(hex, out2 = []) {
    return deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"), Color.shared.setValue(hex).toRgbArray(out2);
  }
  function hex2string(hex) {
    return deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), Color.shared.setValue(hex).toHex();
  }
  function string2hex(string) {
    return deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"), Color.shared.setValue(string).toNumber();
  }
  function rgb2hex(rgb) {
    return deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), Color.shared.setValue(rgb).toNumber();
  }
  var init_hex = __esm({
    "node_modules/@pixi/utils/lib/color/hex.mjs"() {
      init_lib3();
      init_deprecation();
    }
  });

  // node_modules/@pixi/utils/lib/color/premultiply.mjs
  function mapPremultipliedBlendModes() {
    const pm = [], npm = [];
    for (let i2 = 0; i2 < 32; i2++)
      pm[i2] = i2, npm[i2] = i2;
    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
    const array = [];
    return array.push(npm), array.push(pm), array;
  }
  function correctBlendMode(blendMode, premultiplied) {
    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
  }
  function premultiplyRgba(rgb, alpha, out2, premultiply = true) {
    return deprecation("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"), Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out2 ?? new Float32Array(4));
  }
  function premultiplyTint(tint, alpha) {
    return deprecation("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"), Color.shared.setValue(tint).toPremultiplied(alpha);
  }
  function premultiplyTintToRgba(tint, alpha, out2, premultiply = true) {
    return deprecation("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"), Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out2 ?? new Float32Array(4));
  }
  var premultiplyBlendMode;
  var init_premultiply = __esm({
    "node_modules/@pixi/utils/lib/color/premultiply.mjs"() {
      init_lib3();
      init_lib();
      init_deprecation();
      premultiplyBlendMode = mapPremultipliedBlendModes();
    }
  });

  // node_modules/@pixi/utils/lib/const.mjs
  var DATA_URI;
  var init_const = __esm({
    "node_modules/@pixi/utils/lib/const.mjs"() {
      DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
    }
  });

  // node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs
  function createIndicesForQuads(size, outBuffer = null) {
    const totalIndices = size * 6;
    if (outBuffer = outBuffer || new Uint16Array(totalIndices), outBuffer.length !== totalIndices)
      throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
    for (let i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4)
      outBuffer[i2 + 0] = j2 + 0, outBuffer[i2 + 1] = j2 + 1, outBuffer[i2 + 2] = j2 + 2, outBuffer[i2 + 3] = j2 + 0, outBuffer[i2 + 4] = j2 + 2, outBuffer[i2 + 5] = j2 + 3;
    return outBuffer;
  }
  var init_createIndicesForQuads = __esm({
    "node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs"() {
    }
  });

  // node_modules/@pixi/utils/lib/data/getBufferType.mjs
  function getBufferType(array) {
    if (array.BYTES_PER_ELEMENT === 4)
      return array instanceof Float32Array ? "Float32Array" : array instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (array.BYTES_PER_ELEMENT === 2) {
      if (array instanceof Uint16Array)
        return "Uint16Array";
    } else if (array.BYTES_PER_ELEMENT === 1 && array instanceof Uint8Array)
      return "Uint8Array";
    return null;
  }
  var init_getBufferType = __esm({
    "node_modules/@pixi/utils/lib/data/getBufferType.mjs"() {
    }
  });

  // node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs
  function interleaveTypedArrays(arrays, sizes) {
    let outSize = 0, stride = 0;
    const views = {};
    for (let i2 = 0; i2 < arrays.length; i2++)
      stride += sizes[i2], outSize += arrays[i2].length;
    const buffer = new ArrayBuffer(outSize * 4);
    let out2 = null, littleOffset = 0;
    for (let i2 = 0; i2 < arrays.length; i2++) {
      const size = sizes[i2], array = arrays[i2], type = getBufferType(array);
      views[type] || (views[type] = new map[type](buffer)), out2 = views[type];
      for (let j2 = 0; j2 < array.length; j2++) {
        const indexStart = (j2 / size | 0) * stride + littleOffset, index = j2 % size;
        out2[indexStart + index] = array[j2];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  var map;
  var init_interleaveTypedArrays = __esm({
    "node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs"() {
      init_getBufferType();
      map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
    }
  });

  // node_modules/@pixi/utils/lib/data/pow2.mjs
  function nextPow2(v2) {
    return v2 += v2 === 0 ? 1 : 0, --v2, v2 |= v2 >>> 1, v2 |= v2 >>> 2, v2 |= v2 >>> 4, v2 |= v2 >>> 8, v2 |= v2 >>> 16, v2 + 1;
  }
  function isPow2(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  function log2(v2) {
    let r2 = (v2 > 65535 ? 1 : 0) << 4;
    v2 >>>= r2;
    let shift = (v2 > 255 ? 1 : 0) << 3;
    return v2 >>>= shift, r2 |= shift, shift = (v2 > 15 ? 1 : 0) << 2, v2 >>>= shift, r2 |= shift, shift = (v2 > 3 ? 1 : 0) << 1, v2 >>>= shift, r2 |= shift, r2 | v2 >> 1;
  }
  var init_pow2 = __esm({
    "node_modules/@pixi/utils/lib/data/pow2.mjs"() {
    }
  });

  // node_modules/@pixi/utils/lib/data/removeItems.mjs
  function removeItems(arr, startIdx, removeCount) {
    const length = arr.length;
    let i2;
    if (startIdx >= length || removeCount === 0)
      return;
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i2 = startIdx; i2 < len; ++i2)
      arr[i2] = arr[i2 + removeCount];
    arr.length = len;
  }
  var init_removeItems = __esm({
    "node_modules/@pixi/utils/lib/data/removeItems.mjs"() {
    }
  });

  // node_modules/@pixi/utils/lib/data/sign.mjs
  function sign(n2) {
    return n2 === 0 ? 0 : n2 < 0 ? -1 : 1;
  }
  var init_sign = __esm({
    "node_modules/@pixi/utils/lib/data/sign.mjs"() {
    }
  });

  // node_modules/@pixi/utils/lib/data/uid.mjs
  function uid() {
    return ++nextUid;
  }
  var nextUid;
  var init_uid = __esm({
    "node_modules/@pixi/utils/lib/data/uid.mjs"() {
      nextUid = 0;
    }
  });

  // node_modules/@pixi/utils/lib/media/BoundingBox.mjs
  var _BoundingBox, BoundingBox;
  var init_BoundingBox = __esm({
    "node_modules/@pixi/utils/lib/media/BoundingBox.mjs"() {
      _BoundingBox = class {
        constructor(left, top, right, bottom) {
          this.left = left, this.top = top, this.right = right, this.bottom = bottom;
        }
        get width() {
          return this.right - this.left;
        }
        get height() {
          return this.bottom - this.top;
        }
        isEmpty() {
          return this.left === this.right || this.top === this.bottom;
        }
      };
      _BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);
      BoundingBox = _BoundingBox;
    }
  });

  // node_modules/@pixi/utils/lib/media/caches.mjs
  function destroyTextureCache() {
    let key;
    for (key in TextureCache)
      TextureCache[key].destroy();
    for (key in BaseTextureCache)
      BaseTextureCache[key].destroy();
  }
  function clearTextureCache() {
    let key;
    for (key in TextureCache)
      delete TextureCache[key];
    for (key in BaseTextureCache)
      delete BaseTextureCache[key];
  }
  var ProgramCache, TextureCache, BaseTextureCache;
  var init_caches = __esm({
    "node_modules/@pixi/utils/lib/media/caches.mjs"() {
      ProgramCache = {};
      TextureCache = /* @__PURE__ */ Object.create(null);
      BaseTextureCache = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs
  var CanvasRenderTarget;
  var init_CanvasRenderTarget = __esm({
    "node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs"() {
      init_lib2();
      CanvasRenderTarget = class {
        constructor(width, height, resolution) {
          this._canvas = settings.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = resolution || settings.RESOLUTION, this.resize(width, height);
        }
        clear() {
          this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
        }
        resize(desiredWidth, desiredHeight) {
          this._checkDestroyed(), this._canvas.width = Math.round(desiredWidth * this.resolution), this._canvas.height = Math.round(desiredHeight * this.resolution);
        }
        destroy() {
          this._context = null, this._canvas = null;
        }
        get width() {
          return this._checkDestroyed(), this._canvas.width;
        }
        set width(val) {
          this._checkDestroyed(), this._canvas.width = Math.round(val);
        }
        get height() {
          return this._checkDestroyed(), this._canvas.height;
        }
        set height(val) {
          this._checkDestroyed(), this._canvas.height = Math.round(val);
        }
        get canvas() {
          return this._checkDestroyed(), this._canvas;
        }
        get context() {
          return this._checkDestroyed(), this._context;
        }
        _checkDestroyed() {
          if (this._canvas === null)
            throw new TypeError("The CanvasRenderTarget has already been destroyed");
        }
      };
    }
  });

  // node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs
  function checkRow(data, width, y2) {
    for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4)
      if (data[index + 3] !== 0)
        return false;
    return true;
  }
  function checkColumn(data, width, x2, top, bottom) {
    const stride = 4 * width;
    for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride)
      if (data[index + 3] !== 0)
        return false;
    return true;
  }
  function getCanvasBoundingBox(canvas) {
    const { width, height } = canvas, context3 = canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (context3 === null)
      throw new TypeError("Failed to get canvas 2D context");
    const data = context3.getImageData(0, 0, width, height).data;
    let left = 0, top = 0, right = width - 1, bottom = height - 1;
    for (; top < height && checkRow(data, width, top); )
      ++top;
    if (top === height)
      return BoundingBox.EMPTY;
    for (; checkRow(data, width, bottom); )
      --bottom;
    for (; checkColumn(data, width, left, top, bottom); )
      ++left;
    for (; checkColumn(data, width, right, top, bottom); )
      --right;
    return ++right, ++bottom, new BoundingBox(left, top, right, bottom);
  }
  var init_getCanvasBoundingBox = __esm({
    "node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs"() {
      init_BoundingBox();
    }
  });

  // node_modules/@pixi/utils/lib/media/trimCanvas.mjs
  function trimCanvas(canvas) {
    const boundingBox = getCanvasBoundingBox(canvas), { width, height } = boundingBox;
    let data = null;
    if (!boundingBox.isEmpty()) {
      const context3 = canvas.getContext("2d");
      if (context3 === null)
        throw new TypeError("Failed to get canvas 2D context");
      data = context3.getImageData(
        boundingBox.left,
        boundingBox.top,
        width,
        height
      );
    }
    return { width, height, data };
  }
  var init_trimCanvas = __esm({
    "node_modules/@pixi/utils/lib/media/trimCanvas.mjs"() {
      init_getCanvasBoundingBox();
    }
  });

  // node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs
  function decomposeDataUri(dataUri) {
    const dataUriMatch = DATA_URI.exec(dataUri);
    if (dataUriMatch)
      return {
        mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
        subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
        charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
        encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
        data: dataUriMatch[5]
      };
  }
  var init_decomposeDataUri = __esm({
    "node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs"() {
      init_const();
    }
  });

  // node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs
  function determineCrossOrigin(url2, loc = globalThis.location) {
    if (url2.startsWith("data:"))
      return "";
    loc = loc || globalThis.location;
    const parsedUrl = new URL(url2, document.baseURI);
    return parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol ? "anonymous" : "";
  }
  var init_determineCrossOrigin = __esm({
    "node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs"() {
    }
  });

  // node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs
  function getResolutionOfUrl(url2, defaultValue3 = 1) {
    const resolution = settings.RETINA_PREFIX?.exec(url2);
    return resolution ? parseFloat(resolution[1]) : defaultValue3;
  }
  var init_getResolutionOfUrl = __esm({
    "node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs"() {
      init_settings2();
      init_lib2();
    }
  });

  // node_modules/@pixi/utils/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    BaseTextureCache: () => BaseTextureCache,
    BoundingBox: () => BoundingBox,
    CanvasRenderTarget: () => CanvasRenderTarget,
    DATA_URI: () => DATA_URI,
    EventEmitter: () => import_eventemitter3.default,
    ProgramCache: () => ProgramCache,
    TextureCache: () => TextureCache,
    clearTextureCache: () => clearTextureCache,
    correctBlendMode: () => correctBlendMode,
    createIndicesForQuads: () => createIndicesForQuads,
    decomposeDataUri: () => decomposeDataUri,
    deprecation: () => deprecation,
    destroyTextureCache: () => destroyTextureCache,
    detectVideoAlphaMode: () => detectVideoAlphaMode,
    determineCrossOrigin: () => determineCrossOrigin,
    earcut: () => import_earcut.default,
    getBufferType: () => getBufferType,
    getCanvasBoundingBox: () => getCanvasBoundingBox,
    getResolutionOfUrl: () => getResolutionOfUrl,
    hex2rgb: () => hex2rgb,
    hex2string: () => hex2string,
    interleaveTypedArrays: () => interleaveTypedArrays,
    isMobile: () => isMobile2,
    isPow2: () => isPow2,
    isWebGLSupported: () => isWebGLSupported,
    log2: () => log2,
    nextPow2: () => nextPow2,
    path: () => path,
    premultiplyBlendMode: () => premultiplyBlendMode,
    premultiplyRgba: () => premultiplyRgba,
    premultiplyTint: () => premultiplyTint,
    premultiplyTintToRgba: () => premultiplyTintToRgba,
    removeItems: () => removeItems,
    rgb2hex: () => rgb2hex,
    sayHello: () => sayHello,
    sign: () => sign,
    skipHello: () => skipHello,
    string2hex: () => string2hex,
    trimCanvas: () => trimCanvas,
    uid: () => uid,
    url: () => url
  });
  var import_eventemitter3, import_earcut;
  var init_lib4 = __esm({
    "node_modules/@pixi/utils/lib/index.mjs"() {
      init_settings2();
      init_lib2();
      import_eventemitter3 = __toESM(require_eventemitter3(), 1);
      import_earcut = __toESM(require_earcut(), 1);
      init_url();
      init_path();
      init_detectVideoAlphaMode();
      init_hello();
      init_isWebGLSupported();
      init_hex();
      init_premultiply();
      init_const();
      init_createIndicesForQuads();
      init_getBufferType();
      init_interleaveTypedArrays();
      init_pow2();
      init_removeItems();
      init_sign();
      init_uid();
      init_deprecation();
      init_BoundingBox();
      init_caches();
      init_CanvasRenderTarget();
      init_getCanvasBoundingBox();
      init_trimCanvas();
      init_decomposeDataUri();
      init_determineCrossOrigin();
      init_getResolutionOfUrl();
    }
  });

  // node_modules/@pixi/extensions/lib/index.mjs
  var ExtensionType, normalizeExtension, normalizePriority, extensions;
  var init_lib5 = __esm({
    "node_modules/@pixi/extensions/lib/index.mjs"() {
      ExtensionType = /* @__PURE__ */ ((ExtensionType22) => (ExtensionType22.Renderer = "renderer", ExtensionType22.Application = "application", ExtensionType22.RendererSystem = "renderer-webgl-system", ExtensionType22.RendererPlugin = "renderer-webgl-plugin", ExtensionType22.CanvasRendererSystem = "renderer-canvas-system", ExtensionType22.CanvasRendererPlugin = "renderer-canvas-plugin", ExtensionType22.Asset = "asset", ExtensionType22.LoadParser = "load-parser", ExtensionType22.ResolveParser = "resolve-parser", ExtensionType22.CacheParser = "cache-parser", ExtensionType22.DetectionParser = "detection-parser", ExtensionType22))(ExtensionType || {});
      normalizeExtension = (ext) => {
        if (typeof ext == "function" || typeof ext == "object" && ext.extension) {
          if (!ext.extension)
            throw new Error("Extension class must have an extension object");
          ext = { ...typeof ext.extension != "object" ? { type: ext.extension } : ext.extension, ref: ext };
        }
        if (typeof ext == "object")
          ext = { ...ext };
        else
          throw new Error("Invalid extension type");
        return typeof ext.type == "string" && (ext.type = [ext.type]), ext;
      };
      normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
      extensions = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...extensions22) {
          return extensions22.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
          }), this;
        },
        add(...extensions22) {
          return extensions22.map(normalizeExtension).forEach((ext) => {
            ext.type.forEach((type) => {
              const handlers = this._addHandlers, queue = this._queue;
              handlers[type] ? handlers[type](ext) : (queue[type] = queue[type] || [], queue[type].push(ext));
            });
          }), this;
        },
        handle(type, onAdd, onRemove) {
          const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type])
            throw new Error(`Extension type ${type} already has a handler`);
          addHandlers[type] = onAdd, removeHandlers[type] = onRemove;
          const queue = this._queue;
          return queue[type] && (queue[type].forEach((ext) => onAdd(ext)), delete queue[type]), this;
        },
        handleByMap(type, map4) {
          return this.handle(
            type,
            (extension) => {
              map4[extension.name] = extension.ref;
            },
            (extension) => {
              delete map4[extension.name];
            }
          );
        },
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              list.includes(extension.ref) || (list.push(extension.ref), list.sort((a2, b2) => normalizePriority(b2, defaultPriority) - normalizePriority(a2, defaultPriority)));
            },
            (extension) => {
              const index = list.indexOf(extension.ref);
              index !== -1 && list.splice(index, 1);
            }
          );
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs
  var ViewableBuffer;
  var init_ViewableBuffer = __esm({
    "node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs"() {
      ViewableBuffer = class {
        constructor(sizeOrBuffer) {
          typeof sizeOrBuffer == "number" ? this.rawBinaryData = new ArrayBuffer(sizeOrBuffer) : sizeOrBuffer instanceof Uint8Array ? this.rawBinaryData = sizeOrBuffer.buffer : this.rawBinaryData = sizeOrBuffer, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
        }
        get int8View() {
          return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
        }
        get uint8View() {
          return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
        }
        get int16View() {
          return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
        }
        get uint16View() {
          return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
        }
        get int32View() {
          return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
        }
        view(type) {
          return this[`${type}View`];
        }
        destroy() {
          this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
        }
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs
  function generateIfTestSrc(maxIfs) {
    let src = "";
    for (let i2 = 0; i2 < maxIfs; ++i2)
      i2 > 0 && (src += `
else `), i2 < maxIfs - 1 && (src += `if(test == ${i2}.0){}`);
    return src;
  }
  function checkMaxIfStatementsInShader(maxIfs, gl) {
    if (maxIfs === 0)
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    for (; ; ) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      if (gl.shaderSource(shader, fragmentSrc), gl.compileShader(shader), !gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        maxIfs = maxIfs / 2 | 0;
      else
        break;
    }
    return maxIfs;
  }
  var fragTemplate;
  var init_checkMaxIfStatementsInShader = __esm({
    "node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs"() {
      fragTemplate = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
      ].join(`
`);
    }
  });

  // node_modules/@pixi/core/lib/state/State.mjs
  var BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, State;
  var init_State = __esm({
    "node_modules/@pixi/core/lib/state/State.mjs"() {
      init_lib();
      BLEND = 0;
      OFFSET = 1;
      CULLING = 2;
      DEPTH_TEST = 3;
      WINDING = 4;
      DEPTH_MASK = 5;
      State = class {
        constructor() {
          this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
        }
        get blend() {
          return !!(this.data & 1 << BLEND);
        }
        set blend(value) {
          !!(this.data & 1 << BLEND) !== value && (this.data ^= 1 << BLEND);
        }
        get offsets() {
          return !!(this.data & 1 << OFFSET);
        }
        set offsets(value) {
          !!(this.data & 1 << OFFSET) !== value && (this.data ^= 1 << OFFSET);
        }
        get culling() {
          return !!(this.data & 1 << CULLING);
        }
        set culling(value) {
          !!(this.data & 1 << CULLING) !== value && (this.data ^= 1 << CULLING);
        }
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST);
        }
        set depthTest(value) {
          !!(this.data & 1 << DEPTH_TEST) !== value && (this.data ^= 1 << DEPTH_TEST);
        }
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK);
        }
        set depthMask(value) {
          !!(this.data & 1 << DEPTH_MASK) !== value && (this.data ^= 1 << DEPTH_MASK);
        }
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING);
        }
        set clockwiseFrontFace(value) {
          !!(this.data & 1 << WINDING) !== value && (this.data ^= 1 << WINDING);
        }
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value) {
          this.blend = value !== BLEND_MODES.NONE, this._blendMode = value;
        }
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value) {
          this.offsets = !!value, this._polygonOffset = value;
        }
        static for2d() {
          const state = new State();
          return state.depthTest = false, state.blend = true, state;
        }
      };
      State.prototype.toString = function() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs
  function autoDetectResource(source2, options) {
    if (!source2)
      return null;
    let extension = "";
    if (typeof source2 == "string") {
      const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source2);
      result && (extension = result[1].toLowerCase());
    }
    for (let i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
      const ResourcePlugin = INSTALLED[i2];
      if (ResourcePlugin.test && ResourcePlugin.test(source2, extension))
        return new ResourcePlugin(source2, options);
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  var INSTALLED;
  var init_autoDetectResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs"() {
      INSTALLED = [];
    }
  });

  // node_modules/@pixi/runner/lib/Runner.mjs
  var Runner;
  var init_Runner = __esm({
    "node_modules/@pixi/runner/lib/Runner.mjs"() {
      Runner = class {
        constructor(name) {
          this.items = [], this._name = name, this._aliasCount = 0;
        }
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          if (arguments.length > 8)
            throw new Error("max arguments reached");
          const { name, items } = this;
          this._aliasCount++;
          for (let i2 = 0, len = items.length; i2 < len; i2++)
            items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
          return items === this.items && this._aliasCount--, this;
        }
        ensureNonAliasedItems() {
          this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
        }
        add(item) {
          return item[this._name] && (this.ensureNonAliasedItems(), this.remove(item), this.items.push(item)), this;
        }
        remove(item) {
          const index = this.items.indexOf(item);
          return index !== -1 && (this.ensureNonAliasedItems(), this.items.splice(index, 1)), this;
        }
        contains(item) {
          return this.items.includes(item);
        }
        removeAll() {
          return this.ensureNonAliasedItems(), this.items.length = 0, this;
        }
        destroy() {
          this.removeAll(), this.items = null, this._name = null;
        }
        get empty() {
          return this.items.length === 0;
        }
        get name() {
          return this._name;
        }
      };
      Object.defineProperties(Runner.prototype, {
        dispatch: { value: Runner.prototype.emit },
        run: { value: Runner.prototype.emit }
      });
    }
  });

  // node_modules/@pixi/runner/lib/index.mjs
  var init_lib6 = __esm({
    "node_modules/@pixi/runner/lib/index.mjs"() {
      init_Runner();
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/Resource.mjs
  var Resource;
  var init_Resource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/Resource.mjs"() {
      init_lib6();
      Resource = class {
        constructor(width = 0, height = 0) {
          this._width = width, this._height = height, this.destroyed = false, this.internal = false, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
        }
        bind(baseTexture) {
          this.onResize.add(baseTexture), this.onUpdate.add(baseTexture), this.onError.add(baseTexture), (this._width || this._height) && this.onResize.emit(this._width, this._height);
        }
        unbind(baseTexture) {
          this.onResize.remove(baseTexture), this.onUpdate.remove(baseTexture), this.onError.remove(baseTexture);
        }
        resize(width, height) {
          (width !== this._width || height !== this._height) && (this._width = width, this._height = height, this.onResize.emit(width, height));
        }
        get valid() {
          return !!this._width && !!this._height;
        }
        update() {
          this.destroyed || this.onUpdate.emit();
        }
        load() {
          return Promise.resolve(this);
        }
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        style(_renderer, _baseTexture, _glTexture) {
          return false;
        }
        dispose() {
        }
        destroy() {
          this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
        }
        static test(_source, _extension) {
          return false;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs
  var BufferResource;
  var init_BufferResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs"() {
      init_lib();
      init_Resource();
      BufferResource = class extends Resource {
        constructor(source2, options) {
          const { width, height } = options || {};
          if (!width || !height)
            throw new Error("BufferResource width or height invalid");
          super(width, height), this.data = source2, this.unpackAlignment = options.unpackAlignment ?? 4;
        }
        upload(renderer, baseTexture, glTexture) {
          const gl = renderer.gl;
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment), gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK);
          const width = baseTexture.realWidth, height = baseTexture.realHeight;
          return glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(
            baseTexture.target,
            0,
            0,
            0,
            width,
            height,
            baseTexture.format,
            glTexture.type,
            this.data
          ) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(
            baseTexture.target,
            0,
            glTexture.internalFormat,
            width,
            height,
            0,
            baseTexture.format,
            glTexture.type,
            this.data
          )), true;
        }
        dispose() {
          this.data = null;
        }
        static test(source2) {
          return source2 === null || source2 instanceof Int8Array || source2 instanceof Uint8Array || source2 instanceof Uint8ClampedArray || source2 instanceof Int16Array || source2 instanceof Uint16Array || source2 instanceof Int32Array || source2 instanceof Uint32Array || source2 instanceof Float32Array;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/BaseTexture.mjs
  var defaultBufferOptions, _BaseTexture, BaseTexture;
  var init_BaseTexture = __esm({
    "node_modules/@pixi/core/lib/textures/BaseTexture.mjs"() {
      init_lib();
      init_lib2();
      init_lib4();
      init_autoDetectResource();
      init_BufferResource();
      init_Resource();
      defaultBufferOptions = {
        scaleMode: SCALE_MODES.NEAREST,
        alphaMode: ALPHA_MODES.NPM
      };
      _BaseTexture = class _BaseTexture2 extends import_eventemitter3.default {
        constructor(resource = null, options = null) {
          super(), options = Object.assign({}, _BaseTexture2.defaultOptions, options);
          const {
            alphaMode,
            mipmap,
            anisotropicLevel,
            scaleMode,
            width,
            height,
            wrapMode,
            format: format2,
            type,
            target,
            resolution,
            resourceOptions
          } = options;
          resource && !(resource instanceof Resource) && (resource = autoDetectResource(resource, resourceOptions), resource.internal = true), this.resolution = resolution || settings.RESOLUTION, this.width = Math.round((width || 0) * this.resolution) / this.resolution, this.height = Math.round((height || 0) * this.resolution) / this.resolution, this._mipmap = mipmap, this.anisotropicLevel = anisotropicLevel, this._wrapMode = wrapMode, this._scaleMode = scaleMode, this.format = format2, this.type = type, this.target = target, this.alphaMode = alphaMode, this.uid = uid(), this.touched = 0, this.isPowerOfTwo = false, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = width > 0 && height > 0, this.textureCacheIds = [], this.destroyed = false, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(resource);
        }
        get realWidth() {
          return Math.round(this.width * this.resolution);
        }
        get realHeight() {
          return Math.round(this.height * this.resolution);
        }
        get mipmap() {
          return this._mipmap;
        }
        set mipmap(value) {
          this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);
        }
        get scaleMode() {
          return this._scaleMode;
        }
        set scaleMode(value) {
          this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);
        }
        get wrapMode() {
          return this._wrapMode;
        }
        set wrapMode(value) {
          this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);
        }
        setStyle(scaleMode, mipmap) {
          let dirty;
          return scaleMode !== void 0 && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = true), mipmap !== void 0 && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = true), dirty && this.dirtyStyleId++, this;
        }
        setSize(desiredWidth, desiredHeight, resolution) {
          return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
        }
        setRealSize(realWidth, realHeight, resolution) {
          return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;
        }
        _refreshPOT() {
          this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
        }
        setResolution(resolution) {
          const oldResolution = this.resolution;
          return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit("update", this)), this._refreshPOT(), this);
        }
        setResource(resource) {
          if (this.resource === resource)
            return this;
          if (this.resource)
            throw new Error("Resource can be set only once");
          return resource.bind(this), this.resource = resource, this;
        }
        update() {
          this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
        }
        onError(event) {
          this.emit("error", this, event);
        }
        destroy() {
          this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.valid = false, this.dispose(), _BaseTexture2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true, this.emit("destroyed", this), this.removeAllListeners();
        }
        dispose() {
          this.emit("dispose", this);
        }
        castToBaseTexture() {
          return this;
        }
        static from(source2, options, strict = settings.STRICT_TEXTURE_CACHE) {
          const isFrame = typeof source2 == "string";
          let cacheId = null;
          if (isFrame)
            cacheId = source2;
          else {
            if (!source2._pixiId) {
              const prefix = options?.pixiIdPrefix || "pixiid";
              source2._pixiId = `${prefix}_${uid()}`;
            }
            cacheId = source2._pixiId;
          }
          let baseTexture = BaseTextureCache[cacheId];
          if (isFrame && strict && !baseTexture)
            throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
          return baseTexture || (baseTexture = new _BaseTexture2(source2, options), baseTexture.cacheId = cacheId, _BaseTexture2.addToCache(baseTexture, cacheId)), baseTexture;
        }
        static fromBuffer(buffer, width, height, options) {
          buffer = buffer || new Float32Array(width * height * 4);
          const resource = new BufferResource(buffer, { width, height, ...options?.resourceOptions });
          let format2, type;
          return buffer instanceof Float32Array ? (format2 = FORMATS.RGBA, type = TYPES.FLOAT) : buffer instanceof Int32Array ? (format2 = FORMATS.RGBA_INTEGER, type = TYPES.INT) : buffer instanceof Uint32Array ? (format2 = FORMATS.RGBA_INTEGER, type = TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format2 = FORMATS.RGBA_INTEGER, type = TYPES.SHORT) : buffer instanceof Uint16Array ? (format2 = FORMATS.RGBA_INTEGER, type = TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format2 = FORMATS.RGBA, type = TYPES.BYTE) : (format2 = FORMATS.RGBA, type = TYPES.UNSIGNED_BYTE), resource.internal = true, new _BaseTexture2(resource, Object.assign({}, defaultBufferOptions, { type, format: format2 }, options));
        }
        static addToCache(baseTexture, id) {
          id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), BaseTextureCache[id] = baseTexture);
        }
        static removeFromCache(baseTexture) {
          if (typeof baseTexture == "string") {
            const baseTextureFromCache = BaseTextureCache[baseTexture];
            if (baseTextureFromCache) {
              const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
              return index > -1 && baseTextureFromCache.textureCacheIds.splice(index, 1), delete BaseTextureCache[baseTexture], baseTextureFromCache;
            }
          } else if (baseTexture?.textureCacheIds) {
            for (let i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2)
              delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
            return baseTexture.textureCacheIds.length = 0, baseTexture;
          }
          return null;
        }
      };
      _BaseTexture.defaultOptions = {
        mipmap: MIPMAP_MODES.POW2,
        anisotropicLevel: 0,
        scaleMode: SCALE_MODES.LINEAR,
        wrapMode: WRAP_MODES.CLAMP,
        alphaMode: ALPHA_MODES.UNPACK,
        target: TARGETS.TEXTURE_2D,
        format: FORMATS.RGBA,
        type: TYPES.UNSIGNED_BYTE
      }, _BaseTexture._globalBatch = 0;
      BaseTexture = _BaseTexture;
    }
  });

  // node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs
  var BatchDrawCall;
  var init_BatchDrawCall = __esm({
    "node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs"() {
      init_lib();
      BatchDrawCall = class {
        constructor() {
          this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/geometry/Buffer.mjs
  var UID, Buffer2;
  var init_Buffer = __esm({
    "node_modules/@pixi/core/lib/geometry/Buffer.mjs"() {
      init_lib();
      init_lib6();
      UID = 0;
      Buffer2 = class {
        constructor(data, _static = true, index = false) {
          this.data = data || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = index, this.static = _static, this.id = UID++, this.disposeRunner = new Runner("disposeBuffer");
        }
        update(data) {
          data instanceof Array && (data = new Float32Array(data)), this.data = data || this.data, this._updateID++;
        }
        dispose() {
          this.disposeRunner.emit(this, false);
        }
        destroy() {
          this.dispose(), this.data = null;
        }
        set index(value) {
          this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
        }
        get index() {
          return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        }
        static from(data) {
          return data instanceof Array && (data = new Float32Array(data)), new Buffer2(data);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/geometry/Attribute.mjs
  var Attribute;
  var init_Attribute = __esm({
    "node_modules/@pixi/core/lib/geometry/Attribute.mjs"() {
      init_lib();
      Attribute = class {
        constructor(buffer, size = 0, normalized = false, type = TYPES.FLOAT, stride, start, instance, divisor = 1) {
          this.buffer = buffer, this.size = size, this.normalized = normalized, this.type = type, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;
        }
        destroy() {
          this.buffer = null;
        }
        static from(buffer, size, normalized, type, stride) {
          return new Attribute(buffer, size, normalized, type, stride);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs
  function interleaveTypedArrays2(arrays, sizes) {
    let outSize = 0, stride = 0;
    const views = {};
    for (let i2 = 0; i2 < arrays.length; i2++)
      stride += sizes[i2], outSize += arrays[i2].length;
    const buffer = new ArrayBuffer(outSize * 4);
    let out2 = null, littleOffset = 0;
    for (let i2 = 0; i2 < arrays.length; i2++) {
      const size = sizes[i2], array = arrays[i2], type = getBufferType(array);
      views[type] || (views[type] = new map2[type](buffer)), out2 = views[type];
      for (let j2 = 0; j2 < array.length; j2++) {
        const indexStart = (j2 / size | 0) * stride + littleOffset, index = j2 % size;
        out2[indexStart + index] = array[j2];
      }
      littleOffset += size;
    }
    return new Float32Array(buffer);
  }
  var map2;
  var init_interleaveTypedArrays2 = __esm({
    "node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs"() {
      init_lib4();
      map2 = {
        Float32Array,
        Uint32Array,
        Int32Array,
        Uint8Array
      };
    }
  });

  // node_modules/@pixi/core/lib/geometry/Geometry.mjs
  var byteSizeMap, UID2, map3, Geometry;
  var init_Geometry = __esm({
    "node_modules/@pixi/core/lib/geometry/Geometry.mjs"() {
      init_lib();
      init_lib6();
      init_lib4();
      init_Attribute();
      init_Buffer();
      init_interleaveTypedArrays2();
      byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
      UID2 = 0;
      map3 = {
        Float32Array,
        Uint32Array,
        Int32Array,
        Uint8Array,
        Uint16Array
      };
      Geometry = class {
        constructor(buffers = [], attributes = {}) {
          this.buffers = buffers, this.indexBuffer = null, this.attributes = attributes, this.glVertexArrayObjects = {}, this.id = UID2++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
        }
        addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
          if (!buffer)
            throw new Error("You must pass a buffer when creating an attribute");
          buffer instanceof Buffer2 || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer2(buffer));
          const ids = id.split("|");
          if (ids.length > 1) {
            for (let i2 = 0; i2 < ids.length; i2++)
              this.addAttribute(ids[i2], buffer, size, normalized, type);
            return this;
          }
          let bufferIndex = this.buffers.indexOf(buffer);
          return bufferIndex === -1 && (this.buffers.push(buffer), bufferIndex = this.buffers.length - 1), this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this;
        }
        getAttribute(id) {
          return this.attributes[id];
        }
        getBuffer(id) {
          return this.buffers[this.getAttribute(id).buffer];
        }
        addIndex(buffer) {
          return buffer instanceof Buffer2 || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer2(buffer)), buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;
        }
        getIndex() {
          return this.indexBuffer;
        }
        interleave() {
          if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
            return this;
          const arrays = [], sizes = [], interleavedBuffer = new Buffer2();
          let i2;
          for (i2 in this.attributes) {
            const attribute = this.attributes[i2], buffer = this.buffers[attribute.buffer];
            arrays.push(buffer.data), sizes.push(attribute.size * byteSizeMap[attribute.type] / 4), attribute.buffer = 0;
          }
          for (interleavedBuffer.data = interleaveTypedArrays2(arrays, sizes), i2 = 0; i2 < this.buffers.length; i2++)
            this.buffers[i2] !== this.indexBuffer && this.buffers[i2].destroy();
          return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
        }
        getSize() {
          for (const i2 in this.attributes) {
            const attribute = this.attributes[i2];
            return this.buffers[attribute.buffer].data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        dispose() {
          this.disposeRunner.emit(this, false);
        }
        destroy() {
          this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
        }
        clone() {
          const geometry = new Geometry();
          for (let i2 = 0; i2 < this.buffers.length; i2++)
            geometry.buffers[i2] = new Buffer2(this.buffers[i2].data.slice(0));
          for (const i2 in this.attributes) {
            const attrib = this.attributes[i2];
            geometry.attributes[i2] = new Attribute(
              attrib.buffer,
              attrib.size,
              attrib.normalized,
              attrib.type,
              attrib.stride,
              attrib.start,
              attrib.instance
            );
          }
          return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;
        }
        static merge(geometries) {
          const geometryOut = new Geometry(), arrays = [], sizes = [], offsets = [];
          let geometry;
          for (let i2 = 0; i2 < geometries.length; i2++) {
            geometry = geometries[i2];
            for (let j2 = 0; j2 < geometry.buffers.length; j2++)
              sizes[j2] = sizes[j2] || 0, sizes[j2] += geometry.buffers[j2].data.length, offsets[j2] = 0;
          }
          for (let i2 = 0; i2 < geometry.buffers.length; i2++)
            arrays[i2] = new map3[getBufferType(geometry.buffers[i2].data)](sizes[i2]), geometryOut.buffers[i2] = new Buffer2(arrays[i2]);
          for (let i2 = 0; i2 < geometries.length; i2++) {
            geometry = geometries[i2];
            for (let j2 = 0; j2 < geometry.buffers.length; j2++)
              arrays[j2].set(geometry.buffers[j2].data, offsets[j2]), offsets[j2] += geometry.buffers[j2].data.length;
          }
          if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {
            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)], geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
            let offset = 0, stride = 0, offset2 = 0, bufferIndexToCount = 0;
            for (let i2 = 0; i2 < geometry.buffers.length; i2++)
              if (geometry.buffers[i2] !== geometry.indexBuffer) {
                bufferIndexToCount = i2;
                break;
              }
            for (const i2 in geometry.attributes) {
              const attribute = geometry.attributes[i2];
              (attribute.buffer | 0) === bufferIndexToCount && (stride += attribute.size * byteSizeMap[attribute.type] / 4);
            }
            for (let i2 = 0; i2 < geometries.length; i2++) {
              const indexBufferData = geometries[i2].indexBuffer.data;
              for (let j2 = 0; j2 < indexBufferData.length; j2++)
                geometryOut.indexBuffer.data[j2 + offset2] += offset;
              offset += geometries[i2].buffers[bufferIndexToCount].data.length / stride, offset2 += indexBufferData.length;
            }
          }
          return geometryOut;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/batch/BatchGeometry.mjs
  var BatchGeometry;
  var init_BatchGeometry = __esm({
    "node_modules/@pixi/core/lib/batch/BatchGeometry.mjs"() {
      init_lib();
      init_Buffer();
      init_Geometry();
      BatchGeometry = class extends Geometry {
        constructor(_static = false) {
          super(), this._buffer = new Buffer2(null, _static, false), this._indexBuffer = new Buffer2(null, _static, true), this.addAttribute("aVertexPosition", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, TYPES.FLOAT).addIndex(this._indexBuffer);
        }
      };
    }
  });

  // node_modules/@pixi/math/lib/const.mjs
  var PI_2, RAD_TO_DEG, DEG_TO_RAD, SHAPES;
  var init_const2 = __esm({
    "node_modules/@pixi/math/lib/const.mjs"() {
      PI_2 = Math.PI * 2;
      RAD_TO_DEG = 180 / Math.PI;
      DEG_TO_RAD = Math.PI / 180;
      SHAPES = /* @__PURE__ */ ((SHAPES2) => (SHAPES2[SHAPES2.POLY = 0] = "POLY", SHAPES2[SHAPES2.RECT = 1] = "RECT", SHAPES2[SHAPES2.CIRC = 2] = "CIRC", SHAPES2[SHAPES2.ELIP = 3] = "ELIP", SHAPES2[SHAPES2.RREC = 4] = "RREC", SHAPES2))(SHAPES || {});
    }
  });

  // node_modules/@pixi/math/lib/Point.mjs
  var Point;
  var init_Point = __esm({
    "node_modules/@pixi/math/lib/Point.mjs"() {
      Point = class {
        constructor(x2 = 0, y2 = 0) {
          this.x = 0, this.y = 0, this.x = x2, this.y = y2;
        }
        clone() {
          return new Point(this.x, this.y);
        }
        copyFrom(p2) {
          return this.set(p2.x, p2.y), this;
        }
        copyTo(p2) {
          return p2.set(this.x, this.y), p2;
        }
        equals(p2) {
          return p2.x === this.x && p2.y === this.y;
        }
        set(x2 = 0, y2 = x2) {
          return this.x = x2, this.y = y2, this;
        }
      };
      Point.prototype.toString = function() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/shapes/Rectangle.mjs
  var tempPoints, Rectangle;
  var init_Rectangle = __esm({
    "node_modules/@pixi/math/lib/shapes/Rectangle.mjs"() {
      init_const2();
      init_Point();
      tempPoints = [new Point(), new Point(), new Point(), new Point()];
      Rectangle = class {
        constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
          this.x = Number(x2), this.y = Number(y2), this.width = Number(width), this.height = Number(height), this.type = SHAPES.RECT;
        }
        get left() {
          return this.x;
        }
        get right() {
          return this.x + this.width;
        }
        get top() {
          return this.y;
        }
        get bottom() {
          return this.y + this.height;
        }
        static get EMPTY() {
          return new Rectangle(0, 0, 0, 0);
        }
        clone() {
          return new Rectangle(this.x, this.y, this.width, this.height);
        }
        copyFrom(rectangle) {
          return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;
        }
        copyTo(rectangle) {
          return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;
        }
        contains(x2, y2) {
          return this.width <= 0 || this.height <= 0 ? false : x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
        }
        intersects(other, transform2) {
          if (!transform2) {
            const x02 = this.x < other.x ? other.x : this.x;
            if ((this.right > other.right ? other.right : this.right) <= x02)
              return false;
            const y02 = this.y < other.y ? other.y : this.y;
            return (this.bottom > other.bottom ? other.bottom : this.bottom) > y02;
          }
          const x0 = this.left, x1 = this.right, y0 = this.top, y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0)
            return false;
          const lt = tempPoints[0].set(other.left, other.top), lb = tempPoints[1].set(other.left, other.bottom), rt = tempPoints[2].set(other.right, other.top), rb = tempPoints[3].set(other.right, other.bottom);
          if (rt.x <= lt.x || lb.y <= lt.y)
            return false;
          const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
          if (s2 === 0 || (transform2.apply(lt, lt), transform2.apply(lb, lb), transform2.apply(rt, rt), transform2.apply(rb, rb), Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1))
            return false;
          const nx = s2 * (lb.y - lt.y), ny = s2 * (lt.x - lb.x), n00 = nx * x0 + ny * y0, n10 = nx * x1 + ny * y0, n01 = nx * x0 + ny * y1, n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y)
            return false;
          const mx = s2 * (lt.y - rt.y), my = s2 * (rt.x - lt.x), m00 = mx * x0 + my * y0, m10 = mx * x1 + my * y0, m01 = mx * x0 + my * y1, m11 = mx * x1 + my * y1;
          return !(Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y);
        }
        pad(paddingX = 0, paddingY = paddingX) {
          return this.x -= paddingX, this.y -= paddingY, this.width += paddingX * 2, this.height += paddingY * 2, this;
        }
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y), y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          return this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(y2 - y1, 0), this;
        }
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y, this;
        }
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y), y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          return this.x = x1, this.width = x2 - x1, this.y = y1, this.height = y2 - y1, this;
        }
      };
      Rectangle.prototype.toString = function() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/shapes/Circle.mjs
  var Circle;
  var init_Circle = __esm({
    "node_modules/@pixi/math/lib/shapes/Circle.mjs"() {
      init_const2();
      init_Rectangle();
      Circle = class {
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.x = x2, this.y = y2, this.radius = radius, this.type = SHAPES.CIRC;
        }
        clone() {
          return new Circle(this.x, this.y, this.radius);
        }
        contains(x2, y2) {
          if (this.radius <= 0)
            return false;
          const r2 = this.radius * this.radius;
          let dx = this.x - x2, dy = this.y - y2;
          return dx *= dx, dy *= dy, dx + dy <= r2;
        }
        getBounds() {
          return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        }
      };
      Circle.prototype.toString = function() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/shapes/Ellipse.mjs
  var Ellipse;
  var init_Ellipse = __esm({
    "node_modules/@pixi/math/lib/shapes/Ellipse.mjs"() {
      init_const2();
      init_Rectangle();
      Ellipse = class {
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.x = x2, this.y = y2, this.width = halfWidth, this.height = halfHeight, this.type = SHAPES.ELIP;
        }
        clone() {
          return new Ellipse(this.x, this.y, this.width, this.height);
        }
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0)
            return false;
          let normx = (x2 - this.x) / this.width, normy = (y2 - this.y) / this.height;
          return normx *= normx, normy *= normy, normx + normy <= 1;
        }
        getBounds() {
          return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
        }
      };
      Ellipse.prototype.toString = function() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/shapes/Polygon.mjs
  var Polygon;
  var init_Polygon = __esm({
    "node_modules/@pixi/math/lib/shapes/Polygon.mjs"() {
      init_const2();
      Polygon = class {
        constructor(...points) {
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] != "number") {
            const p2 = [];
            for (let i2 = 0, il = flat.length; i2 < il; i2++)
              p2.push(flat[i2].x, flat[i2].y);
            flat = p2;
          }
          this.points = flat, this.type = SHAPES.POLY, this.closeStroke = true;
        }
        clone() {
          const points = this.points.slice(), polygon = new Polygon(points);
          return polygon.closeStroke = this.closeStroke, polygon;
        }
        contains(x2, y2) {
          let inside = false;
          const length = this.points.length / 2;
          for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
            const xi = this.points[i2 * 2], yi = this.points[i2 * 2 + 1], xj = this.points[j2 * 2], yj = this.points[j2 * 2 + 1];
            yi > y2 != yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi && (inside = !inside);
          }
          return inside;
        }
      };
      Polygon.prototype.toString = function() {
        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs
  var RoundedRectangle;
  var init_RoundedRectangle = __esm({
    "node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs"() {
      init_const2();
      RoundedRectangle = class {
        constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
          this.x = x2, this.y = y2, this.width = width, this.height = height, this.radius = radius, this.type = SHAPES.RREC;
        }
        clone() {
          return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        }
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0)
            return false;
          if (x2 >= this.x && x2 <= this.x + this.width && y2 >= this.y && y2 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius)
              return true;
            let dx = x2 - (this.x + radius), dy = y2 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2 || (dx = x2 - (this.x + this.width - radius), dx * dx + dy * dy <= radius2) || (dy = y2 - (this.y + this.height - radius), dx * dx + dy * dy <= radius2) || (dx = x2 - (this.x + radius), dx * dx + dy * dy <= radius2))
              return true;
          }
          return false;
        }
      };
      RoundedRectangle.prototype.toString = function() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/Matrix.mjs
  var Matrix;
  var init_Matrix = __esm({
    "node_modules/@pixi/math/lib/Matrix.mjs"() {
      init_const2();
      init_Point();
      Matrix = class {
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null, this.a = a2, this.b = b2, this.c = c2, this.d = d2, this.tx = tx, this.ty = ty;
        }
        fromArray(array) {
          this.a = array[0], this.b = array[1], this.c = array[3], this.d = array[4], this.tx = array[2], this.ty = array[5];
        }
        set(a2, b2, c2, d2, tx, ty) {
          return this.a = a2, this.b = b2, this.c = c2, this.d = d2, this.tx = tx, this.ty = ty, this;
        }
        toArray(transpose, out2) {
          this.array || (this.array = new Float32Array(9));
          const array = out2 || this.array;
          return transpose ? (array[0] = this.a, array[1] = this.b, array[2] = 0, array[3] = this.c, array[4] = this.d, array[5] = 0, array[6] = this.tx, array[7] = this.ty, array[8] = 1) : (array[0] = this.a, array[1] = this.c, array[2] = this.tx, array[3] = this.b, array[4] = this.d, array[5] = this.ty, array[6] = 0, array[7] = 0, array[8] = 1), array;
        }
        apply(pos, newPos) {
          newPos = newPos || new Point();
          const x2 = pos.x, y2 = pos.y;
          return newPos.x = this.a * x2 + this.c * y2 + this.tx, newPos.y = this.b * x2 + this.d * y2 + this.ty, newPos;
        }
        applyInverse(pos, newPos) {
          newPos = newPos || new Point();
          const id = 1 / (this.a * this.d + this.c * -this.b), x2 = pos.x, y2 = pos.y;
          return newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id, newPos;
        }
        translate(x2, y2) {
          return this.tx += x2, this.ty += y2, this;
        }
        scale(x2, y2) {
          return this.a *= x2, this.d *= y2, this.c *= x2, this.b *= y2, this.tx *= x2, this.ty *= y2, this;
        }
        rotate(angle) {
          const cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;
          return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this;
        }
        append(matrix) {
          const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
          return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;
        }
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x2 - (pivotX * this.a + pivotY * this.c), this.ty = y2 - (pivotX * this.b + pivotY * this.d), this;
        }
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a, c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c, this.b = a1 * matrix.b + this.b * matrix.d, this.c = c1 * matrix.a + this.d * matrix.c, this.d = c1 * matrix.b + this.d * matrix.d;
          }
          return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;
        }
        decompose(transform2) {
          const a2 = this.a, b2 = this.b, c2 = this.c, d2 = this.d, pivot = transform2.pivot, skewX = -Math.atan2(-c2, d2), skewY = Math.atan2(b2, a2), delta = Math.abs(skewX + skewY);
          return delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5 ? (transform2.rotation = skewY, transform2.skew.x = transform2.skew.y = 0) : (transform2.rotation = 0, transform2.skew.x = skewX, transform2.skew.y = skewY), transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2), transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2), transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2), transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2), transform2;
        }
        invert() {
          const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n2 = a1 * d1 - b1 * c1;
          return this.a = d1 / n2, this.b = -b1 / n2, this.c = -c1 / n2, this.d = a1 / n2, this.tx = (c1 * this.ty - d1 * tx1) / n2, this.ty = -(a1 * this.ty - b1 * tx1) / n2, this;
        }
        identity() {
          return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
        }
        clone() {
          const matrix = new Matrix();
          return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
        }
        copyTo(matrix) {
          return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
        }
        copyFrom(matrix) {
          return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;
        }
        static get IDENTITY() {
          return new Matrix();
        }
        static get TEMP_MATRIX() {
          return new Matrix();
        }
      };
      Matrix.prototype.toString = function() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/groupD8.mjs
  function init() {
    for (let i2 = 0; i2 < 16; i2++) {
      const row = [];
      rotationCayley.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]), _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]), _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]), _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
        for (let k2 = 0; k2 < 16; k2++)
          if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
            row.push(k2);
            break;
          }
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      const mat = new Matrix();
      mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0), rotationMatrices.push(mat);
    }
  }
  var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
  var init_groupD8 = __esm({
    "node_modules/@pixi/math/lib/groupD8.mjs"() {
      init_Matrix();
      ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley = [];
      rotationMatrices = [];
      signum = Math.sign;
      init();
      groupD8 = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (ind) => ux[ind],
        uY: (ind) => uy[ind],
        vX: (ind) => vx[ind],
        vY: (ind) => vy[ind],
        inv: (rotation) => rotation & 8 ? rotation & 15 : -rotation & 7,
        add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
        sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
        rotate180: (rotation) => rotation ^ 4,
        isVertical: (rotation) => (rotation & 3) === 2,
        byDirection: (dx, dy) => Math.abs(dx) * 2 <= Math.abs(dy) ? dy >= 0 ? groupD8.S : groupD8.N : Math.abs(dy) * 2 <= Math.abs(dx) ? dx > 0 ? groupD8.E : groupD8.W : dy > 0 ? dx > 0 ? groupD8.SE : groupD8.SW : dx > 0 ? groupD8.NE : groupD8.NW,
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices[groupD8.inv(rotation)];
          mat.tx = tx, mat.ty = ty, matrix.append(mat);
        }
      };
    }
  });

  // node_modules/@pixi/math/lib/ObservablePoint.mjs
  var ObservablePoint;
  var init_ObservablePoint = __esm({
    "node_modules/@pixi/math/lib/ObservablePoint.mjs"() {
      ObservablePoint = class {
        constructor(cb, scope, x2 = 0, y2 = 0) {
          this._x = x2, this._y = y2, this.cb = cb, this.scope = scope;
        }
        clone(cb = this.cb, scope = this.scope) {
          return new ObservablePoint(cb, scope, this._x, this._y);
        }
        set(x2 = 0, y2 = x2) {
          return (this._x !== x2 || this._y !== y2) && (this._x = x2, this._y = y2, this.cb.call(this.scope)), this;
        }
        copyFrom(p2) {
          return (this._x !== p2.x || this._y !== p2.y) && (this._x = p2.x, this._y = p2.y, this.cb.call(this.scope)), this;
        }
        copyTo(p2) {
          return p2.set(this._x, this._y), p2;
        }
        equals(p2) {
          return p2.x === this._x && p2.y === this._y;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          this._x !== value && (this._x = value, this.cb.call(this.scope));
        }
        get y() {
          return this._y;
        }
        set y(value) {
          this._y !== value && (this._y = value, this.cb.call(this.scope));
        }
      };
      ObservablePoint.prototype.toString = function() {
        return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/Transform.mjs
  var _Transform, Transform;
  var init_Transform = __esm({
    "node_modules/@pixi/math/lib/Transform.mjs"() {
      init_Matrix();
      init_ObservablePoint();
      _Transform = class {
        constructor() {
          this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
        }
        onChange() {
          this._localID++;
        }
        updateSkew() {
          this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
        }
        updateLocalTransform() {
          const lt = this.localTransform;
          this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1);
        }
        updateTransform(parentTransform) {
          const lt = this.localTransform;
          if (this._localID !== this._currentLocalID && (lt.a = this._cx * this.scale.x, lt.b = this._sx * this.scale.x, lt.c = this._cy * this.scale.y, lt.d = this._sy * this.scale.y, lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c), lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== parentTransform._worldID) {
            const pt = parentTransform.worldTransform, wt = this.worldTransform;
            wt.a = lt.a * pt.a + lt.b * pt.c, wt.b = lt.a * pt.b + lt.b * pt.d, wt.c = lt.c * pt.a + lt.d * pt.c, wt.d = lt.c * pt.b + lt.d * pt.d, wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx, wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty, this._parentID = parentTransform._worldID, this._worldID++;
          }
        }
        setFromMatrix(matrix) {
          matrix.decompose(this), this._localID++;
        }
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          this._rotation !== value && (this._rotation = value, this.updateSkew());
        }
      };
      _Transform.IDENTITY = new _Transform();
      Transform = _Transform;
      Transform.prototype.toString = function() {
        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
      };
    }
  });

  // node_modules/@pixi/math/lib/index.mjs
  var init_lib7 = __esm({
    "node_modules/@pixi/math/lib/index.mjs"() {
      init_Circle();
      init_Ellipse();
      init_Polygon();
      init_Rectangle();
      init_RoundedRectangle();
      init_groupD8();
      init_Matrix();
      init_ObservablePoint();
      init_Point();
      init_Transform();
      init_const2();
    }
  });

  // node_modules/@pixi/core/lib/shader/defaultProgram.frag.mjs
  var defaultFragment;
  var init_defaultProgram_frag = __esm({
    "node_modules/@pixi/core/lib/shader/defaultProgram.frag.mjs"() {
      defaultFragment = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`;
    }
  });

  // node_modules/@pixi/core/lib/shader/defaultProgram.vert.mjs
  var defaultVertex;
  var init_defaultProgram_vert = __esm({
    "node_modules/@pixi/core/lib/shader/defaultProgram.vert.mjs"() {
      defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/compileShader.mjs
  function compileShader(gl, type, src) {
    const shader = gl.createShader(type);
    return gl.shaderSource(shader, src), gl.compileShader(shader), shader;
  }
  var init_compileShader = __esm({
    "node_modules/@pixi/core/lib/shader/utils/compileShader.mjs"() {
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs
  function booleanArray(size) {
    const array = new Array(size);
    for (let i2 = 0; i2 < array.length; i2++)
      array[i2] = false;
    return array;
  }
  function defaultValue(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray(2 * size);
      case "bvec3":
        return booleanArray(3 * size);
      case "bvec4":
        return booleanArray(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue = __esm({
    "node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs"() {
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs
  var uniformParsers;
  var init_uniformParsers = __esm({
    "node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs"() {
      uniformParsers = [
        {
          test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
          code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
        },
        {
          test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
          code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
        },
        {
          test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
          code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
          codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
        },
        {
          test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
          codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
        },
        {
          test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
        },
        {
          test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
          codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
        },
        {
          test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
          codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
        },
        {
          test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
          codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
        },
        {
          test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
          code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
        }
      ];
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i2 in group.uniforms) {
      const data = uniformData[i2];
      if (!data) {
        group.uniforms[i2]?.group === true && (group.uniforms[i2].ubo ? funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i2}, '${i2}');
                    `) : funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i2}, syncData);
                    `));
        continue;
      }
      const uniform = group.uniforms[i2];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++)
        if (uniformParsers[j2].test(data, uniform)) {
          funcFragments.push(uniformParsers[j2].code(i2, uniform)), parsed = true;
          break;
        }
      if (!parsed) {
        const template = (data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS)[data.type].replace("location", `ud["${i2}"].location`);
        funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join(`
`));
  }
  var GLSL_TO_SINGLE_SETTERS_CACHED, GLSL_TO_ARRAY_SETTERS;
  var init_generateUniformsSync = __esm({
    "node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs"() {
      init_uniformParsers();
      GLSL_TO_SINGLE_SETTERS_CACHED = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
      };
      GLSL_TO_ARRAY_SETTERS = {
        float: "gl.uniform1fv(location, v)",
        vec2: "gl.uniform2fv(location, v)",
        vec3: "gl.uniform3fv(location, v)",
        vec4: "gl.uniform4fv(location, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        int: "gl.uniform1iv(location, v)",
        ivec2: "gl.uniform2iv(location, v)",
        ivec3: "gl.uniform3iv(location, v)",
        ivec4: "gl.uniform4iv(location, v)",
        uint: "gl.uniform1uiv(location, v)",
        uvec2: "gl.uniform2uiv(location, v)",
        uvec3: "gl.uniform3uiv(location, v)",
        uvec4: "gl.uniform4uiv(location, v)",
        bool: "gl.uniform1iv(location, v)",
        bvec2: "gl.uniform2iv(location, v)",
        bvec3: "gl.uniform3iv(location, v)",
        bvec4: "gl.uniform4iv(location, v)",
        sampler2D: "gl.uniform1iv(location, v)",
        samplerCube: "gl.uniform1iv(location, v)",
        sampler2DArray: "gl.uniform1iv(location, v)"
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs
  function getTestContext() {
    if (context === unknownContext || context?.isContextLost()) {
      const canvas = settings.ADAPTER.createCanvas();
      let gl;
      settings.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas.getContext("webgl2", {})), gl || (gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {}), gl ? gl.getExtension("WEBGL_draw_buffers") : gl = null), context = gl;
    }
    return context;
  }
  var unknownContext, context;
  var init_getTestContext = __esm({
    "node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs"() {
      init_lib();
      init_lib2();
      unknownContext = {};
      context = unknownContext;
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision() {
    if (!maxFragmentPrecision) {
      maxFragmentPrecision = PRECISION.MEDIUM;
      const gl = getTestContext();
      gl && gl.getShaderPrecisionFormat && (maxFragmentPrecision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision ? PRECISION.HIGH : PRECISION.MEDIUM);
    }
    return maxFragmentPrecision;
  }
  var maxFragmentPrecision;
  var init_getMaxFragmentPrecision = __esm({
    "node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs"() {
      init_lib();
      init_getTestContext();
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs
  function logPrettyShaderError(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split(`
`).map((line, index) => `${index}: ${line}`), shaderLog = gl.getShaderInfoLog(shader), splitShader = shaderLog.split(`
`), dedupe = {}, lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => n2 && !dedupe[n2] ? (dedupe[n2] = true, true) : false), logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`, logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join(`
`);
    logArgs[0] = fragmentSourceToLog, console.error(shaderLog), console.groupCollapsed("click to view full shader code"), console.warn(...logArgs), console.groupEnd();
  }
  function logProgramError(gl, program, vertexShader, fragmentShader) {
    gl.getProgramParameter(program, gl.LINK_STATUS) || (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, vertexShader), gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) || logPrettyShaderError(gl, fragmentShader), console.error("PixiJS Error: Could not initialize shader."), gl.getProgramInfoLog(program) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program)));
  }
  var init_logProgramError = __esm({
    "node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs"() {
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/mapSize.mjs
  function mapSize(type) {
    return GLSL_TO_SIZE[type];
  }
  var GLSL_TO_SIZE;
  var init_mapSize = __esm({
    "node_modules/@pixi/core/lib/shader/utils/mapSize.mjs"() {
      GLSL_TO_SIZE = {
        float: 1,
        vec2: 2,
        vec3: 3,
        vec4: 4,
        int: 1,
        ivec2: 2,
        ivec3: 3,
        ivec4: 4,
        uint: 1,
        uvec2: 2,
        uvec3: 3,
        uvec4: 4,
        bool: 1,
        bvec2: 2,
        bvec3: 3,
        bvec4: 4,
        mat2: 4,
        mat3: 9,
        mat4: 16,
        sampler2D: 1
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/mapType.mjs
  function mapType(gl, type) {
    if (!GL_TABLE) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES);
      GL_TABLE = {};
      for (let i2 = 0; i2 < typeNames.length; ++i2) {
        const tn = typeNames[i2];
        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
      }
    }
    return GL_TABLE[type];
  }
  var GL_TABLE, GL_TO_GLSL_TYPES;
  var init_mapType = __esm({
    "node_modules/@pixi/core/lib/shader/utils/mapType.mjs"() {
      GL_TABLE = null;
      GL_TO_GLSL_TYPES = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs
  function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
    if (src.substring(0, 9) !== "precision") {
      let precision = requestedPrecision;
      return requestedPrecision === PRECISION.HIGH && maxSupportedPrecision !== PRECISION.HIGH && (precision = PRECISION.MEDIUM), `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== PRECISION.HIGH && src.substring(0, 15) === "precision highp")
      return src.replace("precision highp", "precision mediump");
    return src;
  }
  var init_setPrecision = __esm({
    "node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs"() {
      init_lib();
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs
  function unsafeEvalSupported() {
    if (typeof unsafeEval == "boolean")
      return unsafeEval;
    try {
      unsafeEval = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === true;
    } catch {
      unsafeEval = false;
    }
    return unsafeEval;
  }
  var unsafeEval;
  var init_unsafeEvalSupported = __esm({
    "node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs"() {
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/index.mjs
  var init_utils = __esm({
    "node_modules/@pixi/core/lib/shader/utils/index.mjs"() {
      init_checkMaxIfStatementsInShader();
      init_compileShader();
      init_defaultValue();
      init_generateUniformsSync();
      init_getMaxFragmentPrecision();
      init_getTestContext();
      init_logProgramError();
      init_mapSize();
      init_mapType();
      init_setPrecision();
      init_uniformParsers();
      init_unsafeEvalSupported();
    }
  });

  // node_modules/@pixi/core/lib/shader/Program.mjs
  var UID3, nameCache, _Program, Program;
  var init_Program = __esm({
    "node_modules/@pixi/core/lib/shader/Program.mjs"() {
      init_lib();
      init_lib4();
      init_defaultProgram_frag();
      init_defaultProgram_vert();
      init_utils();
      init_setPrecision();
      init_getMaxFragmentPrecision();
      UID3 = 0;
      nameCache = {};
      _Program = class _Program2 {
        constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
          this.extra = {}, this.id = UID3++, this.vertexSrc = vertexSrc || _Program2.defaultVertexSrc, this.fragmentSrc = fragmentSrc || _Program2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = extra, this.vertexSrc.substring(0, 8) !== "#version" && (name = name.replace(/\s+/g, "-"), nameCache[name] ? (nameCache[name]++, name += `-${nameCache[name]}`) : nameCache[name] = 1, this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`, this.vertexSrc = setPrecision(
            this.vertexSrc,
            _Program2.defaultVertexPrecision,
            PRECISION.HIGH
          ), this.fragmentSrc = setPrecision(
            this.fragmentSrc,
            _Program2.defaultFragmentPrecision,
            getMaxFragmentPrecision()
          )), this.glPrograms = {}, this.syncUniforms = null;
        }
        static get defaultVertexSrc() {
          return defaultVertex;
        }
        static get defaultFragmentSrc() {
          return defaultFragment;
        }
        static from(vertexSrc, fragmentSrc, name) {
          const key = vertexSrc + fragmentSrc;
          let program = ProgramCache[key];
          return program || (ProgramCache[key] = program = new _Program2(vertexSrc, fragmentSrc, name)), program;
        }
      };
      _Program.defaultVertexPrecision = PRECISION.HIGH, _Program.defaultFragmentPrecision = isMobile2.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM;
      Program = _Program;
    }
  });

  // node_modules/@pixi/core/lib/shader/UniformGroup.mjs
  var UID4, UniformGroup;
  var init_UniformGroup = __esm({
    "node_modules/@pixi/core/lib/shader/UniformGroup.mjs"() {
      init_lib();
      init_Buffer();
      UID4 = 0;
      UniformGroup = class {
        constructor(uniforms, isStatic, isUbo) {
          this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID4++, this.static = !!isStatic, this.ubo = !!isUbo, uniforms instanceof Buffer2 ? (this.buffer = uniforms, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = uniforms, this.ubo && (this.buffer = new Buffer2(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = true));
        }
        update() {
          this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
        }
        add(name, uniforms, _static) {
          if (!this.ubo)
            this.uniforms[name] = new UniformGroup(uniforms, _static);
          else
            throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
        }
        static from(uniforms, _static, _ubo) {
          return new UniformGroup(uniforms, _static, _ubo);
        }
        static uboFrom(uniforms, _static) {
          return new UniformGroup(uniforms, _static ?? true, true);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/Shader.mjs
  var Shader;
  var init_Shader = __esm({
    "node_modules/@pixi/core/lib/shader/Shader.mjs"() {
      init_lib6();
      init_Program();
      init_UniformGroup();
      Shader = class {
        constructor(program, uniforms) {
          this.uniformBindCount = 0, this.program = program, uniforms ? uniforms instanceof UniformGroup ? this.uniformGroup = uniforms : this.uniformGroup = new UniformGroup(uniforms) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner("disposeShader");
        }
        checkUniformExists(name, group) {
          if (group.uniforms[name])
            return true;
          for (const i2 in group.uniforms) {
            const uniform = group.uniforms[i2];
            if (uniform.group === true && this.checkUniformExists(name, uniform))
              return true;
          }
          return false;
        }
        destroy() {
          this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
        }
        get uniforms() {
          return this.uniformGroup.uniforms;
        }
        static from(vertexSrc, fragmentSrc, uniforms) {
          const program = Program.from(vertexSrc, fragmentSrc);
          return new Shader(program, uniforms);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs
  var BatchShaderGenerator;
  var init_BatchShaderGenerator = __esm({
    "node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs"() {
      init_lib7();
      init_Program();
      init_Shader();
      init_UniformGroup();
      BatchShaderGenerator = class {
        constructor(vertexSrc, fragTemplate4) {
          if (this.vertexSrc = vertexSrc, this.fragTemplate = fragTemplate4, this.programCache = {}, this.defaultGroupCache = {}, !fragTemplate4.includes("%count%"))
            throw new Error('Fragment template must contain "%count%".');
          if (!fragTemplate4.includes("%forloop%"))
            throw new Error('Fragment template must contain "%forloop%".');
        }
        generateShader(maxTextures2) {
          if (!this.programCache[maxTextures2]) {
            const sampleValues = new Int32Array(maxTextures2);
            for (let i2 = 0; i2 < maxTextures2; i2++)
              sampleValues[i2] = i2;
            this.defaultGroupCache[maxTextures2] = UniformGroup.from({ uSamplers: sampleValues }, true);
            let fragmentSrc = this.fragTemplate;
            fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures2}`), fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures2)), this.programCache[maxTextures2] = new Program(this.vertexSrc, fragmentSrc);
          }
          const uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix(),
            default: this.defaultGroupCache[maxTextures2]
          };
          return new Shader(this.programCache[maxTextures2], uniforms);
        }
        generateSampleSrc(maxTextures2) {
          let src = "";
          src += `
`, src += `
`;
          for (let i2 = 0; i2 < maxTextures2; i2++)
            i2 > 0 && (src += `
else `), i2 < maxTextures2 - 1 && (src += `if(vTextureId < ${i2}.5)`), src += `
{`, src += `
	color = texture2D(uSamplers[${i2}], vTextureCoord);`, src += `
}`;
          return src += `
`, src += `
`, src;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs
  var BatchTextureArray;
  var init_BatchTextureArray = __esm({
    "node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs"() {
      BatchTextureArray = class {
        constructor() {
          this.elements = [], this.ids = [], this.count = 0;
        }
        clear() {
          for (let i2 = 0; i2 < this.count; i2++)
            this.elements[i2] = null;
          this.count = 0;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs
  function canUploadSameBuffer() {
    return !isMobile2.apple.device;
  }
  var init_canUploadSameBuffer = __esm({
    "node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs"() {
      init_lib2();
    }
  });

  // node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs
  function maxRecommendedTextures(max) {
    let allowMax = true;
    const navigator2 = settings.ADAPTER.getNavigator();
    if (isMobile2.tablet || isMobile2.phone) {
      if (isMobile2.apple.device) {
        const match = navigator2.userAgent.match(/OS (\d+)_(\d+)?/);
        match && parseInt(match[1], 10) < 11 && (allowMax = false);
      }
      if (isMobile2.android.device) {
        const match = navigator2.userAgent.match(/Android\s([0-9.]*)/);
        match && parseInt(match[1], 10) < 7 && (allowMax = false);
      }
    }
    return allowMax ? max : 4;
  }
  var init_maxRecommendedTextures = __esm({
    "node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs"() {
      init_lib2();
    }
  });

  // node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs
  var ObjectRenderer;
  var init_ObjectRenderer = __esm({
    "node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs"() {
      ObjectRenderer = class {
        constructor(renderer) {
          this.renderer = renderer;
        }
        flush() {
        }
        destroy() {
          this.renderer = null;
        }
        start() {
        }
        stop() {
          this.flush();
        }
        render(_object) {
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/batch/texture.frag.mjs
  var defaultFragment2;
  var init_texture_frag = __esm({
    "node_modules/@pixi/core/lib/batch/texture.frag.mjs"() {
      defaultFragment2 = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`;
    }
  });

  // node_modules/@pixi/core/lib/batch/texture.vert.mjs
  var defaultVertex2;
  var init_texture_vert = __esm({
    "node_modules/@pixi/core/lib/batch/texture.vert.mjs"() {
      defaultVertex2 = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
    }
  });

  // node_modules/@pixi/core/lib/batch/BatchRenderer.mjs
  var _BatchRenderer, BatchRenderer;
  var init_BatchRenderer = __esm({
    "node_modules/@pixi/core/lib/batch/BatchRenderer.mjs"() {
      init_lib3();
      init_lib();
      init_lib5();
      init_lib2();
      init_lib4();
      init_ViewableBuffer();
      init_checkMaxIfStatementsInShader();
      init_State();
      init_BaseTexture();
      init_BatchDrawCall();
      init_BatchGeometry();
      init_BatchShaderGenerator();
      init_BatchTextureArray();
      init_canUploadSameBuffer();
      init_maxRecommendedTextures();
      init_ObjectRenderer();
      init_texture_frag();
      init_texture_vert();
      _BatchRenderer = class _BatchRenderer2 extends ObjectRenderer {
        constructor(renderer) {
          super(renderer), this.setShaderGenerator(), this.geometryClass = BatchGeometry, this.vertexSize = 6, this.state = State.for2d(), this.size = _BatchRenderer2.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), renderer.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = [];
        }
        static get defaultMaxTextures() {
          return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32), this._defaultMaxTextures;
        }
        static set defaultMaxTextures(value) {
          this._defaultMaxTextures = value;
        }
        static get canUploadSameBuffer() {
          return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer(), this._canUploadSameBuffer;
        }
        static set canUploadSameBuffer(value) {
          this._canUploadSameBuffer = value;
        }
        get MAX_TEXTURES() {
          return deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;
        }
        static get defaultVertexSrc() {
          return defaultVertex2;
        }
        static get defaultFragmentTemplate() {
          return defaultFragment2;
        }
        setShaderGenerator({
          vertex: vertex7 = _BatchRenderer2.defaultVertexSrc,
          fragment: fragment10 = _BatchRenderer2.defaultFragmentTemplate
        } = {}) {
          this.shaderGenerator = new BatchShaderGenerator(vertex7, fragment10);
        }
        contextChange() {
          const gl = this.renderer.gl;
          settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(
            gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
            _BatchRenderer2.defaultMaxTextures
          ), this.maxTextures = checkMaxIfStatementsInShader(
            this.maxTextures,
            gl
          )), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
          for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++)
            this._packedGeometries[i2] = new this.geometryClass();
          this.initFlushBuffers();
        }
        initFlushBuffers() {
          const {
            _drawCallPool,
            _textureArrayPool
          } = _BatchRenderer2, MAX_SPRITES = this.size / 4, MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
          for (; _drawCallPool.length < MAX_SPRITES; )
            _drawCallPool.push(new BatchDrawCall());
          for (; _textureArrayPool.length < MAX_TA; )
            _textureArrayPool.push(new BatchTextureArray());
          for (let i2 = 0; i2 < this.maxTextures; i2++)
            this._tempBoundTextures[i2] = null;
        }
        onPrerender() {
          this._flushId = 0;
        }
        render(element) {
          element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);
        }
        buildTexturesAndDrawCalls() {
          const {
            _bufferedTextures: textures,
            maxTextures: maxTextures2
          } = this, textureArrays = _BatchRenderer2._textureArrayPool, batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;
          let TICK = ++BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;
          batch.copyBoundTextures(boundTextures, maxTextures2);
          for (let i2 = 0; i2 < this._bufferSize; ++i2) {
            const tex = textures[i2];
            textures[i2] = null, tex._batchEnabled !== TICK && (texArray.count >= maxTextures2 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures2), this.buildDrawCalls(texArray, start, i2), start = i2, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);
          }
          texArray.count > 0 && (batch.boundArray(texArray, boundTextures, TICK, maxTextures2), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);
          for (let i2 = 0; i2 < boundTextures.length; i2++)
            boundTextures[i2] = null;
          BaseTexture._globalBatch = TICK;
        }
        buildDrawCalls(texArray, start, finish) {
          const {
            _bufferedElements: elements,
            _attributeBuffer,
            _indexBuffer,
            vertexSize
          } = this, drawCalls = _BatchRenderer2._drawCallPool;
          let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];
          drawCall.start = this._iIndex, drawCall.texArray = texArray;
          for (let i2 = start; i2 < finish; ++i2) {
            const sprite = elements[i2], tex = sprite._texture.baseTexture, spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
            elements[i2] = null, start < i2 && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i2, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex), this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex), aIndex += sprite.vertexData.length / 2 * vertexSize, iIndex += sprite.indices.length, drawCall.blend = spriteBlendMode;
          }
          start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex), this._dcIndex = dcIndex, this._aIndex = aIndex, this._iIndex = iIndex;
        }
        bindAndClearTexArray(texArray) {
          const textureSystem = this.renderer.texture;
          for (let j2 = 0; j2 < texArray.count; j2++)
            textureSystem.bind(texArray.elements[j2], texArray.ids[j2]), texArray.elements[j2] = null;
          texArray.count = 0;
        }
        updateGeometry() {
          const {
            _packedGeometries: packedGeometries,
            _attributeBuffer: attributeBuffer,
            _indexBuffer: indexBuffer
          } = this;
          _BatchRenderer2.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
        }
        drawBatches() {
          const dcCount = this._dcIndex, { gl, state: stateSystem } = this.renderer, drawCalls = _BatchRenderer2._drawCallPool;
          let curTexArray = null;
          for (let i2 = 0; i2 < dcCount; i2++) {
            const { texArray, type, size, start, blend } = drawCalls[i2];
            curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray)), this.state.blendMode = blend, stateSystem.set(this.state), gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
          }
        }
        flush() {
          this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
        }
        start() {
          this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _BatchRenderer2.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
        stop() {
          this.flush();
        }
        destroy() {
          for (let i2 = 0; i2 < this._packedGeometryPoolSize; i2++)
            this._packedGeometries[i2] && this._packedGeometries[i2].destroy();
          this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy();
        }
        getAttributeBuffer(size) {
          const roundedP2 = nextPow2(Math.ceil(size / 8)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 8;
          this._aBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
          let buffer = this._aBuffers[roundedSize];
          return buffer || (this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4)), buffer;
        }
        getIndexBuffer(size) {
          const roundedP2 = nextPow2(Math.ceil(size / 12)), roundedSizeIndex = log2(roundedP2), roundedSize = roundedP2 * 12;
          this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
          let buffer = this._iBuffers[roundedSizeIndex];
          return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize)), buffer;
        }
        packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
          const {
            uint32View,
            float32View
          } = attributeBuffer, packedVertices = aIndex / this.vertexSize, uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation, alpha = Math.min(element.worldAlpha, 1), argb = Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
          for (let i2 = 0; i2 < vertexData.length; i2 += 2)
            float32View[aIndex++] = vertexData[i2], float32View[aIndex++] = vertexData[i2 + 1], float32View[aIndex++] = uvs[i2], float32View[aIndex++] = uvs[i2 + 1], uint32View[aIndex++] = argb, float32View[aIndex++] = textureId;
          for (let i2 = 0; i2 < indicies.length; i2++)
            indexBuffer[iIndex++] = packedVertices + indicies[i2];
        }
      };
      _BatchRenderer.defaultBatchSize = 4096, _BatchRenderer.extension = {
        name: "batch",
        type: ExtensionType.RendererPlugin
      }, _BatchRenderer._drawCallPool = [], _BatchRenderer._textureArrayPool = [];
      BatchRenderer = _BatchRenderer;
      extensions.add(BatchRenderer);
    }
  });

  // node_modules/@pixi/core/lib/filters/defaultFilter.frag.mjs
  var defaultFragment3;
  var init_defaultFilter_frag = __esm({
    "node_modules/@pixi/core/lib/filters/defaultFilter.frag.mjs"() {
      defaultFragment3 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`;
    }
  });

  // node_modules/@pixi/core/lib/filters/defaultFilter.vert.mjs
  var defaultVertex3;
  var init_defaultFilter_vert = __esm({
    "node_modules/@pixi/core/lib/filters/defaultFilter.vert.mjs"() {
      defaultVertex3 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
    }
  });

  // node_modules/@pixi/core/lib/filters/Filter.mjs
  var _Filter, Filter;
  var init_Filter = __esm({
    "node_modules/@pixi/core/lib/filters/Filter.mjs"() {
      init_lib();
      init_Program();
      init_Shader();
      init_State();
      init_defaultFilter_frag();
      init_defaultFilter_vert();
      _Filter = class _Filter2 extends Shader {
        constructor(vertexSrc, fragmentSrc, uniforms) {
          const program = Program.from(
            vertexSrc || _Filter2.defaultVertexSrc,
            fragmentSrc || _Filter2.defaultFragmentSrc
          );
          super(program, uniforms), this.padding = 0, this.resolution = _Filter2.defaultResolution, this.multisample = _Filter2.defaultMultisample, this.enabled = true, this.autoFit = true, this.state = new State();
        }
        apply(filterManager, input, output, clearMode, _currentState) {
          filterManager.applyFilter(this, input, output, clearMode);
        }
        get blendMode() {
          return this.state.blendMode;
        }
        set blendMode(value) {
          this.state.blendMode = value;
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(value) {
          this._resolution = value;
        }
        static get defaultVertexSrc() {
          return defaultVertex3;
        }
        static get defaultFragmentSrc() {
          return defaultFragment3;
        }
      };
      _Filter.defaultResolution = 1, _Filter.defaultMultisample = MSAA_QUALITY.NONE;
      Filter = _Filter;
    }
  });

  // node_modules/@pixi/core/lib/background/BackgroundSystem.mjs
  var BackgroundSystem;
  var init_BackgroundSystem = __esm({
    "node_modules/@pixi/core/lib/background/BackgroundSystem.mjs"() {
      init_lib3();
      init_lib5();
      BackgroundSystem = class {
        constructor() {
          this.clearBeforeRender = true, this._backgroundColor = new Color(0), this.alpha = 1;
        }
        init(options) {
          this.clearBeforeRender = options.clearBeforeRender;
          const { backgroundColor, background, backgroundAlpha } = options, color = background ?? backgroundColor;
          color !== void 0 && (this.color = color), this.alpha = backgroundAlpha;
        }
        get color() {
          return this._backgroundColor.value;
        }
        set color(value) {
          this._backgroundColor.setValue(value);
        }
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value) {
          this._backgroundColor.setAlpha(value);
        }
        get backgroundColor() {
          return this._backgroundColor;
        }
        destroy() {
        }
      };
      BackgroundSystem.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: true
      }, BackgroundSystem.extension = {
        type: [
          ExtensionType.RendererSystem,
          ExtensionType.CanvasRendererSystem
        ],
        name: "background"
      };
      extensions.add(BackgroundSystem);
    }
  });

  // node_modules/@pixi/core/lib/batch/BatchSystem.mjs
  var BatchSystem;
  var init_BatchSystem = __esm({
    "node_modules/@pixi/core/lib/batch/BatchSystem.mjs"() {
      init_lib5();
      init_ObjectRenderer();
      BatchSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.emptyRenderer = new ObjectRenderer(renderer), this.currentRenderer = this.emptyRenderer;
        }
        setObjectRenderer(objectRenderer) {
          this.currentRenderer !== objectRenderer && (this.currentRenderer.stop(), this.currentRenderer = objectRenderer, this.currentRenderer.start());
        }
        flush() {
          this.setObjectRenderer(this.emptyRenderer);
        }
        reset() {
          this.setObjectRenderer(this.emptyRenderer);
        }
        copyBoundTextures(arr, maxTextures2) {
          const { boundTextures } = this.renderer.texture;
          for (let i2 = maxTextures2 - 1; i2 >= 0; --i2)
            arr[i2] = boundTextures[i2] || null, arr[i2] && (arr[i2]._batchLocation = i2);
        }
        boundArray(texArray, boundTextures, batchId, maxTextures2) {
          const { elements, ids, count: count2 } = texArray;
          let j2 = 0;
          for (let i2 = 0; i2 < count2; i2++) {
            const tex = elements[i2], loc = tex._batchLocation;
            if (loc >= 0 && loc < maxTextures2 && boundTextures[loc] === tex) {
              ids[i2] = loc;
              continue;
            }
            for (; j2 < maxTextures2; ) {
              const bound = boundTextures[j2];
              if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
                j2++;
                continue;
              }
              ids[i2] = j2, tex._batchLocation = j2, boundTextures[j2] = tex;
              break;
            }
          }
        }
        destroy() {
          this.renderer = null;
        }
      };
      BatchSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "batch"
      };
      extensions.add(BatchSystem);
    }
  });

  // node_modules/@pixi/core/lib/context/ContextSystem.mjs
  var CONTEXT_UID_COUNTER, ContextSystem;
  var init_ContextSystem = __esm({
    "node_modules/@pixi/core/lib/context/ContextSystem.mjs"() {
      init_lib();
      init_lib5();
      init_lib2();
      CONTEXT_UID_COUNTER = 0;
      ContextSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.webGLVersion = 1, this.extensions = {}, this.supports = {
            uint32Indices: false
          }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        contextChange(gl) {
          this.gl = gl, this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        }
        init(options) {
          if (options.context)
            this.initFromContext(options.context);
          else {
            const alpha = this.renderer.background.alpha < 1, premultipliedAlpha = options.premultipliedAlpha;
            this.preserveDrawingBuffer = options.preserveDrawingBuffer, this.useContextAlpha = options.useContextAlpha, this.powerPreference = options.powerPreference, this.initFromOptions({
              alpha,
              premultipliedAlpha,
              antialias: options.antialias,
              stencil: true,
              preserveDrawingBuffer: options.preserveDrawingBuffer,
              powerPreference: options.powerPreference
            });
          }
        }
        initFromContext(gl) {
          this.gl = gl, this.validateContext(gl), this.renderer.gl = gl, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(gl);
          const view = this.renderer.view;
          view.addEventListener !== void 0 && (view.addEventListener("webglcontextlost", this.handleContextLost, false), view.addEventListener("webglcontextrestored", this.handleContextRestored, false));
        }
        initFromOptions(options) {
          const gl = this.createContext(this.renderer.view, options);
          this.initFromContext(gl);
        }
        createContext(canvas, options) {
          let gl;
          if (settings.PREFER_ENV >= ENV.WEBGL2 && (gl = canvas.getContext("webgl2", options)), gl)
            this.webGLVersion = 2;
          else if (this.webGLVersion = 1, gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options), !gl)
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          return this.gl = gl, this.getExtensions(), this.gl;
        }
        getExtensions() {
          const { gl } = this, common = {
            loseContext: gl.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc")
          };
          this.webGLVersion === 1 ? Object.assign(this.extensions, common, {
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
          }) : this.webGLVersion === 2 && Object.assign(this.extensions, common, {
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          });
        }
        handleContextLost(event) {
          event.preventDefault(), setTimeout(() => {
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();
          }, 0);
        }
        handleContextRestored() {
          this.renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          const view = this.renderer.view;
          this.renderer = null, view.removeEventListener !== void 0 && (view.removeEventListener("webglcontextlost", this.handleContextLost), view.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
        }
        postrender() {
          this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
        }
        validateContext(gl) {
          const attributes = gl.getContextAttributes(), isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
          isWebGl2 && (this.webGLVersion = 2), attributes && !attributes.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
          this.supports.uint32Indices = hasuint32, hasuint32 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      };
      ContextSystem.defaultOptions = {
        context: null,
        antialias: false,
        premultipliedAlpha: true,
        preserveDrawingBuffer: false,
        powerPreference: "default"
      }, ContextSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "context"
      };
      extensions.add(ContextSystem);
    }
  });

  // node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs
  var Framebuffer;
  var init_Framebuffer = __esm({
    "node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs"() {
      init_lib();
      init_lib6();
      init_BaseTexture();
      Framebuffer = class {
        constructor(width, height) {
          if (this.width = Math.round(width), this.height = Math.round(height), !this.width || !this.height)
            throw new Error("Framebuffer width or height is zero");
          this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        addColorTexture(index = 0, texture) {
          return this.colorTextures[index] = texture || new BaseTexture(null, {
            scaleMode: SCALE_MODES.NEAREST,
            resolution: 1,
            mipmap: MIPMAP_MODES.OFF,
            width: this.width,
            height: this.height
          }), this.dirtyId++, this.dirtyFormat++, this;
        }
        addDepthTexture(texture) {
          return this.depthTexture = texture || new BaseTexture(null, {
            scaleMode: SCALE_MODES.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: MIPMAP_MODES.OFF,
            format: FORMATS.DEPTH_COMPONENT,
            type: TYPES.UNSIGNED_SHORT
          }), this.dirtyId++, this.dirtyFormat++, this;
        }
        enableDepth() {
          return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
        }
        enableStencil() {
          return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
        }
        resize(width, height) {
          if (width = Math.round(width), height = Math.round(height), !width || !height)
            throw new Error("Framebuffer width and height must not be zero");
          if (!(width === this.width && height === this.height)) {
            this.width = width, this.height = height, this.dirtyId++, this.dirtySize++;
            for (let i2 = 0; i2 < this.colorTextures.length; i2++) {
              const texture = this.colorTextures[i2], resolution = texture.resolution;
              texture.setSize(width / resolution, height / resolution);
            }
            if (this.depthTexture) {
              const resolution = this.depthTexture.resolution;
              this.depthTexture.setSize(width / resolution, height / resolution);
            }
          }
        }
        dispose() {
          this.disposeRunner.emit(this, false);
        }
        destroyDepthTexture() {
          this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs
  var BaseRenderTexture;
  var init_BaseRenderTexture = __esm({
    "node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs"() {
      init_lib3();
      init_lib();
      init_Framebuffer();
      init_BaseTexture();
      BaseRenderTexture = class extends BaseTexture {
        constructor(options = {}) {
          if (typeof options == "number") {
            const width = arguments[0], height = arguments[1], scaleMode = arguments[2], resolution = arguments[3];
            options = { width, height, scaleMode, resolution };
          }
          options.width = options.width ?? 100, options.height = options.height ?? 100, options.multisample ?? (options.multisample = MSAA_QUALITY.NONE), super(null, options), this.mipmap = MIPMAP_MODES.OFF, this.valid = true, this._clear = new Color([0, 0, 0, 0]), this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = options.multisample, this.maskStack = [], this.filterStack = [{}];
        }
        set clearColor(value) {
          this._clear.setValue(value);
        }
        get clearColor() {
          return this._clear.value;
        }
        get clear() {
          return this._clear;
        }
        get multisample() {
          return this.framebuffer.multisample;
        }
        set multisample(value) {
          this.framebuffer.multisample = value;
        }
        resize(desiredWidth, desiredHeight) {
          this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
        }
        dispose() {
          this.framebuffer.dispose(), super.dispose();
        }
        destroy() {
          super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs
  var BaseImageResource;
  var init_BaseImageResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs"() {
      init_lib();
      init_lib4();
      init_Resource();
      BaseImageResource = class extends Resource {
        constructor(source2) {
          const sourceAny = source2, width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width, height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
          super(width, height), this.source = source2, this.noSubImage = false;
        }
        static crossOrigin(element, url2, crossorigin) {
          crossorigin === void 0 && !url2.startsWith("data:") ? element.crossOrigin = determineCrossOrigin(url2) : crossorigin !== false && (element.crossOrigin = typeof crossorigin == "string" ? crossorigin : "anonymous");
        }
        upload(renderer, baseTexture, glTexture, source2) {
          const gl = renderer.gl, width = baseTexture.realWidth, height = baseTexture.realHeight;
          if (source2 = source2 || this.source, typeof HTMLImageElement < "u" && source2 instanceof HTMLImageElement) {
            if (!source2.complete || source2.naturalWidth === 0)
              return false;
          } else if (typeof HTMLVideoElement < "u" && source2 instanceof HTMLVideoElement && source2.readyState <= 1)
            return false;
          return gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height ? gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source2) : (glTexture.width = width, glTexture.height = height, gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source2)), true;
        }
        update() {
          if (this.destroyed)
            return;
          const source2 = this.source, width = source2.naturalWidth || source2.videoWidth || source2.width, height = source2.naturalHeight || source2.videoHeight || source2.height;
          this.resize(width, height), super.update();
        }
        dispose() {
          this.source = null;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs
  var ImageResource;
  var init_ImageResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs"() {
      init_lib();
      init_lib2();
      init_BaseImageResource();
      ImageResource = class extends BaseImageResource {
        constructor(source2, options) {
          if (options = options || {}, typeof source2 == "string") {
            const imageElement = new Image();
            BaseImageResource.crossOrigin(imageElement, source2, options.crossorigin), imageElement.src = source2, source2 = imageElement;
          }
          super(source2), !source2.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = source2.src, this._process = null, this.preserveBitmap = false, this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.bitmap = null, this._load = null, options.autoLoad !== false && this.load();
        }
        load(createBitmap) {
          return this._load ? this._load : (createBitmap !== void 0 && (this.createBitmap = createBitmap), this._load = new Promise((resolve2, reject) => {
            const source2 = this.source;
            this.url = source2.src;
            const completed = () => {
              this.destroyed || (source2.onload = null, source2.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve2(this.process()) : resolve2(this));
            };
            source2.complete && source2.src ? completed() : (source2.onload = completed, source2.onerror = (event) => {
              reject(event), this.onError.emit(event);
            });
          }), this._load);
        }
        process() {
          const source2 = this.source;
          if (this._process !== null)
            return this._process;
          if (this.bitmap !== null || !globalThis.createImageBitmap)
            return Promise.resolve(this);
          const createImageBitmap2 = globalThis.createImageBitmap, cors = !source2.crossOrigin || source2.crossOrigin === "anonymous";
          return this._process = fetch(
            source2.src,
            {
              mode: cors ? "cors" : "no-cors"
            }
          ).then((r2) => r2.blob()).then((blob) => createImageBitmap2(
            blob,
            0,
            0,
            source2.width,
            source2.height,
            {
              premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
            }
          )).then((bitmap) => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;
        }
        upload(renderer, baseTexture, glTexture) {
          if (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap)
            return super.upload(renderer, baseTexture, glTexture);
          if (!this.bitmap && (this.process(), !this.bitmap))
            return false;
          if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {
            let flag = true;
            const glTextures = baseTexture._glTextures;
            for (const key in glTextures) {
              const otherTex = glTextures[key];
              if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
                flag = false;
                break;
              }
            }
            flag && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
          }
          return true;
        }
        dispose() {
          this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
        }
        static test(source2) {
          return typeof HTMLImageElement < "u" && (typeof source2 == "string" || source2 instanceof HTMLImageElement);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/TextureUvs.mjs
  var TextureUvs;
  var init_TextureUvs = __esm({
    "node_modules/@pixi/core/lib/textures/TextureUvs.mjs"() {
      init_lib7();
      TextureUvs = class {
        constructor() {
          this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
        }
        set(frame, baseFrame, rotate) {
          const tw = baseFrame.width, th = baseFrame.height;
          if (rotate) {
            const w2 = frame.width / 2 / tw, h2 = frame.height / 2 / th, cX = frame.x / tw + w2, cY = frame.y / th + h2;
            rotate = groupD8.add(rotate, groupD8.NW), this.x0 = cX + w2 * groupD8.uX(rotate), this.y0 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x1 = cX + w2 * groupD8.uX(rotate), this.y1 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x2 = cX + w2 * groupD8.uX(rotate), this.y2 = cY + h2 * groupD8.uY(rotate), rotate = groupD8.add(rotate, 2), this.x3 = cX + w2 * groupD8.uX(rotate), this.y3 = cY + h2 * groupD8.uY(rotate);
          } else
            this.x0 = frame.x / tw, this.y0 = frame.y / th, this.x1 = (frame.x + frame.width) / tw, this.y1 = frame.y / th, this.x2 = (frame.x + frame.width) / tw, this.y2 = (frame.y + frame.height) / th, this.x3 = frame.x / tw, this.y3 = (frame.y + frame.height) / th;
          this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
        }
      };
      TextureUvs.prototype.toString = function() {
        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/Texture.mjs
  function removeAllHandlers(tex) {
    tex.destroy = function() {
    }, tex.on = function() {
    }, tex.once = function() {
    }, tex.emit = function() {
    };
  }
  var DEFAULT_UVS, Texture;
  var init_Texture = __esm({
    "node_modules/@pixi/core/lib/textures/Texture.mjs"() {
      init_lib7();
      init_lib2();
      init_lib4();
      init_BaseTexture();
      init_ImageResource();
      init_TextureUvs();
      DEFAULT_UVS = new TextureUvs();
      Texture = class extends import_eventemitter3.default {
        constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
          if (super(), this.noFrame = false, frame || (this.noFrame = true, frame = new Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = false, this.destroyed = false, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), rotate === true)
            this._rotate = 2;
          else if (this._rotate % 2 !== 0)
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
          this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0), this.defaultBorders = borders, this._updateID = 0, this.textureCacheIds = [], baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && baseTexture.on("update", this.onBaseTextureUpdated, this);
        }
        update() {
          this.baseTexture.resource && this.baseTexture.resource.update();
        }
        onBaseTextureUpdated(baseTexture) {
          if (this.noFrame) {
            if (!this.baseTexture.valid)
              return;
            this._frame.width = baseTexture.width, this._frame.height = baseTexture.height, this.valid = true, this.updateUvs();
          } else
            this.frame = this._frame;
          this.emit("update", this);
        }
        destroy(destroyBase) {
          if (this.baseTexture) {
            if (destroyBase) {
              const { resource } = this.baseTexture;
              resource?.url && TextureCache[resource.url] && Texture.removeFromCache(resource.url), this.baseTexture.destroy();
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
          }
          this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, Texture.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true, this.emit("destroyed", this), this.removeAllListeners();
        }
        clone() {
          const clonedFrame = this._frame.clone(), clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone(), clonedTexture = new Texture(
            this.baseTexture,
            !this.noFrame && clonedFrame,
            clonedOrig,
            this.trim?.clone(),
            this.rotate,
            this.defaultAnchor,
            this.defaultBorders
          );
          return this.noFrame && (clonedTexture._frame = clonedFrame), clonedTexture;
        }
        updateUvs() {
          this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
        }
        static from(source2, options = {}, strict = settings.STRICT_TEXTURE_CACHE) {
          const isFrame = typeof source2 == "string";
          let cacheId = null;
          if (isFrame)
            cacheId = source2;
          else if (source2 instanceof BaseTexture) {
            if (!source2.cacheId) {
              const prefix = options?.pixiIdPrefix || "pixiid";
              source2.cacheId = `${prefix}-${uid()}`, BaseTexture.addToCache(source2, source2.cacheId);
            }
            cacheId = source2.cacheId;
          } else {
            if (!source2._pixiId) {
              const prefix = options?.pixiIdPrefix || "pixiid";
              source2._pixiId = `${prefix}_${uid()}`;
            }
            cacheId = source2._pixiId;
          }
          let texture = TextureCache[cacheId];
          if (isFrame && strict && !texture)
            throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
          return !texture && !(source2 instanceof BaseTexture) ? (options.resolution || (options.resolution = getResolutionOfUrl(source2)), texture = new Texture(new BaseTexture(source2, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)) : !texture && source2 instanceof BaseTexture && (texture = new Texture(source2), Texture.addToCache(texture, cacheId)), texture;
        }
        static fromURL(url2, options) {
          const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions), texture = Texture.from(url2, Object.assign({ resourceOptions }, options), false), resource = texture.baseTexture.resource;
          return texture.baseTexture.valid ? Promise.resolve(texture) : resource.load().then(() => Promise.resolve(texture));
        }
        static fromBuffer(buffer, width, height, options) {
          return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));
        }
        static fromLoader(source2, imageUrl, name, options) {
          const baseTexture = new BaseTexture(source2, Object.assign({
            scaleMode: BaseTexture.defaultOptions.scaleMode,
            resolution: getResolutionOfUrl(imageUrl)
          }, options)), { resource } = baseTexture;
          resource instanceof ImageResource && (resource.url = imageUrl);
          const texture = new Texture(baseTexture);
          return name || (name = imageUrl), BaseTexture.addToCache(texture.baseTexture, name), Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise((resolve2) => {
            texture.baseTexture.once("loaded", () => resolve2(texture));
          });
        }
        static addToCache(texture, id) {
          id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), TextureCache[id] && TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), TextureCache[id] = texture);
        }
        static removeFromCache(texture) {
          if (typeof texture == "string") {
            const textureFromCache = TextureCache[texture];
            if (textureFromCache) {
              const index = textureFromCache.textureCacheIds.indexOf(texture);
              return index > -1 && textureFromCache.textureCacheIds.splice(index, 1), delete TextureCache[texture], textureFromCache;
            }
          } else if (texture?.textureCacheIds) {
            for (let i2 = 0; i2 < texture.textureCacheIds.length; ++i2)
              TextureCache[texture.textureCacheIds[i2]] === texture && delete TextureCache[texture.textureCacheIds[i2]];
            return texture.textureCacheIds.length = 0, texture;
          }
          return null;
        }
        get resolution() {
          return this.baseTexture.resolution;
        }
        get frame() {
          return this._frame;
        }
        set frame(frame) {
          this._frame = frame, this.noFrame = false;
          const { x: x2, y: y2, width, height } = frame, xNotFit = x2 + width > this.baseTexture.width, yNotFit = y2 + height > this.baseTexture.height;
          if (xNotFit || yNotFit) {
            const relationship = xNotFit && yNotFit ? "and" : "or", errorX = `X: ${x2} + ${width} = ${x2 + width} > ${this.baseTexture.width}`, errorY = `Y: ${y2} + ${height} = ${y2 + height} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
          }
          this.valid = width && height && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = frame), this.valid && this.updateUvs();
        }
        get rotate() {
          return this._rotate;
        }
        set rotate(rotate) {
          this._rotate = rotate, this.valid && this.updateUvs();
        }
        get width() {
          return this.orig.width;
        }
        get height() {
          return this.orig.height;
        }
        castToBaseTexture() {
          return this.baseTexture;
        }
        static get EMPTY() {
          return Texture._EMPTY || (Texture._EMPTY = new Texture(new BaseTexture()), removeAllHandlers(Texture._EMPTY), removeAllHandlers(Texture._EMPTY.baseTexture)), Texture._EMPTY;
        }
        static get WHITE() {
          if (!Texture._WHITE) {
            const canvas = settings.ADAPTER.createCanvas(16, 16), context3 = canvas.getContext("2d");
            canvas.width = 16, canvas.height = 16, context3.fillStyle = "white", context3.fillRect(0, 0, 16, 16), Texture._WHITE = new Texture(BaseTexture.from(canvas)), removeAllHandlers(Texture._WHITE), removeAllHandlers(Texture._WHITE.baseTexture);
          }
          return Texture._WHITE;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs
  var RenderTexture;
  var init_RenderTexture = __esm({
    "node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs"() {
      init_Texture();
      init_BaseRenderTexture();
      RenderTexture = class extends Texture {
        constructor(baseRenderTexture, frame) {
          super(baseRenderTexture, frame), this.valid = true, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs();
        }
        get framebuffer() {
          return this.baseTexture.framebuffer;
        }
        get multisample() {
          return this.framebuffer.multisample;
        }
        set multisample(value) {
          this.framebuffer.multisample = value;
        }
        resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
          const resolution = this.baseTexture.resolution, width = Math.round(desiredWidth * resolution) / resolution, height = Math.round(desiredHeight * resolution) / resolution;
          this.valid = width > 0 && height > 0, this._frame.width = this.orig.width = width, this._frame.height = this.orig.height = height, resizeBaseTexture && this.baseTexture.resize(width, height), this.updateUvs();
        }
        setResolution(resolution) {
          const { baseTexture } = this;
          baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, false));
        }
        static create(options) {
          return new RenderTexture(new BaseRenderTexture(options));
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs
  var RenderTexturePool;
  var init_RenderTexturePool = __esm({
    "node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs"() {
      init_lib();
      init_lib4();
      init_BaseRenderTexture();
      init_RenderTexture();
      RenderTexturePool = class {
        constructor(textureOptions) {
          this.texturePool = {}, this.textureOptions = textureOptions || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
        }
        createTexture(realWidth, realHeight, multisample = MSAA_QUALITY.NONE) {
          const baseRenderTexture = new BaseRenderTexture(Object.assign({
            width: realWidth,
            height: realHeight,
            resolution: 1,
            multisample
          }, this.textureOptions));
          return new RenderTexture(baseRenderTexture);
        }
        getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
          let key;
          minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1), minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1), !this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight ? (minWidth = nextPow2(minWidth), minHeight = nextPow2(minHeight), key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, multisample > 1 && (key += multisample * 4294967296)) : key = multisample > 1 ? -multisample : -1, this.texturePool[key] || (this.texturePool[key] = []);
          let renderTexture = this.texturePool[key].pop();
          return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture;
        }
        getFilterTexture(input, resolution, multisample) {
          const filterTexture = this.getOptimalTexture(
            input.width,
            input.height,
            resolution || input.resolution,
            multisample || MSAA_QUALITY.NONE
          );
          return filterTexture.filterFrame = input.filterFrame, filterTexture;
        }
        returnTexture(renderTexture) {
          const key = renderTexture.filterPoolKey;
          renderTexture.filterFrame = null, this.texturePool[key].push(renderTexture);
        }
        returnFilterTexture(renderTexture) {
          this.returnTexture(renderTexture);
        }
        clear(destroyTextures) {
          if (destroyTextures = destroyTextures !== false, destroyTextures)
            for (const i2 in this.texturePool) {
              const textures = this.texturePool[i2];
              if (textures)
                for (let j2 = 0; j2 < textures.length; j2++)
                  textures[j2].destroy(true);
            }
          this.texturePool = {};
        }
        setScreenSize(size) {
          if (!(size.width === this._pixelsWidth && size.height === this._pixelsHeight)) {
            this.enableFullScreen = size.width > 0 && size.height > 0;
            for (const i2 in this.texturePool) {
              if (!(Number(i2) < 0))
                continue;
              const textures = this.texturePool[i2];
              if (textures)
                for (let j2 = 0; j2 < textures.length; j2++)
                  textures[j2].destroy(true);
              this.texturePool[i2] = [];
            }
            this._pixelsWidth = size.width, this._pixelsHeight = size.height;
          }
        }
      };
      RenderTexturePool.SCREEN_KEY = -1;
    }
  });

  // node_modules/@pixi/core/lib/utils/Quad.mjs
  var Quad;
  var init_Quad = __esm({
    "node_modules/@pixi/core/lib/utils/Quad.mjs"() {
      init_Geometry();
      Quad = class extends Geometry {
        constructor() {
          super(), this.addAttribute("aVertexPosition", new Float32Array([
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
          ])).addIndex([0, 1, 3, 2]);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/utils/QuadUv.mjs
  var QuadUv;
  var init_QuadUv = __esm({
    "node_modules/@pixi/core/lib/utils/QuadUv.mjs"() {
      init_Buffer();
      init_Geometry();
      QuadUv = class extends Geometry {
        constructor() {
          super(), this.vertices = new Float32Array([
            -1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            1
          ]), this.uvs = new Float32Array([
            0,
            0,
            1,
            0,
            1,
            1,
            0,
            1
          ]), this.vertexBuffer = new Buffer2(this.vertices), this.uvBuffer = new Buffer2(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
        }
        map(targetTextureFrame, destinationFrame) {
          let x2 = 0, y2 = 0;
          return this.uvs[0] = x2, this.uvs[1] = y2, this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y2, this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x2, this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height, x2 = destinationFrame.x, y2 = destinationFrame.y, this.vertices[0] = x2, this.vertices[1] = y2, this.vertices[2] = x2 + destinationFrame.width, this.vertices[3] = y2, this.vertices[4] = x2 + destinationFrame.width, this.vertices[5] = y2 + destinationFrame.height, this.vertices[6] = x2, this.vertices[7] = y2 + destinationFrame.height, this.invalidate(), this;
        }
        invalidate() {
          return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/filters/FilterState.mjs
  var FilterState;
  var init_FilterState = __esm({
    "node_modules/@pixi/core/lib/filters/FilterState.mjs"() {
      init_lib();
      init_lib7();
      FilterState = class {
        constructor() {
          this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;
        }
        clear() {
          this.target = null, this.filters = null, this.renderTexture = null;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/filters/FilterSystem.mjs
  var tempPoints2, tempMatrix, FilterSystem;
  var init_FilterSystem = __esm({
    "node_modules/@pixi/core/lib/filters/FilterSystem.mjs"() {
      init_lib();
      init_lib5();
      init_lib7();
      init_RenderTexturePool();
      init_UniformGroup();
      init_Quad();
      init_QuadUv();
      init_FilterState();
      tempPoints2 = [new Point(), new Point(), new Point(), new Point()];
      tempMatrix = new Matrix();
      FilterSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({
            outputFrame: new Rectangle(),
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
          }, true), this.forceClear = false, this.useMaxPadding = false;
        }
        init() {
          this.texturePool.setScreenSize(this.renderer.view);
        }
        push(target, filters2) {
          const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState(), renderTextureSystem = renderer.renderTexture;
          let currentResolution, currentMultisample;
          if (renderTextureSystem.current) {
            const renderTexture = renderTextureSystem.current;
            currentResolution = renderTexture.resolution, currentMultisample = renderTexture.multisample;
          } else
            currentResolution = renderer.resolution, currentMultisample = renderer.multisample;
          let resolution = filters2[0].resolution || currentResolution, multisample = filters2[0].multisample ?? currentMultisample, padding = filters2[0].padding, autoFit = filters2[0].autoFit, legacy = filters2[0].legacy ?? true;
          for (let i2 = 1; i2 < filters2.length; i2++) {
            const filter = filters2[i2];
            resolution = Math.min(resolution, filter.resolution || currentResolution), multisample = Math.min(multisample, filter.multisample ?? currentMultisample), padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding, autoFit = autoFit && filter.autoFit, legacy = legacy || (filter.legacy ?? true);
          }
          filterStack.length === 1 && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current), filterStack.push(state), state.resolution = resolution, state.multisample = multisample, state.legacy = legacy, state.target = target, state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true)), state.sourceFrame.pad(padding);
          const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
          renderer.projection.transform && this.transformAABB(
            tempMatrix.copyFrom(renderer.projection.transform).invert(),
            sourceFrameProjected
          ), autoFit ? (state.sourceFrame.fit(sourceFrameProjected), (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(sourceFrameProjected) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0), this.roundFrame(
            state.sourceFrame,
            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
            renderTextureSystem.sourceFrame,
            renderTextureSystem.destinationFrame,
            renderer.projection.transform
          ), state.renderTexture = this.getOptimalFilterTexture(
            state.sourceFrame.width,
            state.sourceFrame.height,
            resolution,
            multisample
          ), state.filters = filters2, state.destinationFrame.width = state.renderTexture.width, state.destinationFrame.height = state.renderTexture.height;
          const destinationFrame = this.tempRect;
          destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = state.sourceFrame.width, destinationFrame.height = state.sourceFrame.height, state.renderTexture.filterFrame = state.sourceFrame, state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame), state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame), state.transform = renderer.projection.transform, renderer.projection.transform = null, renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame), renderer.framebuffer.clear(0, 0, 0, 0);
        }
        pop() {
          const filterStack = this.defaultFilterStack, state = filterStack.pop(), filters2 = state.filters;
          this.activeState = state;
          const globalUniforms = this.globalUniforms.uniforms;
          globalUniforms.outputFrame = state.sourceFrame, globalUniforms.resolution = state.resolution;
          const inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;
          if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {
            const filterArea = globalUniforms.filterArea;
            filterArea[0] = state.destinationFrame.width, filterArea[1] = state.destinationFrame.height, filterArea[2] = state.sourceFrame.x, filterArea[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;
          }
          this.globalUniforms.update();
          const lastState = filterStack[filterStack.length - 1];
          if (this.renderer.framebuffer.blit(), filters2.length === 1)
            filters2[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);
          else {
            let flip = state.renderTexture, flop = this.getOptimalFilterTexture(
              flip.width,
              flip.height,
              state.resolution
            );
            flop.filterFrame = flip.filterFrame;
            let i2 = 0;
            for (i2 = 0; i2 < filters2.length - 1; ++i2) {
              i2 === 1 && state.multisample > 1 && (flop = this.getOptimalFilterTexture(
                flip.width,
                flip.height,
                state.resolution
              ), flop.filterFrame = flip.filterFrame), filters2[i2].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);
              const t2 = flip;
              flip = flop, flop = t2;
            }
            filters2[i2].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state), i2 > 1 && state.multisample > 1 && this.returnFilterTexture(state.renderTexture), this.returnFilterTexture(flip), this.returnFilterTexture(flop);
          }
          state.clear(), this.statePool.push(state);
        }
        bindAndClear(filterTexture, clearMode = CLEAR_MODES.CLEAR) {
          const {
            renderTexture: renderTextureSystem,
            state: stateSystem
          } = this.renderer;
          if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {
            const destinationFrame = this.tempRect;
            destinationFrame.x = 0, destinationFrame.y = 0, destinationFrame.width = filterTexture.filterFrame.width, destinationFrame.height = filterTexture.filterFrame.height, renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
          } else
            filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(
              filterTexture,
              this.activeState.bindingSourceFrame,
              this.activeState.bindingDestinationFrame
            );
          const autoClear = stateSystem.stateId & 1 || this.forceClear;
          (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) && this.renderer.framebuffer.clear(0, 0, 0, 0);
        }
        applyFilter(filter, input, output, clearMode) {
          const renderer = this.renderer;
          renderer.state.set(filter.state), this.bindAndClear(output, clearMode), filter.uniforms.uSampler = input, filter.uniforms.filterGlobals = this.globalUniforms, renderer.shader.bind(filter), filter.legacy = !!filter.program.attributeData.aTextureCoord, filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
        }
        calculateSpriteMatrix(outputMatrix, sprite) {
          const { sourceFrame, destinationFrame } = this.activeState, { orig } = sprite._texture, mappedMatrix = outputMatrix.set(
            destinationFrame.width,
            0,
            0,
            destinationFrame.height,
            sourceFrame.x,
            sourceFrame.y
          ), worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
          return worldTransform.invert(), mappedMatrix.prepend(worldTransform), mappedMatrix.scale(1 / orig.width, 1 / orig.height), mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y), mappedMatrix;
        }
        destroy() {
          this.renderer = null, this.texturePool.clear(false);
        }
        getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = MSAA_QUALITY.NONE) {
          return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
        }
        getFilterTexture(input, resolution, multisample) {
          if (typeof input == "number") {
            const swap = input;
            input = resolution, resolution = swap;
          }
          input = input || this.activeState.renderTexture;
          const filterTexture = this.texturePool.getOptimalTexture(
            input.width,
            input.height,
            resolution || input.resolution,
            multisample || MSAA_QUALITY.NONE
          );
          return filterTexture.filterFrame = input.filterFrame, filterTexture;
        }
        returnFilterTexture(renderTexture) {
          this.texturePool.returnTexture(renderTexture);
        }
        emptyPool() {
          this.texturePool.clear(true);
        }
        resize() {
          this.texturePool.setScreenSize(this.renderer.view);
        }
        transformAABB(matrix, rect) {
          const lt = tempPoints2[0], lb = tempPoints2[1], rt = tempPoints2[2], rb = tempPoints2[3];
          lt.set(rect.left, rect.top), lb.set(rect.left, rect.bottom), rt.set(rect.right, rect.top), rb.set(rect.right, rect.bottom), matrix.apply(lt, lt), matrix.apply(lb, lb), matrix.apply(rt, rt), matrix.apply(rb, rb);
          const x0 = Math.min(lt.x, lb.x, rt.x, rb.x), y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x), y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
          rect.x = x0, rect.y = y0, rect.width = x1 - x0, rect.height = y1 - y0;
        }
        roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform2) {
          if (!(frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)) {
            if (transform2) {
              const { a: a2, b: b2, c: c2, d: d2 } = transform2;
              if ((Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4))
                return;
            }
            transform2 = transform2 ? tempMatrix.copyFrom(transform2) : tempMatrix.identity(), transform2.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
              bindingDestinationFrame.width / bindingSourceFrame.width,
              bindingDestinationFrame.height / bindingSourceFrame.height
            ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.transformAABB(transform2, frame), frame.ceil(resolution), this.transformAABB(transform2.invert(), frame);
          }
        }
      };
      FilterSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "filter"
      };
      extensions.add(FilterSystem);
    }
  });

  // node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs
  var GLFramebuffer;
  var init_GLFramebuffer = __esm({
    "node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs"() {
      init_lib();
      GLFramebuffer = class {
        constructor(framebuffer) {
          this.framebuffer = framebuffer, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs
  var tempRectangle, FramebufferSystem;
  var init_FramebufferSystem = __esm({
    "node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs"() {
      init_lib();
      init_lib5();
      init_lib7();
      init_lib2();
      init_Framebuffer();
      init_GLFramebuffer();
      tempRectangle = new Rectangle();
      FramebufferSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
        }
        contextChange() {
          this.disposeAll(true);
          const gl = this.gl = this.renderer.gl;
          if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = true, this.writeDepthTexture = true, this.renderer.context.webGLVersion === 1) {
            let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
            settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null), nativeDrawBuffersExtension ? gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = false, gl.drawBuffers = () => {
            }), nativeDepthTextureExtension || (this.writeDepthTexture = false);
          } else
            this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
        }
        bind(framebuffer, frame, mipLevel = 0) {
          const { gl } = this;
          if (framebuffer) {
            const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
            this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer)), fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel), fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));
            for (let i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
              const tex = framebuffer.colorTextures[i2];
              this.renderer.texture.unbind(tex.parentTextureArray || tex);
            }
            if (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) {
              const mipWidth = frame.width >> mipLevel, mipHeight = frame.height >> mipLevel, scale = mipWidth / frame.width;
              this.setViewport(
                frame.x * scale,
                frame.y * scale,
                mipWidth,
                mipHeight
              );
            } else {
              const mipWidth = framebuffer.width >> mipLevel, mipHeight = framebuffer.height >> mipLevel;
              this.setViewport(0, 0, mipWidth, mipHeight);
            }
          } else
            this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }
        setViewport(x2, y2, width, height) {
          const v2 = this.viewport;
          x2 = Math.round(x2), y2 = Math.round(y2), width = Math.round(width), height = Math.round(height), (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) && (v2.x = x2, v2.y = y2, v2.width = width, v2.height = height, this.gl.viewport(x2, y2, width, height));
        }
        get size() {
          return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
        }
        clear(r2, g2, b2, a2, mask = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH) {
          const { gl } = this;
          gl.clearColor(r2, g2, b2, a2), gl.clear(mask);
        }
        initFramebuffer(framebuffer) {
          const { gl } = this, fbo = new GLFramebuffer(gl.createFramebuffer());
          return fbo.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), fbo;
        }
        resizeFramebuffer(framebuffer) {
          const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
          if (fbo.stencil) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            let stencilFormat;
            this.renderer.context.webGLVersion === 1 ? stencilFormat = gl.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl.DEPTH_COMPONENT24 : stencilFormat = gl.STENCIL_INDEX8, fbo.msaaBuffer ? gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              fbo.multisample,
              stencilFormat,
              framebuffer.width,
              framebuffer.height
            ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);
          }
          const colorTextures = framebuffer.colorTextures;
          let count2 = colorTextures.length;
          gl.drawBuffers || (count2 = Math.min(count2, 1));
          for (let i2 = 0; i2 < count2; i2++) {
            const texture = colorTextures[i2], parentTexture = texture.parentTextureArray || texture;
            this.renderer.texture.bind(parentTexture, 0), i2 === 0 && fbo.msaaBuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              fbo.multisample,
              parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
              framebuffer.width,
              framebuffer.height
            ));
          }
          framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
        updateFramebuffer(framebuffer, mipLevel) {
          const { gl } = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], colorTextures = framebuffer.colorTextures;
          let count2 = colorTextures.length;
          gl.drawBuffers || (count2 = Math.min(count2, 1)), fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer() : fbo.msaaBuffer && (gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));
          const activeTextures = [];
          for (let i2 = 0; i2 < count2; i2++) {
            const texture = colorTextures[i2], parentTexture = texture.parentTextureArray || texture;
            this.renderer.texture.bind(parentTexture, 0), i2 === 0 && fbo.msaaBuffer ? (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              fbo.multisample,
              parentTexture._glTextures[this.CONTEXT_UID].internalFormat,
              framebuffer.width,
              framebuffer.height
            ), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer)) : (gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              texture.target,
              parentTexture._glTextures[this.CONTEXT_UID].texture,
              mipLevel
            ), activeTextures.push(gl.COLOR_ATTACHMENT0 + i2));
          }
          if (activeTextures.length > 1 && gl.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {
            const depthTexture = framebuffer.depthTexture;
            this.renderer.texture.bind(depthTexture, 0), gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.DEPTH_ATTACHMENT,
              gl.TEXTURE_2D,
              depthTexture._glTextures[this.CONTEXT_UID].texture,
              mipLevel
            );
          }
          if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
            fbo.stencil = fbo.stencil || gl.createRenderbuffer();
            let stencilAttachment, stencilFormat;
            this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_ATTACHMENT, stencilFormat = gl.DEPTH_COMPONENT24) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              fbo.multisample,
              stencilFormat,
              framebuffer.width,
              framebuffer.height
            ) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, fbo.stencil);
          } else
            fbo.stencil && (gl.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);
        }
        canMultisampleFramebuffer(framebuffer) {
          return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
        }
        detectSamples(samples) {
          const { msaaSamples } = this;
          let res = MSAA_QUALITY.NONE;
          if (samples <= 1 || msaaSamples === null)
            return res;
          for (let i2 = 0; i2 < msaaSamples.length; i2++)
            if (msaaSamples[i2] <= samples) {
              res = msaaSamples[i2];
              break;
            }
          return res === 1 && (res = MSAA_QUALITY.NONE), res;
        }
        blit(framebuffer, sourcePixels, destPixels) {
          const { current, renderer, gl, CONTEXT_UID } = this;
          if (renderer.context.webGLVersion !== 2 || !current)
            return;
          const fbo = current.glFramebuffers[CONTEXT_UID];
          if (!fbo)
            return;
          if (!framebuffer) {
            if (!fbo.msaaBuffer)
              return;
            const colorTexture = current.colorTextures[0];
            if (!colorTexture)
              return;
            fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture)), framebuffer = fbo.blitFramebuffer, framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++), (framebuffer.width !== current.width || framebuffer.height !== current.height) && (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);
          }
          sourcePixels || (sourcePixels = tempRectangle, sourcePixels.width = current.width, sourcePixels.height = current.height), destPixels || (destPixels = sourcePixels);
          const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
          this.bind(framebuffer), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer), gl.blitFramebuffer(
            sourcePixels.left,
            sourcePixels.top,
            sourcePixels.right,
            sourcePixels.bottom,
            destPixels.left,
            destPixels.top,
            destPixels.right,
            destPixels.bottom,
            gl.COLOR_BUFFER_BIT,
            sameSize ? gl.NEAREST : gl.LINEAR
          ), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
        }
        disposeFramebuffer(framebuffer, contextLost) {
          const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl = this.gl;
          if (!fbo)
            return;
          delete framebuffer.glFramebuffers[this.CONTEXT_UID];
          const index = this.managedFramebuffers.indexOf(framebuffer);
          index >= 0 && this.managedFramebuffers.splice(index, 1), framebuffer.disposeRunner.remove(this), contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil)), fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
        }
        disposeAll(contextLost) {
          const list = this.managedFramebuffers;
          this.managedFramebuffers = [];
          for (let i2 = 0; i2 < list.length; i2++)
            this.disposeFramebuffer(list[i2], contextLost);
        }
        forceStencil() {
          const framebuffer = this.current;
          if (!framebuffer)
            return;
          const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
          if (!fbo || fbo.stencil && framebuffer.stencil)
            return;
          framebuffer.stencil = true;
          const w2 = framebuffer.width, h2 = framebuffer.height, gl = this.gl, stencil = fbo.stencil = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
          let stencilAttachment, stencilFormat;
          this.renderer.context.webGLVersion === 1 ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8), fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, w2, h2) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, w2, h2), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, stencil);
        }
        reset() {
          this.current = this.unknownFramebuffer, this.viewport = new Rectangle();
        }
        destroy() {
          this.renderer = null;
        }
      };
      FramebufferSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "framebuffer"
      };
      extensions.add(FramebufferSystem);
    }
  });

  // node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs
  var byteSizeMap2, GeometrySystem;
  var init_GeometrySystem = __esm({
    "node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs"() {
      init_lib();
      init_lib5();
      init_lib2();
      byteSizeMap2 = { 5126: 4, 5123: 2, 5121: 1 };
      GeometrySystem = class {
        constructor(renderer) {
          this.renderer = renderer, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
        }
        contextChange() {
          this.disposeAll(true);
          const gl = this.gl = this.renderer.gl, context3 = this.renderer.context;
          if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, context3.webGLVersion !== 2) {
            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
            settings.PREFER_ENV === ENV.WEBGL_LEGACY && (nativeVaoExtension = null), nativeVaoExtension ? (gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao), gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = false, gl.createVertexArray = () => null, gl.bindVertexArray = () => null, gl.deleteVertexArray = () => null);
          }
          if (context3.webGLVersion !== 2) {
            const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
            instanceExt ? (gl.vertexAttribDivisor = (a2, b2) => instanceExt.vertexAttribDivisorANGLE(a2, b2), gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => instanceExt.drawElementsInstancedANGLE(a2, b2, c2, d2, e2), gl.drawArraysInstanced = (a2, b2, c2, d2) => instanceExt.drawArraysInstancedANGLE(a2, b2, c2, d2)) : this.hasInstance = false;
          }
          this.canUseUInt32ElementIndex = context3.webGLVersion === 2 || !!context3.extensions.uint32ElementIndex;
        }
        bind(geometry, shader) {
          shader = shader || this.renderer.shader.shader;
          const { gl } = this;
          let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], incRefCount = false;
          vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = true);
          const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
          this._activeGeometry = geometry, this._activeVao !== vao && (this._activeVao = vao, this.hasVao ? gl.bindVertexArray(vao) : this.activateVao(geometry, shader.program)), this.updateBuffers();
        }
        reset() {
          this.unbind();
        }
        updateBuffers() {
          const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;
          for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
            const buffer = geometry.buffers[i2];
            bufferSystem.update(buffer);
          }
        }
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes, shaderAttributes = program.attributeData;
          for (const j2 in shaderAttributes)
            if (!geometryAttributes[j2])
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
        }
        getSignature(geometry, program) {
          const attribs = geometry.attributes, shaderAttributes = program.attributeData, strings = ["g", geometry.id];
          for (const i2 in attribs)
            shaderAttributes[i2] && strings.push(i2, shaderAttributes[i2].location);
          return strings.join("-");
        }
        initGeometryVao(geometry, shader, incRefCount = true) {
          const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;
          program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader), this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program), vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
          let vao = vaoObjectHash[signature];
          if (vao)
            return vaoObjectHash[program.id] = vao, vao;
          const buffers = geometry.buffers, attributes = geometry.attributes, tempStride = {}, tempStart = {};
          for (const j2 in buffers)
            tempStride[j2] = 0, tempStart[j2] = 0;
          for (const j2 in attributes)
            !attributes[j2].size && program.attributeData[j2] ? attributes[j2].size = program.attributeData[j2].size : attributes[j2].size || console.warn(`PIXI Geometry attribute '${j2}' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap2[attributes[j2].type];
          for (const j2 in attributes) {
            const attribute = attributes[j2], attribSize = attribute.size;
            attribute.stride === void 0 && (tempStride[attribute.buffer] === attribSize * byteSizeMap2[attribute.type] ? attribute.stride = 0 : attribute.stride = tempStride[attribute.buffer]), attribute.start === void 0 && (attribute.start = tempStart[attribute.buffer], tempStart[attribute.buffer] += attribSize * byteSizeMap2[attribute.type]);
          }
          vao = gl.createVertexArray(), gl.bindVertexArray(vao);
          for (let i2 = 0; i2 < buffers.length; i2++) {
            const buffer = buffers[i2];
            bufferSystem.bind(buffer), incRefCount && buffer._glBuffers[CONTEXT_UID].refCount++;
          }
          return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[signature] = vao, gl.bindVertexArray(null), bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER), vao;
        }
        disposeGeometry(geometry, contextLost) {
          if (!this.managedGeometries[geometry.id])
            return;
          delete this.managedGeometries[geometry.id];
          const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;
          if (geometry.disposeRunner.remove(this), !!vaos) {
            if (bufferSystem)
              for (let i2 = 0; i2 < buffers.length; i2++) {
                const buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
                buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffers[i2], contextLost));
              }
            if (!contextLost) {
              for (const vaoId in vaos)
                if (vaoId[0] === "g") {
                  const vao = vaos[vaoId];
                  this._activeVao === vao && this.unbind(), gl.deleteVertexArray(vao);
                }
            }
            delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
          }
        }
        disposeAll(contextLost) {
          const all = Object.keys(this.managedGeometries);
          for (let i2 = 0; i2 < all.length; i2++)
            this.disposeGeometry(this.managedGeometries[all[i2]], contextLost);
        }
        activateVao(geometry, program) {
          const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;
          geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2], buffer = buffers[attribute.buffer], glBuffer = buffer._glBuffers[CONTEXT_UID];
            if (program.attributeData[j2]) {
              lastBuffer !== glBuffer && (bufferSystem.bind(buffer), lastBuffer = glBuffer);
              const location = program.attributeData[j2].location;
              if (gl.enableVertexAttribArray(location), gl.vertexAttribPointer(
                location,
                attribute.size,
                attribute.type || gl.FLOAT,
                attribute.normalized,
                attribute.stride,
                attribute.start
              ), attribute.instance)
                if (this.hasInstance)
                  gl.vertexAttribDivisor(location, attribute.divisor);
                else
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
            }
          }
        }
        draw(type, size, start, instanceCount) {
          const { gl } = this, geometry = this._activeGeometry;
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn("unsupported index buffer type: uint32");
          } else
            geometry.instanced ? gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type, start, size || geometry.getSize());
          return this;
        }
        unbind() {
          this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
        }
        destroy() {
          this.renderer = null;
        }
      };
      GeometrySystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "geometry"
      };
      extensions.add(GeometrySystem);
    }
  });

  // node_modules/@pixi/core/lib/textures/TextureMatrix.mjs
  var tempMat, TextureMatrix;
  var init_TextureMatrix = __esm({
    "node_modules/@pixi/core/lib/textures/TextureMatrix.mjs"() {
      init_lib7();
      tempMat = new Matrix();
      TextureMatrix = class {
        constructor(texture, clampMargin) {
          this._texture = texture, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof clampMargin > "u" ? 0.5 : clampMargin, this.isSimple = false;
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          this._texture = value, this._textureID = -1;
        }
        multiplyUvs(uvs, out2) {
          out2 === void 0 && (out2 = uvs);
          const mat = this.mapCoord;
          for (let i2 = 0; i2 < uvs.length; i2 += 2) {
            const x2 = uvs[i2], y2 = uvs[i2 + 1];
            out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx, out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        update(forceUpdate) {
          const tex = this._texture;
          if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID)
            return false;
          this._textureID = tex._updateID, this._updateID++;
          const uvs = tex._uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.orig, trim = tex.trim;
          trim && (tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          ), this.mapCoord.append(tempMat));
          const texBase = tex.baseTexture, frame = this.uClampFrame, margin = this.clampMargin / texBase.resolution, offset = this.clampOffset;
          return frame[0] = (tex._frame.x + margin + offset) / texBase.width, frame[1] = (tex._frame.y + margin + offset) / texBase.height, frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width, frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height, this.uClampOffset[0] = offset / texBase.realWidth, this.uClampOffset[1] = offset / texBase.realHeight, this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0, true;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.mjs
  var fragment;
  var init_spriteMaskFilter_frag = __esm({
    "node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.frag.mjs"() {
      fragment = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`;
    }
  });

  // node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.mjs
  var vertex;
  var init_spriteMaskFilter_vert = __esm({
    "node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter.vert.mjs"() {
      vertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
    }
  });

  // node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs
  var SpriteMaskFilter;
  var init_SpriteMaskFilter = __esm({
    "node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs"() {
      init_lib7();
      init_TextureMatrix();
      init_Filter();
      init_spriteMaskFilter_frag();
      init_spriteMaskFilter_vert();
      SpriteMaskFilter = class extends Filter {
        constructor(vertexSrc, fragmentSrc, uniforms) {
          let sprite = null;
          typeof vertexSrc != "string" && fragmentSrc === void 0 && uniforms === void 0 && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0), super(vertexSrc || vertex, fragmentSrc || fragment, uniforms), this.maskSprite = sprite, this.maskMatrix = new Matrix();
        }
        get maskSprite() {
          return this._maskSprite;
        }
        set maskSprite(value) {
          this._maskSprite = value, this._maskSprite && (this._maskSprite.renderable = false);
        }
        apply(filterManager, input, output, clearMode) {
          const maskSprite = this._maskSprite, tex = maskSprite._texture;
          tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/mask/MaskData.mjs
  var MaskData;
  var init_MaskData = __esm({
    "node_modules/@pixi/core/lib/mask/MaskData.mjs"() {
      init_lib();
      init_Filter();
      MaskData = class {
        constructor(maskObject = null) {
          this.type = MASK_TYPES.NONE, this.autoDetect = true, this.maskObject = maskObject || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = Filter.defaultMultisample, this.enabled = true, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
        }
        get filter() {
          return this._filters ? this._filters[0] : null;
        }
        set filter(value) {
          value ? this._filters ? this._filters[0] = value : this._filters = [value] : this._filters = null;
        }
        reset() {
          this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
        }
        copyCountersOrReset(maskAbove) {
          maskAbove ? (this._stencilCounter = maskAbove._stencilCounter, this._scissorCounter = maskAbove._scissorCounter, this._scissorRect = maskAbove._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/mask/MaskSystem.mjs
  var MaskSystem;
  var init_MaskSystem = __esm({
    "node_modules/@pixi/core/lib/mask/MaskSystem.mjs"() {
      init_lib();
      init_lib5();
      init_SpriteMaskFilter();
      init_MaskData();
      MaskSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
        }
        setMaskStack(maskStack) {
          this.maskStack = maskStack, this.renderer.scissor.setMaskStack(maskStack), this.renderer.stencil.setMaskStack(maskStack);
        }
        push(target, maskDataOrTarget) {
          let maskData = maskDataOrTarget;
          if (!maskData.isMaskData) {
            const d2 = this.maskDataPool.pop() || new MaskData();
            d2.pooled = true, d2.maskObject = maskDataOrTarget, maskData = d2;
          }
          const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
          if (maskData.copyCountersOrReset(maskAbove), maskData._colorMask = maskAbove ? maskAbove._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled)
            switch (maskData.type) {
              case MASK_TYPES.SCISSOR:
                this.renderer.scissor.push(maskData);
                break;
              case MASK_TYPES.STENCIL:
                this.renderer.stencil.push(maskData);
                break;
              case MASK_TYPES.SPRITE:
                maskData.copyCountersOrReset(null), this.pushSpriteMask(maskData);
                break;
              case MASK_TYPES.COLOR:
                this.pushColorMask(maskData);
                break;
              default:
                break;
            }
          maskData.type === MASK_TYPES.SPRITE && this.maskStack.push(maskData);
        }
        pop(target) {
          const maskData = this.maskStack.pop();
          if (!(!maskData || maskData._target !== target)) {
            if (maskData.enabled)
              switch (maskData.type) {
                case MASK_TYPES.SCISSOR:
                  this.renderer.scissor.pop(maskData);
                  break;
                case MASK_TYPES.STENCIL:
                  this.renderer.stencil.pop(maskData.maskObject);
                  break;
                case MASK_TYPES.SPRITE:
                  this.popSpriteMask(maskData);
                  break;
                case MASK_TYPES.COLOR:
                  this.popColorMask(maskData);
                  break;
                default:
                  break;
              }
            if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), this.maskStack.length !== 0) {
              const maskCurrent = this.maskStack[this.maskStack.length - 1];
              maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters && (maskCurrent._filters[0].maskSprite = maskCurrent.maskObject);
            }
          }
        }
        detect(maskData) {
          const maskObject = maskData.maskObject;
          maskObject ? maskObject.isSprite ? maskData.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = MASK_TYPES.SCISSOR : maskData.type = MASK_TYPES.STENCIL : maskData.type = MASK_TYPES.COLOR;
        }
        pushSpriteMask(maskData) {
          const { maskObject } = maskData, target = maskData._target;
          let alphaMaskFilter = maskData._filters;
          alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()])), alphaMaskFilter[0].resolution = maskData.resolution, alphaMaskFilter[0].multisample = maskData.multisample, alphaMaskFilter[0].maskSprite = maskObject;
          const stashFilterArea = target.filterArea;
          target.filterArea = maskObject.getBounds(true), this.renderer.filter.push(target, alphaMaskFilter), target.filterArea = stashFilterArea, maskData._filters || this.alphaMaskIndex++;
        }
        popSpriteMask(maskData) {
          this.renderer.filter.pop(), maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
        }
        pushColorMask(maskData) {
          const currColorMask = maskData._colorMask, nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
          nextColorMask !== currColorMask && this.renderer.gl.colorMask(
            (nextColorMask & 1) !== 0,
            (nextColorMask & 2) !== 0,
            (nextColorMask & 4) !== 0,
            (nextColorMask & 8) !== 0
          );
        }
        popColorMask(maskData) {
          const currColorMask = maskData._colorMask, nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
          nextColorMask !== currColorMask && this.renderer.gl.colorMask(
            (nextColorMask & 1) !== 0,
            (nextColorMask & 2) !== 0,
            (nextColorMask & 4) !== 0,
            (nextColorMask & 8) !== 0
          );
        }
        destroy() {
          this.renderer = null;
        }
      };
      MaskSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "mask"
      };
      extensions.add(MaskSystem);
    }
  });

  // node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs
  var AbstractMaskSystem;
  var init_AbstractMaskSystem = __esm({
    "node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs"() {
      AbstractMaskSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.maskStack = [], this.glConst = 0;
        }
        getStackLength() {
          return this.maskStack.length;
        }
        setMaskStack(maskStack) {
          const { gl } = this.renderer, curStackLen = this.getStackLength();
          this.maskStack = maskStack;
          const newStackLen = this.getStackLength();
          newStackLen !== curStackLen && (newStackLen === 0 ? gl.disable(this.glConst) : (gl.enable(this.glConst), this._useCurrent()));
        }
        _useCurrent() {
        }
        destroy() {
          this.renderer = null, this.maskStack = null;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/mask/ScissorSystem.mjs
  var tempMatrix2, rectPool, _ScissorSystem, ScissorSystem;
  var init_ScissorSystem = __esm({
    "node_modules/@pixi/core/lib/mask/ScissorSystem.mjs"() {
      init_lib5();
      init_lib7();
      init_lib2();
      init_AbstractMaskSystem();
      tempMatrix2 = new Matrix();
      rectPool = [];
      _ScissorSystem = class _ScissorSystem2 extends AbstractMaskSystem {
        constructor(renderer) {
          super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
        }
        getStackLength() {
          const maskData = this.maskStack[this.maskStack.length - 1];
          return maskData ? maskData._scissorCounter : 0;
        }
        calcScissorRect(maskData) {
          if (maskData._scissorRectLocal)
            return;
          const prevData = maskData._scissorRect, { maskObject } = maskData, { renderer } = this, renderTextureSystem = renderer.renderTexture, rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());
          this.roundFrameToPixels(
            rect,
            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,
            renderTextureSystem.sourceFrame,
            renderTextureSystem.destinationFrame,
            renderer.projection.transform
          ), prevData && rect.fit(prevData), maskData._scissorRectLocal = rect;
        }
        static isMatrixRotated(matrix) {
          if (!matrix)
            return false;
          const { a: a2, b: b2, c: c2, d: d2 } = matrix;
          return (Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4);
        }
        testScissor(maskData) {
          const { maskObject } = maskData;
          if (!maskObject.isFastRect || !maskObject.isFastRect() || _ScissorSystem2.isMatrixRotated(maskObject.worldTransform) || _ScissorSystem2.isMatrixRotated(this.renderer.projection.transform))
            return false;
          this.calcScissorRect(maskData);
          const rect = maskData._scissorRectLocal;
          return rect.width > 0 && rect.height > 0;
        }
        roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform2) {
          _ScissorSystem2.isMatrixRotated(transform2) || (transform2 = transform2 ? tempMatrix2.copyFrom(transform2) : tempMatrix2.identity(), transform2.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(
            bindingDestinationFrame.width / bindingSourceFrame.width,
            bindingDestinationFrame.height / bindingSourceFrame.height
          ).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform2, frame), frame.fit(bindingDestinationFrame), frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));
        }
        push(maskData) {
          maskData._scissorRectLocal || this.calcScissorRect(maskData);
          const { gl } = this.renderer;
          maskData._scissorRect || gl.enable(gl.SCISSOR_TEST), maskData._scissorCounter++, maskData._scissorRect = maskData._scissorRectLocal, this._useCurrent();
        }
        pop(maskData) {
          const { gl } = this.renderer;
          maskData && rectPool.push(maskData._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);
        }
        _useCurrent() {
          const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
          let y2;
          this.renderer.renderTexture.current ? y2 = rect.y : y2 = this.renderer.height - rect.height - rect.y, this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
        }
      };
      _ScissorSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "scissor"
      };
      ScissorSystem = _ScissorSystem;
      extensions.add(ScissorSystem);
    }
  });

  // node_modules/@pixi/core/lib/mask/StencilSystem.mjs
  var StencilSystem;
  var init_StencilSystem = __esm({
    "node_modules/@pixi/core/lib/mask/StencilSystem.mjs"() {
      init_lib5();
      init_lib2();
      init_AbstractMaskSystem();
      StencilSystem = class extends AbstractMaskSystem {
        constructor(renderer) {
          super(renderer), this.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
        }
        getStackLength() {
          const maskData = this.maskStack[this.maskStack.length - 1];
          return maskData ? maskData._stencilCounter : 0;
        }
        push(maskData) {
          const maskObject = maskData.maskObject, { gl } = this.renderer, prevMaskCount = maskData._stencilCounter;
          prevMaskCount === 0 && (this.renderer.framebuffer.forceStencil(), gl.clearStencil(0), gl.clear(gl.STENCIL_BUFFER_BIT), gl.enable(gl.STENCIL_TEST)), maskData._stencilCounter++;
          const colorMask = maskData._colorMask;
          colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(false, false, false, false)), gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR), maskObject.renderable = true, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = false, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(
            (colorMask & 1) !== 0,
            (colorMask & 2) !== 0,
            (colorMask & 4) !== 0,
            (colorMask & 8) !== 0
          )), this._useCurrent();
        }
        pop(maskObject) {
          const gl = this.renderer.gl;
          if (this.getStackLength() === 0)
            gl.disable(gl.STENCIL_TEST);
          else {
            const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, colorMask = maskData ? maskData._colorMask : 15;
            colorMask !== 0 && (maskData._colorMask = 0, gl.colorMask(false, false, false, false)), gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR), maskObject.renderable = true, maskObject.render(this.renderer), this.renderer.batch.flush(), maskObject.renderable = false, colorMask !== 0 && (maskData._colorMask = colorMask, gl.colorMask(
              (colorMask & 1) !== 0,
              (colorMask & 2) !== 0,
              (colorMask & 4) !== 0,
              (colorMask & 8) !== 0
            )), this._useCurrent();
          }
        }
        _useCurrent() {
          const gl = this.renderer.gl;
          gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
      };
      StencilSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "stencil"
      };
      extensions.add(StencilSystem);
    }
  });

  // node_modules/@pixi/core/lib/plugin/PluginSystem.mjs
  var PluginSystem;
  var init_PluginSystem = __esm({
    "node_modules/@pixi/core/lib/plugin/PluginSystem.mjs"() {
      init_lib5();
      init_lib4();
      PluginSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.plugins = {}, Object.defineProperties(this.plugins, {
            extract: {
              enumerable: false,
              get() {
                return deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), renderer.extract;
              }
            },
            prepare: {
              enumerable: false,
              get() {
                return deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), renderer.prepare;
              }
            },
            interaction: {
              enumerable: false,
              get() {
                return deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), renderer.events;
              }
            }
          });
        }
        init() {
          const staticMap = this.rendererPlugins;
          for (const o2 in staticMap)
            this.plugins[o2] = new staticMap[o2](this.renderer);
        }
        destroy() {
          for (const o2 in this.plugins)
            this.plugins[o2].destroy(), this.plugins[o2] = null;
        }
      };
      PluginSystem.extension = {
        type: [
          ExtensionType.RendererSystem,
          ExtensionType.CanvasRendererSystem
        ],
        name: "_plugin"
      };
      extensions.add(PluginSystem);
    }
  });

  // node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs
  var ProjectionSystem;
  var init_ProjectionSystem = __esm({
    "node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs"() {
      init_lib5();
      init_lib7();
      ProjectionSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;
        }
        update(destinationFrame, sourceFrame, resolution, root) {
          this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame, this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame, this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root), this.transform && this.projectionMatrix.append(this.transform);
          const renderer = this.renderer;
          renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, renderer.globalUniforms.update(), renderer.shader.shader && renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
        calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
          const pm = this.projectionMatrix, sign2 = root ? -1 : 1;
          pm.identity(), pm.a = 1 / sourceFrame.width * 2, pm.d = sign2 * (1 / sourceFrame.height * 2), pm.tx = -1 - sourceFrame.x * pm.a, pm.ty = -sign2 - sourceFrame.y * pm.d;
        }
        setTransform(_matrix) {
        }
        destroy() {
          this.renderer = null;
        }
      };
      ProjectionSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "projection"
      };
      extensions.add(ProjectionSystem);
    }
  });

  // node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs
  var tempTransform, tempRect, GenerateTextureSystem;
  var init_GenerateTextureSystem = __esm({
    "node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs"() {
      init_lib5();
      init_lib7();
      init_RenderTexture();
      tempTransform = new Transform();
      tempRect = new Rectangle();
      GenerateTextureSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this._tempMatrix = new Matrix();
        }
        generateTexture(displayObject, options) {
          const { region: manualRegion, ...textureOptions } = options || {}, region = manualRegion?.copyTo(tempRect) || displayObject.getLocalBounds(tempRect, true), resolution = textureOptions.resolution || this.renderer.resolution;
          region.width = Math.max(region.width, 1 / resolution), region.height = Math.max(region.height, 1 / resolution), textureOptions.width = region.width, textureOptions.height = region.height, textureOptions.resolution = resolution, textureOptions.multisample ?? (textureOptions.multisample = this.renderer.multisample);
          const renderTexture = RenderTexture.create(textureOptions);
          this._tempMatrix.tx = -region.x, this._tempMatrix.ty = -region.y;
          const transform2 = displayObject.transform;
          return displayObject.transform = tempTransform, this.renderer.render(displayObject, {
            renderTexture,
            transform: this._tempMatrix,
            skipUpdateTransform: !!displayObject.parent,
            blit: true
          }), displayObject.transform = transform2, renderTexture;
        }
        destroy() {
        }
      };
      GenerateTextureSystem.extension = {
        type: [
          ExtensionType.RendererSystem,
          ExtensionType.CanvasRendererSystem
        ],
        name: "textureGenerator"
      };
      extensions.add(GenerateTextureSystem);
    }
  });

  // node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs
  var tempRect2, tempRect22, RenderTextureSystem;
  var init_RenderTextureSystem = __esm({
    "node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs"() {
      init_lib3();
      init_lib5();
      init_lib7();
      tempRect2 = new Rectangle();
      tempRect22 = new Rectangle();
      RenderTextureSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();
        }
        contextChange() {
          const attributes = this.renderer?.gl.getContextAttributes();
          this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
        }
        bind(renderTexture = null, sourceFrame, destinationFrame) {
          const renderer = this.renderer;
          this.current = renderTexture;
          let baseTexture, framebuffer, resolution;
          renderTexture ? (baseTexture = renderTexture.baseTexture, resolution = baseTexture.resolution, sourceFrame || (tempRect2.width = renderTexture.frame.width, tempRect2.height = renderTexture.frame.height, sourceFrame = tempRect2), destinationFrame || (tempRect22.x = renderTexture.frame.x, tempRect22.y = renderTexture.frame.y, tempRect22.width = sourceFrame.width, tempRect22.height = sourceFrame.height, destinationFrame = tempRect22), framebuffer = baseTexture.framebuffer) : (resolution = renderer.resolution, sourceFrame || (tempRect2.width = renderer._view.screen.width, tempRect2.height = renderer._view.screen.height, sourceFrame = tempRect2), destinationFrame || (destinationFrame = tempRect2, destinationFrame.width = sourceFrame.width, destinationFrame.height = sourceFrame.height));
          const viewportFrame = this.viewportFrame;
          viewportFrame.x = destinationFrame.x * resolution, viewportFrame.y = destinationFrame.y * resolution, viewportFrame.width = destinationFrame.width * resolution, viewportFrame.height = destinationFrame.height * resolution, renderTexture || (viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height)), viewportFrame.ceil(), this.renderer.framebuffer.bind(framebuffer, viewportFrame), this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer), renderTexture ? this.renderer.mask.setMaskStack(baseTexture.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(sourceFrame), this.destinationFrame.copyFrom(destinationFrame);
        }
        clear(clearColor, mask) {
          const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor, color = Color.shared.setValue(clearColor || fallbackColor);
          (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && color.premultiply(color.alpha);
          const destinationFrame = this.destinationFrame, baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen, clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
          if (clearMask) {
            let { x: x2, y: y2, width, height } = this.viewportFrame;
            x2 = Math.round(x2), y2 = Math.round(y2), width = Math.round(width), height = Math.round(height), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(x2, y2, width, height);
          }
          this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask), clearMask && this.renderer.scissor.pop();
        }
        resize() {
          this.bind(null);
        }
        reset() {
          this.bind(null);
        }
        destroy() {
          this.renderer = null;
        }
      };
      RenderTextureSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "renderTexture"
      };
      extensions.add(RenderTextureSystem);
    }
  });

  // node_modules/@pixi/core/lib/shader/GLProgram.mjs
  var GLProgram;
  var init_GLProgram = __esm({
    "node_modules/@pixi/core/lib/shader/GLProgram.mjs"() {
      GLProgram = class {
        constructor(program, uniformData) {
          this.program = program, this.uniformData = uniformData, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
        }
        destroy() {
          this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs
  function getAttributeData(program, gl) {
    const attributes = {}, totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i2 = 0; i2 < totalAttributes; i2++) {
      const attribData = gl.getActiveAttrib(program, i2);
      if (attribData.name.startsWith("gl_"))
        continue;
      const type = mapType(gl, attribData.type), data = {
        type,
        name: attribData.name,
        size: mapSize(type),
        location: gl.getAttribLocation(program, attribData.name)
      };
      attributes[attribData.name] = data;
    }
    return attributes;
  }
  var init_getAttributeData = __esm({
    "node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs"() {
      init_mapSize();
      init_mapType();
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs
  function getUniformData(program, gl) {
    const uniforms = {}, totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < totalUniforms; i2++) {
      const uniformData = gl.getActiveUniform(program, i2), name = uniformData.name.replace(/\[.*?\]$/, ""), isArray = !!uniformData.name.match(/\[.*?\]$/), type = mapType(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i2,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData = __esm({
    "node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs"() {
      init_defaultValue();
      init_mapType();
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs
  function generateProgram(gl, program) {
    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc), webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader), gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
    if (transformFeedbackVaryings && (typeof gl.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl.transformFeedbackVaryings(
      webGLProgram,
      transformFeedbackVaryings.names,
      transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
    )), gl.linkProgram(webGLProgram), gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError(gl, webGLProgram, glVertShader, glFragShader), program.attributeData = getAttributeData(webGLProgram, gl), program.uniformData = getUniformData(webGLProgram, gl), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
      const keys = Object.keys(program.attributeData);
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i2 = 0; i2 < keys.length; i2++)
        program.attributeData[keys[i2]].location = i2, gl.bindAttribLocation(webGLProgram, i2, keys[i2]);
      gl.linkProgram(webGLProgram);
    }
    gl.deleteShader(glVertShader), gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i2 in program.uniformData) {
      const data = program.uniformData[i2];
      uniformData[i2] = {
        location: gl.getUniformLocation(webGLProgram, i2),
        value: defaultValue(data.type, data.size)
      };
    }
    return new GLProgram(webGLProgram, uniformData);
  }
  var init_generateProgram = __esm({
    "node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs"() {
      init_GLProgram();
      init_compileShader();
      init_defaultValue();
      init_getAttributeData();
      init_getUniformData();
      init_logProgramError();
    }
  });

  // node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs
  function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
    _renderer.buffer.update(buffer);
  }
  function createUBOElements(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    }));
    let size = 0, chunkSize = 0, offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      if (size = GLSL_TO_STD40_SIZE[uboElement.data.type], uboElement.data.size > 1 && (size = Math.max(size, 16) * uboElement.data.size), uboElement.dataLen = size, chunkSize % size !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue, offset += lineUpValue;
      }
      chunkSize + size > 16 ? (offset = Math.ceil(offset / 16) * 16, uboElement.offset = offset, offset += size, chunkSize = size) : (uboElement.offset = offset, chunkSize += size, offset += size);
    }
    return offset = Math.ceil(offset / 16) * 16, { uboElements, size: offset };
  }
  function getUBOData(uniforms, uniformData) {
    const usedUniformDatas = [];
    for (const i2 in uniforms)
      uniformData[i2] && usedUniformDatas.push(uniformData[i2]);
    return usedUniformDatas.sort((a2, b2) => a2.index - b2.index), usedUniformDatas;
  }
  function generateUniformBufferSync(group, uniformData) {
    if (!group.autoManage)
      return { size: 0, syncFunc: uboUpdate };
    const usedUniformDatas = getUBOData(group.uniforms, uniformData), { uboElements, size } = createUBOElements(usedUniformDatas), funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2], uniform = group.uniforms[uboElement.data.name], name = uboElement.data.name;
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers.length; j2++) {
        const uniformParser = uniformParsers[j2];
        if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
          funcFragments.push(
            `offset = ${uboElement.offset / 4};`,
            uniformParsers[j2].codeUbo(uboElement.data.name, uniform)
          ), parsed = true;
          break;
        }
      }
      if (!parsed)
        if (uboElement.data.size > 1) {
          const size2 = mapSize(uboElement.data.type), rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), elementSize = size2 / rowSize, remainder = (4 - elementSize % 4) % 4;
          funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
        } else {
          const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
          funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
        }
    }
    return funcFragments.push(`
       renderer.buffer.update(buffer);
    `), {
      size,
      syncFunc: new Function(
        "ud",
        "uv",
        "renderer",
        "syncData",
        "buffer",
        funcFragments.join(`
`)
      )
    };
  }
  var UBO_TO_SINGLE_SETTERS, GLSL_TO_STD40_SIZE;
  var init_generateUniformBufferSync = __esm({
    "node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs"() {
      init_utils();
      init_uniformParsers();
      init_mapSize();
      UBO_TO_SINGLE_SETTERS = {
        float: `
        data[offset] = v;
    `,
        vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
        vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
        vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
        mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
        mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
        mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
      };
      GLSL_TO_STD40_SIZE = {
        float: 4,
        vec2: 8,
        vec3: 12,
        vec4: 16,
        int: 4,
        ivec2: 8,
        ivec3: 12,
        ivec4: 16,
        uint: 4,
        uvec2: 8,
        uvec3: 12,
        uvec4: 16,
        bool: 4,
        bvec2: 8,
        bvec3: 12,
        bvec4: 16,
        mat2: 16 * 2,
        mat3: 16 * 3,
        mat4: 16 * 4
      };
    }
  });

  // node_modules/@pixi/core/lib/shader/ShaderSystem.mjs
  var UID5, defaultSyncData, ShaderSystem;
  var init_ShaderSystem = __esm({
    "node_modules/@pixi/core/lib/shader/ShaderSystem.mjs"() {
      init_lib5();
      init_utils();
      init_generateProgram();
      init_generateUniformBufferSync();
      init_unsafeEvalSupported();
      init_generateUniformsSync();
      UID5 = 0;
      defaultSyncData = { textureCount: 0, uboCount: 0 };
      ShaderSystem = class {
        constructor(renderer) {
          this.destroyed = false, this.renderer = renderer, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID5++;
        }
        systemCheck() {
          if (!unsafeEvalSupported())
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
        contextChange(gl) {
          this.gl = gl, this.reset();
        }
        bind(shader, dontSync) {
          shader.disposeRunner.add(this), shader.uniforms.globals = this.renderer.globalUniforms;
          const program = shader.program, glProgram3 = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
          return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram3.program)), dontSync || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData)), glProgram3;
        }
        setUniforms(uniforms) {
          const shader = this.shader.program, glProgram3 = shader.glPrograms[this.renderer.CONTEXT_UID];
          shader.syncUniforms(glProgram3.uniformData, uniforms, this.renderer);
        }
        syncUniformGroup(group, syncData) {
          const glProgram3 = this.getGlProgram();
          (!group.static || group.dirtyId !== glProgram3.uniformDirtyGroups[group.id]) && (glProgram3.uniformDirtyGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram3, syncData));
        }
        syncUniforms(group, glProgram3, syncData) {
          (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram3.uniformData, group.uniforms, this.renderer, syncData);
        }
        createSyncGroups(group) {
          const id = this.getSignature(group, this.shader.program.uniformData, "u");
          return this.cache[id] || (this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData)), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id];
        }
        syncUniformBufferGroup(group, name) {
          const glProgram3 = this.getGlProgram();
          if (!group.static || group.dirtyId !== 0 || !glProgram3.uniformGroups[group.id]) {
            group.dirtyId = 0;
            const syncFunc = glProgram3.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram3, name);
            group.buffer.update(), syncFunc(
              glProgram3.uniformData,
              group.uniforms,
              this.renderer,
              defaultSyncData,
              group.buffer
            );
          }
          this.renderer.buffer.bindBufferBase(group.buffer, glProgram3.uniformBufferBindings[name]);
        }
        createSyncBufferGroup(group, glProgram3, name) {
          const { gl } = this.renderer;
          this.renderer.buffer.bind(group.buffer);
          const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram3.program, name);
          glProgram3.uniformBufferBindings[name] = this.shader.uniformBindCount, gl.uniformBlockBinding(glProgram3.program, uniformBlockIndex, this.shader.uniformBindCount), this.shader.uniformBindCount++;
          const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
          let uboData = this._uboCache[id];
          if (uboData || (uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData)), group.autoManage) {
            const data = new Float32Array(uboData.size / 4);
            group.buffer.update(data);
          }
          return glProgram3.uniformGroups[group.id] = uboData.syncFunc, glProgram3.uniformGroups[group.id];
        }
        getSignature(group, uniformData, preFix) {
          const uniforms = group.uniforms, strings = [`${preFix}-`];
          for (const i2 in uniforms)
            strings.push(i2), uniformData[i2] && strings.push(uniformData[i2].type);
          return strings.join("-");
        }
        getGlProgram() {
          return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
        }
        generateProgram(shader) {
          const gl = this.gl, program = shader.program, glProgram3 = generateProgram(gl, program);
          return program.glPrograms[this.renderer.CONTEXT_UID] = glProgram3, glProgram3;
        }
        reset() {
          this.program = null, this.shader = null;
        }
        disposeShader(shader) {
          this.shader === shader && (this.shader = null);
        }
        destroy() {
          this.renderer = null, this.destroyed = true;
        }
      };
      ShaderSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "shader"
      };
      extensions.add(ShaderSystem);
    }
  });

  // node_modules/@pixi/core/lib/startup/StartupSystem.mjs
  var StartupSystem;
  var init_StartupSystem = __esm({
    "node_modules/@pixi/core/lib/startup/StartupSystem.mjs"() {
      init_lib5();
      StartupSystem = class {
        constructor(renderer) {
          this.renderer = renderer;
        }
        run(options) {
          const { renderer } = this;
          renderer.runners.init.emit(renderer.options), options.hello && console.log(`PixiJS 7.3.1 - ${renderer.rendererLogId} - https://pixijs.com`), renderer.resize(renderer.screen.width, renderer.screen.height);
        }
        destroy() {
        }
      };
      StartupSystem.defaultOptions = {
        hello: false
      }, StartupSystem.extension = {
        type: [
          ExtensionType.RendererSystem,
          ExtensionType.CanvasRendererSystem
        ],
        name: "startup"
      };
      extensions.add(StartupSystem);
    }
  });

  // node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi(gl, array = []) {
    return array[BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD] = [gl.ONE, gl.ONE], array[BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.NONE] = [0, 0], array[BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE], array[BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO], array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO], array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE], array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA], array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA], array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA], array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD], array;
  }
  var init_mapWebGLBlendModesToPixi = __esm({
    "node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs"() {
      init_lib();
    }
  });

  // node_modules/@pixi/core/lib/state/StateSystem.mjs
  var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _StateSystem, StateSystem;
  var init_StateSystem = __esm({
    "node_modules/@pixi/core/lib/state/StateSystem.mjs"() {
      init_lib();
      init_lib5();
      init_State();
      init_mapWebGLBlendModesToPixi();
      BLEND2 = 0;
      OFFSET2 = 1;
      CULLING2 = 2;
      DEPTH_TEST2 = 3;
      WINDING2 = 4;
      DEPTH_MASK2 = 5;
      _StateSystem = class _StateSystem2 {
        constructor() {
          this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = false, this.map = [], this.map[BLEND2] = this.setBlend, this.map[OFFSET2] = this.setOffset, this.map[CULLING2] = this.setCullFace, this.map[DEPTH_TEST2] = this.setDepthTest, this.map[WINDING2] = this.setFrontFace, this.map[DEPTH_MASK2] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = true;
        }
        contextChange(gl) {
          this.gl = gl, this.blendModes = mapWebGLBlendModesToPixi(gl), this.set(this.defaultState), this.reset();
        }
        set(state) {
          if (state = state || this.defaultState, this.stateId !== state.data) {
            let diff = this.stateId ^ state.data, i2 = 0;
            for (; diff; )
              diff & 1 && this.map[i2].call(this, !!(state.data & 1 << i2)), diff = diff >> 1, i2++;
            this.stateId = state.data;
          }
          for (let i2 = 0; i2 < this.checks.length; i2++)
            this.checks[i2](this, state);
        }
        forceState(state) {
          state = state || this.defaultState;
          for (let i2 = 0; i2 < this.map.length; i2++)
            this.map[i2].call(this, !!(state.data & 1 << i2));
          for (let i2 = 0; i2 < this.checks.length; i2++)
            this.checks[i2](this, state);
          this.stateId = state.data;
        }
        setBlend(value) {
          this.updateCheck(_StateSystem2.checkBlendMode, value), this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        }
        setOffset(value) {
          this.updateCheck(_StateSystem2.checkPolygonOffset, value), this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(value) {
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        setDepthMask(value) {
          this.gl.depthMask(value);
        }
        setCullFace(value) {
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        }
        setFrontFace(value) {
          this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
        }
        setBlendMode(value) {
          if (value === this.blendMode)
            return;
          this.blendMode = value;
          const mode = this.blendModes[value], gl = this.gl;
          mode.length === 2 ? gl.blendFunc(mode[0], mode[1]) : gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]), mode.length === 6 ? (this._blendEq = true, gl.blendEquationSeparate(mode[4], mode[5])) : this._blendEq && (this._blendEq = false, gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD));
        }
        setPolygonOffset(value, scale) {
          this.gl.polygonOffset(value, scale);
        }
        reset() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
        }
        updateCheck(func, value) {
          const index = this.checks.indexOf(func);
          value && index === -1 ? this.checks.push(func) : !value && index !== -1 && this.checks.splice(index, 1);
        }
        static checkBlendMode(system, state) {
          system.setBlendMode(state.blendMode);
        }
        static checkPolygonOffset(system, state) {
          system.setPolygonOffset(1, state.polygonOffset);
        }
        destroy() {
          this.gl = null;
        }
      };
      _StateSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "state"
      };
      StateSystem = _StateSystem;
      extensions.add(StateSystem);
    }
  });

  // node_modules/@pixi/core/lib/system/SystemManager.mjs
  var SystemManager;
  var init_SystemManager = __esm({
    "node_modules/@pixi/core/lib/system/SystemManager.mjs"() {
      init_lib6();
      init_lib4();
      SystemManager = class extends import_eventemitter3.default {
        constructor() {
          super(...arguments), this.runners = {}, this._systemsHash = {};
        }
        setup(config) {
          this.addRunners(...config.runners);
          const priority = (config.priority ?? []).filter((key) => config.systems[key]), orderByPriority = [
            ...priority,
            ...Object.keys(config.systems).filter((key) => !priority.includes(key))
          ];
          for (const i2 of orderByPriority)
            this.addSystem(config.systems[i2], i2);
        }
        addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new Runner(runnerId);
          });
        }
        addSystem(ClassRef, name) {
          const system = new ClassRef(this);
          if (this[name])
            throw new Error(`Whoops! The name "${name}" is already in use`);
          this[name] = system, this._systemsHash[name] = system;
          for (const i2 in this.runners)
            this.runners[i2].add(system);
          return this;
        }
        emitWithCustomOptions(runner, options) {
          const systemHashKeys = Object.keys(this._systemsHash);
          runner.items.forEach((system) => {
            const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
            system[runner.name](options[systemName]);
          });
        }
        destroy() {
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          }), this._systemsHash = {};
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs
  var _TextureGCSystem, TextureGCSystem;
  var init_TextureGCSystem = __esm({
    "node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs"() {
      init_lib();
      init_lib5();
      _TextureGCSystem = class _TextureGCSystem2 {
        constructor(renderer) {
          this.renderer = renderer, this.count = 0, this.checkCount = 0, this.maxIdle = _TextureGCSystem2.defaultMaxIdle, this.checkCountMax = _TextureGCSystem2.defaultCheckCountMax, this.mode = _TextureGCSystem2.defaultMode;
        }
        postrender() {
          this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
        }
        run() {
          const tm = this.renderer.texture, managedTextures = tm.managedTextures;
          let wasRemoved = false;
          for (let i2 = 0; i2 < managedTextures.length; i2++) {
            const texture = managedTextures[i2];
            texture.resource && this.count - texture.touched > this.maxIdle && (tm.destroyTexture(texture, true), managedTextures[i2] = null, wasRemoved = true);
          }
          if (wasRemoved) {
            let j2 = 0;
            for (let i2 = 0; i2 < managedTextures.length; i2++)
              managedTextures[i2] !== null && (managedTextures[j2++] = managedTextures[i2]);
            managedTextures.length = j2;
          }
        }
        unload(displayObject) {
          const tm = this.renderer.texture, texture = displayObject._texture;
          texture && !texture.framebuffer && tm.destroyTexture(texture);
          for (let i2 = displayObject.children.length - 1; i2 >= 0; i2--)
            this.unload(displayObject.children[i2]);
        }
        destroy() {
          this.renderer = null;
        }
      };
      _TextureGCSystem.defaultMode = GC_MODES.AUTO, _TextureGCSystem.defaultMaxIdle = 60 * 60, _TextureGCSystem.defaultCheckCountMax = 60 * 10, _TextureGCSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "textureGC"
      };
      TextureGCSystem = _TextureGCSystem;
      extensions.add(TextureGCSystem);
    }
  });

  // node_modules/@pixi/core/lib/textures/GLTexture.mjs
  var GLTexture;
  var init_GLTexture = __esm({
    "node_modules/@pixi/core/lib/textures/GLTexture.mjs"() {
      init_lib();
      GLTexture = class {
        constructor(texture) {
          this.texture = texture, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.mjs
  function mapInternalFormatToSamplerType(gl) {
    let table;
    return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {
      [gl.RGB]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA]: SAMPLER_TYPES.FLOAT,
      [gl.ALPHA]: SAMPLER_TYPES.FLOAT,
      [gl.LUMINANCE]: SAMPLER_TYPES.FLOAT,
      [gl.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,
      [gl.R8]: SAMPLER_TYPES.FLOAT,
      [gl.R8_SNORM]: SAMPLER_TYPES.FLOAT,
      [gl.RG8]: SAMPLER_TYPES.FLOAT,
      [gl.RG8_SNORM]: SAMPLER_TYPES.FLOAT,
      [gl.RGB8]: SAMPLER_TYPES.FLOAT,
      [gl.RGB8_SNORM]: SAMPLER_TYPES.FLOAT,
      [gl.RGB565]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA4]: SAMPLER_TYPES.FLOAT,
      [gl.RGB5_A1]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA8]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA8_SNORM]: SAMPLER_TYPES.FLOAT,
      [gl.RGB10_A2]: SAMPLER_TYPES.FLOAT,
      [gl.RGB10_A2UI]: SAMPLER_TYPES.FLOAT,
      [gl.SRGB8]: SAMPLER_TYPES.FLOAT,
      [gl.SRGB8_ALPHA8]: SAMPLER_TYPES.FLOAT,
      [gl.R16F]: SAMPLER_TYPES.FLOAT,
      [gl.RG16F]: SAMPLER_TYPES.FLOAT,
      [gl.RGB16F]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA16F]: SAMPLER_TYPES.FLOAT,
      [gl.R32F]: SAMPLER_TYPES.FLOAT,
      [gl.RG32F]: SAMPLER_TYPES.FLOAT,
      [gl.RGB32F]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA32F]: SAMPLER_TYPES.FLOAT,
      [gl.R11F_G11F_B10F]: SAMPLER_TYPES.FLOAT,
      [gl.RGB9_E5]: SAMPLER_TYPES.FLOAT,
      [gl.R8I]: SAMPLER_TYPES.INT,
      [gl.R8UI]: SAMPLER_TYPES.UINT,
      [gl.R16I]: SAMPLER_TYPES.INT,
      [gl.R16UI]: SAMPLER_TYPES.UINT,
      [gl.R32I]: SAMPLER_TYPES.INT,
      [gl.R32UI]: SAMPLER_TYPES.UINT,
      [gl.RG8I]: SAMPLER_TYPES.INT,
      [gl.RG8UI]: SAMPLER_TYPES.UINT,
      [gl.RG16I]: SAMPLER_TYPES.INT,
      [gl.RG16UI]: SAMPLER_TYPES.UINT,
      [gl.RG32I]: SAMPLER_TYPES.INT,
      [gl.RG32UI]: SAMPLER_TYPES.UINT,
      [gl.RGB8I]: SAMPLER_TYPES.INT,
      [gl.RGB8UI]: SAMPLER_TYPES.UINT,
      [gl.RGB16I]: SAMPLER_TYPES.INT,
      [gl.RGB16UI]: SAMPLER_TYPES.UINT,
      [gl.RGB32I]: SAMPLER_TYPES.INT,
      [gl.RGB32UI]: SAMPLER_TYPES.UINT,
      [gl.RGBA8I]: SAMPLER_TYPES.INT,
      [gl.RGBA8UI]: SAMPLER_TYPES.UINT,
      [gl.RGBA16I]: SAMPLER_TYPES.INT,
      [gl.RGBA16UI]: SAMPLER_TYPES.UINT,
      [gl.RGBA32I]: SAMPLER_TYPES.INT,
      [gl.RGBA32UI]: SAMPLER_TYPES.UINT,
      [gl.DEPTH_COMPONENT16]: SAMPLER_TYPES.FLOAT,
      [gl.DEPTH_COMPONENT24]: SAMPLER_TYPES.FLOAT,
      [gl.DEPTH_COMPONENT32F]: SAMPLER_TYPES.FLOAT,
      [gl.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT,
      [gl.DEPTH24_STENCIL8]: SAMPLER_TYPES.FLOAT,
      [gl.DEPTH32F_STENCIL8]: SAMPLER_TYPES.FLOAT
    } : table = {
      [gl.RGB]: SAMPLER_TYPES.FLOAT,
      [gl.RGBA]: SAMPLER_TYPES.FLOAT,
      [gl.ALPHA]: SAMPLER_TYPES.FLOAT,
      [gl.LUMINANCE]: SAMPLER_TYPES.FLOAT,
      [gl.LUMINANCE_ALPHA]: SAMPLER_TYPES.FLOAT,
      [gl.DEPTH_STENCIL]: SAMPLER_TYPES.FLOAT
    }, table;
  }
  var init_mapInternalFormatToSamplerType = __esm({
    "node_modules/@pixi/core/lib/textures/utils/mapInternalFormatToSamplerType.mjs"() {
      init_lib();
    }
  });

  // node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs
  function mapTypeAndFormatToInternalFormat(gl) {
    let table;
    return "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext ? table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8,
        [FORMATS.RGB]: gl.RGB8,
        [FORMATS.RG]: gl.RG8,
        [FORMATS.RED]: gl.R8,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [FORMATS.RG_INTEGER]: gl.RG8UI,
        [FORMATS.RED_INTEGER]: gl.R8UI,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.BYTE]: {
        [FORMATS.RGBA]: gl.RGBA8_SNORM,
        [FORMATS.RGB]: gl.RGB8_SNORM,
        [FORMATS.RG]: gl.RG8_SNORM,
        [FORMATS.RED]: gl.R8_SNORM,
        [FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [FORMATS.RGB_INTEGER]: gl.RGB8I,
        [FORMATS.RG_INTEGER]: gl.RG8I,
        [FORMATS.RED_INTEGER]: gl.R8I
      },
      [TYPES.UNSIGNED_SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [FORMATS.RG_INTEGER]: gl.RG16UI,
        [FORMATS.RED_INTEGER]: gl.R16UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [TYPES.SHORT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [FORMATS.RGB_INTEGER]: gl.RGB16I,
        [FORMATS.RG_INTEGER]: gl.RG16I,
        [FORMATS.RED_INTEGER]: gl.R16I
      },
      [TYPES.UNSIGNED_INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [FORMATS.RG_INTEGER]: gl.RG32UI,
        [FORMATS.RED_INTEGER]: gl.R32UI,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [TYPES.INT]: {
        [FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [FORMATS.RGB_INTEGER]: gl.RGB32I,
        [FORMATS.RG_INTEGER]: gl.RG32I,
        [FORMATS.RED_INTEGER]: gl.R32I
      },
      [TYPES.FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA32F,
        [FORMATS.RGB]: gl.RGB32F,
        [FORMATS.RG]: gl.RG32F,
        [FORMATS.RED]: gl.R32F,
        [FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [TYPES.HALF_FLOAT]: {
        [FORMATS.RGBA]: gl.RGBA16F,
        [FORMATS.RGB]: gl.RGB16F,
        [FORMATS.RG]: gl.RG16F,
        [FORMATS.RED]: gl.R16F
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB565
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA4
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGB5_A1
      },
      [TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [FORMATS.RGBA]: gl.RGB10_A2,
        [FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [FORMATS.RGB]: gl.RGB9_E5
      },
      [TYPES.UNSIGNED_INT_24_8]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    } : table = {
      [TYPES.UNSIGNED_BYTE]: {
        [FORMATS.RGBA]: gl.RGBA,
        [FORMATS.RGB]: gl.RGB,
        [FORMATS.ALPHA]: gl.ALPHA,
        [FORMATS.LUMINANCE]: gl.LUMINANCE,
        [FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [TYPES.UNSIGNED_SHORT_5_6_5]: {
        [FORMATS.RGB]: gl.RGB
      },
      [TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [FORMATS.RGBA]: gl.RGBA
      },
      [TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [FORMATS.RGBA]: gl.RGBA
      }
    }, table;
  }
  var init_mapTypeAndFormatToInternalFormat = __esm({
    "node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs"() {
      init_lib();
    }
  });

  // node_modules/@pixi/core/lib/textures/TextureSystem.mjs
  var TextureSystem;
  var init_TextureSystem = __esm({
    "node_modules/@pixi/core/lib/textures/TextureSystem.mjs"() {
      init_lib();
      init_lib5();
      init_lib4();
      init_BaseTexture();
      init_GLTexture();
      init_mapInternalFormatToSamplerType();
      init_mapTypeAndFormatToInternalFormat();
      TextureSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = false;
        }
        contextChange() {
          const gl = this.gl = this.renderer.gl;
          this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(gl), this.samplerTypes = mapInternalFormatToSamplerType(gl);
          const maxTextures2 = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
          this.boundTextures.length = maxTextures2;
          for (let i2 = 0; i2 < maxTextures2; i2++)
            this.boundTextures[i2] = null;
          this.emptyTextures = {};
          const emptyTexture2D = new GLTexture(gl.createTexture());
          gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D, this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture()), gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
          for (let i2 = 0; i2 < 6; i2++)
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          for (let i2 = 0; i2 < this.boundTextures.length; i2++)
            this.bind(null, i2);
        }
        bind(texture, location = 0) {
          const { gl } = this;
          if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {
            texture.touched = this.renderer.textureGC.count;
            const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
            this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture)), glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture), this.boundTextures[location] = texture;
          } else
            this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;
        }
        reset() {
          this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
          for (let i2 = 0; i2 < this.boundTextures.length; i2++)
            this.boundTextures[i2] = this.unknownTexture;
        }
        unbind(texture) {
          const { gl, boundTextures } = this;
          if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            for (let i2 = 0; i2 < boundTextures.length; i2++)
              boundTextures[i2] === this.unknownTexture && this.bind(null, i2);
          }
          for (let i2 = 0; i2 < boundTextures.length; i2++)
            boundTextures[i2] === texture && (this.currentLocation !== i2 && (gl.activeTexture(gl.TEXTURE0 + i2), this.currentLocation = i2), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i2] = null);
        }
        ensureSamplerType(maxTextures2) {
          const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
          if (hasIntegerTextures)
            for (let i2 = maxTextures2 - 1; i2 >= 0; --i2) {
              const tex = boundTextures[i2];
              tex && tex._glTextures[CONTEXT_UID].samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);
            }
        }
        initTexture(texture) {
          const glTexture = new GLTexture(this.gl.createTexture());
          return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on("dispose", this.destroyTexture, this), glTexture;
        }
        initTextureType(texture, glTexture) {
          glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format, glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? SAMPLER_TYPES.FLOAT, this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;
        }
        updateTexture(texture) {
          const glTexture = texture._glTextures[this.CONTEXT_UID];
          if (!glTexture)
            return;
          const renderer = this.renderer;
          if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture))
            glTexture.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = true);
          else {
            const width = texture.realWidth, height = texture.realHeight, gl = renderer.gl;
            (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) && (glTexture.width = width, glTexture.height = height, gl.texImage2D(
              texture.target,
              0,
              glTexture.internalFormat,
              width,
              height,
              0,
              texture.format,
              glTexture.type,
              null
            ));
          }
          texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture), glTexture.dirtyId = texture.dirtyId;
        }
        destroyTexture(texture, skipRemove) {
          const { gl } = this;
          if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off("dispose", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {
            const i2 = this.managedTextures.indexOf(texture);
            i2 !== -1 && removeItems(this.managedTextures, i2, 1);
          }
        }
        updateTextureStyle(texture) {
          const glTexture = texture._glTextures[this.CONTEXT_UID];
          glTexture && ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo ? glTexture.mipmap = false : glTexture.mipmap = texture.mipmap >= 1, this.webGLVersion !== 2 && !texture.isPowerOfTwo ? glTexture.wrapMode = WRAP_MODES.CLAMP : glTexture.wrapMode = texture.wrapMode, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);
        }
        setStyle(texture, glTexture) {
          const gl = this.gl;
          if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
            if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {
              const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
              gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
            }
          } else
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
          gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        destroy() {
          this.renderer = null;
        }
      };
      TextureSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "texture"
      };
      extensions.add(TextureSystem);
    }
  });

  // node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs
  var TransformFeedbackSystem;
  var init_TransformFeedbackSystem = __esm({
    "node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs"() {
      init_lib5();
      TransformFeedbackSystem = class {
        constructor(renderer) {
          this.renderer = renderer;
        }
        contextChange() {
          this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        }
        bind(transformFeedback) {
          const { gl, CONTEXT_UID } = this, glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
        }
        unbind() {
          const { gl } = this;
          gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
        }
        beginTransformFeedback(drawMode, shader) {
          const { gl, renderer } = this;
          shader && renderer.shader.bind(shader), gl.beginTransformFeedback(drawMode);
        }
        endTransformFeedback() {
          const { gl } = this;
          gl.endTransformFeedback();
        }
        createGLTransformFeedback(tf) {
          const { gl, renderer, CONTEXT_UID } = this, glTransformFeedback = gl.createTransformFeedback();
          tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback, gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
          for (let i2 = 0; i2 < tf.buffers.length; i2++) {
            const buffer = tf.buffers[i2];
            buffer && (renderer.buffer.update(buffer), buffer._glBuffers[CONTEXT_UID].refCount++, gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i2, buffer._glBuffers[CONTEXT_UID].buffer || null));
          }
          return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null), tf.disposeRunner.add(this), glTransformFeedback;
        }
        disposeTransformFeedback(tf, contextLost) {
          const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID], gl = this.gl;
          tf.disposeRunner.remove(this);
          const bufferSystem = this.renderer.buffer;
          if (bufferSystem)
            for (let i2 = 0; i2 < tf.buffers.length; i2++) {
              const buffer = tf.buffers[i2];
              if (!buffer)
                continue;
              const buf = buffer._glBuffers[this.CONTEXT_UID];
              buf && (buf.refCount--, buf.refCount === 0 && !contextLost && bufferSystem.dispose(buffer, contextLost));
            }
          glTF && (contextLost || gl.deleteTransformFeedback(glTF), delete tf._glTransformFeedbacks[this.CONTEXT_UID]);
        }
        destroy() {
          this.renderer = null;
        }
      };
      TransformFeedbackSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "transformFeedback"
      };
      extensions.add(TransformFeedbackSystem);
    }
  });

  // node_modules/@pixi/core/lib/view/ViewSystem.mjs
  var ViewSystem;
  var init_ViewSystem = __esm({
    "node_modules/@pixi/core/lib/view/ViewSystem.mjs"() {
      init_lib5();
      init_lib7();
      init_lib2();
      ViewSystem = class {
        constructor(renderer) {
          this.renderer = renderer;
        }
        init(options) {
          this.screen = new Rectangle(0, 0, options.width, options.height), this.element = options.view || settings.ADAPTER.createCanvas(), this.resolution = options.resolution || settings.RESOLUTION, this.autoDensity = !!options.autoDensity;
        }
        resizeView(desiredScreenWidth, desiredScreenHeight) {
          this.element.width = Math.round(desiredScreenWidth * this.resolution), this.element.height = Math.round(desiredScreenHeight * this.resolution);
          const screenWidth = this.element.width / this.resolution, screenHeight = this.element.height / this.resolution;
          this.screen.width = screenWidth, this.screen.height = screenHeight, this.autoDensity && (this.element.style.width = `${screenWidth}px`, this.element.style.height = `${screenHeight}px`), this.renderer.emit("resize", screenWidth, screenHeight), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
        }
        destroy(removeView) {
          removeView && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null;
        }
      };
      ViewSystem.defaultOptions = {
        width: 800,
        height: 600,
        resolution: void 0,
        autoDensity: false
      }, ViewSystem.extension = {
        type: [
          ExtensionType.RendererSystem,
          ExtensionType.CanvasRendererSystem
        ],
        name: "_view"
      };
      extensions.add(ViewSystem);
    }
  });

  // node_modules/@pixi/core/lib/systems.mjs
  var init_systems = __esm({
    "node_modules/@pixi/core/lib/systems.mjs"() {
      init_BackgroundSystem();
      init_BatchSystem();
      init_ContextSystem();
      init_FilterSystem();
      init_FramebufferSystem();
      init_GeometrySystem();
      init_MaskSystem();
      init_ScissorSystem();
      init_StencilSystem();
      init_PluginSystem();
      init_ProjectionSystem();
      init_GenerateTextureSystem();
      init_RenderTextureSystem();
      init_ShaderSystem();
      init_StartupSystem();
      init_StateSystem();
      init_SystemManager();
      init_TextureGCSystem();
      init_TextureSystem();
      init_TransformFeedbackSystem();
      init_ViewSystem();
    }
  });

  // node_modules/@pixi/core/lib/settings.mjs
  var init_settings3 = __esm({
    "node_modules/@pixi/core/lib/settings.mjs"() {
      init_lib();
      init_lib2();
      init_lib4();
      init_BatchRenderer();
      init_Filter();
      init_Program();
      init_systems();
      init_BaseTexture();
      init_ContextSystem();
      init_BackgroundSystem();
      init_ViewSystem();
      init_StartupSystem();
      init_TextureGCSystem();
      settings.PREFER_ENV = ENV.WEBGL2;
      settings.STRICT_TEXTURE_CACHE = false;
      settings.RENDER_OPTIONS = {
        ...ContextSystem.defaultOptions,
        ...BackgroundSystem.defaultOptions,
        ...ViewSystem.defaultOptions,
        ...StartupSystem.defaultOptions
      };
      Object.defineProperties(settings, {
        WRAP_MODE: {
          get() {
            return BaseTexture.defaultOptions.wrapMode;
          },
          set(value) {
            deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), BaseTexture.defaultOptions.wrapMode = value;
          }
        },
        SCALE_MODE: {
          get() {
            return BaseTexture.defaultOptions.scaleMode;
          },
          set(value) {
            deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), BaseTexture.defaultOptions.scaleMode = value;
          }
        },
        MIPMAP_TEXTURES: {
          get() {
            return BaseTexture.defaultOptions.mipmap;
          },
          set(value) {
            deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), BaseTexture.defaultOptions.mipmap = value;
          }
        },
        ANISOTROPIC_LEVEL: {
          get() {
            return BaseTexture.defaultOptions.anisotropicLevel;
          },
          set(value) {
            deprecation(
              "7.1.0",
              "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"
            ), BaseTexture.defaultOptions.anisotropicLevel = value;
          }
        },
        FILTER_RESOLUTION: {
          get() {
            return deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), Filter.defaultResolution;
          },
          set(value) {
            Filter.defaultResolution = value;
          }
        },
        FILTER_MULTISAMPLE: {
          get() {
            return deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), Filter.defaultMultisample;
          },
          set(value) {
            Filter.defaultMultisample = value;
          }
        },
        SPRITE_MAX_TEXTURES: {
          get() {
            return BatchRenderer.defaultMaxTextures;
          },
          set(value) {
            deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), BatchRenderer.defaultMaxTextures = value;
          }
        },
        SPRITE_BATCH_SIZE: {
          get() {
            return BatchRenderer.defaultBatchSize;
          },
          set(value) {
            deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), BatchRenderer.defaultBatchSize = value;
          }
        },
        CAN_UPLOAD_SAME_BUFFER: {
          get() {
            return BatchRenderer.canUploadSameBuffer;
          },
          set(value) {
            deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), BatchRenderer.canUploadSameBuffer = value;
          }
        },
        GC_MODE: {
          get() {
            return TextureGCSystem.defaultMode;
          },
          set(value) {
            deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), TextureGCSystem.defaultMode = value;
          }
        },
        GC_MAX_IDLE: {
          get() {
            return TextureGCSystem.defaultMaxIdle;
          },
          set(value) {
            deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), TextureGCSystem.defaultMaxIdle = value;
          }
        },
        GC_MAX_CHECK_COUNT: {
          get() {
            return TextureGCSystem.defaultCheckCountMax;
          },
          set(value) {
            deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), TextureGCSystem.defaultCheckCountMax = value;
          }
        },
        PRECISION_VERTEX: {
          get() {
            return Program.defaultVertexPrecision;
          },
          set(value) {
            deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Program.defaultVertexPrecision = value;
          }
        },
        PRECISION_FRAGMENT: {
          get() {
            return Program.defaultFragmentPrecision;
          },
          set(value) {
            deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Program.defaultFragmentPrecision = value;
          }
        }
      });
    }
  });

  // node_modules/@pixi/ticker/lib/const.mjs
  var UPDATE_PRIORITY;
  var init_const3 = __esm({
    "node_modules/@pixi/ticker/lib/const.mjs"() {
      UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY22) => (UPDATE_PRIORITY22[UPDATE_PRIORITY22.INTERACTION = 50] = "INTERACTION", UPDATE_PRIORITY22[UPDATE_PRIORITY22.HIGH = 25] = "HIGH", UPDATE_PRIORITY22[UPDATE_PRIORITY22.NORMAL = 0] = "NORMAL", UPDATE_PRIORITY22[UPDATE_PRIORITY22.LOW = -25] = "LOW", UPDATE_PRIORITY22[UPDATE_PRIORITY22.UTILITY = -50] = "UTILITY", UPDATE_PRIORITY22))(UPDATE_PRIORITY || {});
    }
  });

  // node_modules/@pixi/ticker/lib/TickerListener.mjs
  var TickerListener;
  var init_TickerListener = __esm({
    "node_modules/@pixi/ticker/lib/TickerListener.mjs"() {
      TickerListener = class {
        constructor(fn, context3 = null, priority = 0, once = false) {
          this.next = null, this.previous = null, this._destroyed = false, this.fn = fn, this.context = context3, this.priority = priority, this.once = once;
        }
        match(fn, context3 = null) {
          return this.fn === fn && this.context === context3;
        }
        emit(deltaTime) {
          this.fn && (this.context ? this.fn.call(this.context, deltaTime) : this.fn(deltaTime));
          const redirect = this.next;
          return this.once && this.destroy(true), this._destroyed && (this.next = null), redirect;
        }
        connect(previous) {
          this.previous = previous, previous.next && (previous.next.previous = this), this.next = previous.next, previous.next = this;
        }
        destroy(hard = false) {
          this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
          const redirect = this.next;
          return this.next = hard ? null : redirect, this.previous = null, redirect;
        }
      };
    }
  });

  // node_modules/@pixi/ticker/lib/Ticker.mjs
  var _Ticker, Ticker;
  var init_Ticker = __esm({
    "node_modules/@pixi/ticker/lib/Ticker.mjs"() {
      init_const3();
      init_TickerListener();
      _Ticker = class _Ticker2 {
        constructor() {
          this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {
            this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
          };
        }
        _requestIfNeeded() {
          this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
        }
        _cancelIfNeeded() {
          this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
        }
        _startIfPossible() {
          this.started ? this._requestIfNeeded() : this.autoStart && this.start();
        }
        add(fn, context3, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context3, priority));
        }
        addOnce(fn, context3, priority = UPDATE_PRIORITY.NORMAL) {
          return this._addListener(new TickerListener(fn, context3, priority, true));
        }
        _addListener(listener) {
          let current = this._head.next, previous = this._head;
          if (!current)
            listener.connect(previous);
          else {
            for (; current; ) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current, current = current.next;
            }
            listener.previous || listener.connect(previous);
          }
          return this._startIfPossible(), this;
        }
        remove(fn, context3) {
          let listener = this._head.next;
          for (; listener; )
            listener.match(fn, context3) ? listener = listener.destroy() : listener = listener.next;
          return this._head.next || this._cancelIfNeeded(), this;
        }
        get count() {
          if (!this._head)
            return 0;
          let count2 = 0, current = this._head;
          for (; current = current.next; )
            count2++;
          return count2;
        }
        start() {
          this.started || (this.started = true, this._requestIfNeeded());
        }
        stop() {
          this.started && (this.started = false, this._cancelIfNeeded());
        }
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            for (; listener; )
              listener = listener.destroy(true);
            this._head.destroy(), this._head = null;
          }
        }
        update(currentTime = performance.now()) {
          let elapsedMS;
          if (currentTime > this.lastTime) {
            if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {
              const delta = currentTime - this._lastFrame | 0;
              if (delta < this._minElapsedMS)
                return;
              this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
            const head = this._head;
            let listener = head.next;
            for (; listener; )
              listener = listener.emit(this.deltaTime);
            head.next || this._cancelIfNeeded();
          } else
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          this.lastTime = currentTime;
        }
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        get maxFPS() {
          return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
        }
        set maxFPS(fps) {
          if (fps === 0)
            this._minElapsedMS = 0;
          else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        static get shared() {
          if (!_Ticker2._shared) {
            const shared = _Ticker2._shared = new _Ticker2();
            shared.autoStart = true, shared._protected = true;
          }
          return _Ticker2._shared;
        }
        static get system() {
          if (!_Ticker2._system) {
            const system = _Ticker2._system = new _Ticker2();
            system.autoStart = true, system._protected = true;
          }
          return _Ticker2._system;
        }
      };
      _Ticker.targetFPMS = 0.06;
      Ticker = _Ticker;
    }
  });

  // node_modules/@pixi/ticker/lib/settings.mjs
  var init_settings4 = __esm({
    "node_modules/@pixi/ticker/lib/settings.mjs"() {
      init_lib2();
      init_lib2();
      init_lib4();
      init_Ticker();
      Object.defineProperties(settings, {
        TARGET_FPMS: {
          get() {
            return Ticker.targetFPMS;
          },
          set(value) {
            deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Ticker.targetFPMS = value;
          }
        }
      });
    }
  });

  // node_modules/@pixi/ticker/lib/TickerPlugin.mjs
  var TickerPlugin;
  var init_TickerPlugin = __esm({
    "node_modules/@pixi/ticker/lib/TickerPlugin.mjs"() {
      init_lib5();
      init_const3();
      init_Ticker();
      TickerPlugin = class {
        static init(options) {
          options = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options), Object.defineProperty(
            this,
            "ticker",
            {
              set(ticker) {
                this._ticker && this._ticker.remove(this.render, this), this._ticker = ticker, ticker && ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
              },
              get() {
                return this._ticker;
              }
            }
          ), this.stop = () => {
            this._ticker.stop();
          }, this.start = () => {
            this._ticker.start();
          }, this._ticker = null, this.ticker = options.sharedTicker ? Ticker.shared : new Ticker(), options.autoStart && this.start();
        }
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null, oldTicker.destroy();
          }
        }
      };
      TickerPlugin.extension = ExtensionType.Application;
      extensions.add(TickerPlugin);
    }
  });

  // node_modules/@pixi/ticker/lib/index.mjs
  var init_lib8 = __esm({
    "node_modules/@pixi/ticker/lib/index.mjs"() {
      init_settings4();
      init_const3();
      init_Ticker();
      init_TickerPlugin();
    }
  });

  // node_modules/@pixi/core/lib/autoDetectRenderer.mjs
  function autoDetectRenderer(options) {
    for (const RendererType2 of renderers)
      if (RendererType2.test(options))
        return new RendererType2(options);
    throw new Error("Unable to auto-detect a suitable renderer.");
  }
  var renderers;
  var init_autoDetectRenderer = __esm({
    "node_modules/@pixi/core/lib/autoDetectRenderer.mjs"() {
      init_lib5();
      renderers = [];
      extensions.handleByList(ExtensionType.Renderer, renderers);
    }
  });

  // node_modules/@pixi/core/lib/fragments/default.vert.mjs
  var $defaultVertex;
  var init_default_vert = __esm({
    "node_modules/@pixi/core/lib/fragments/default.vert.mjs"() {
      $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`;
    }
  });

  // node_modules/@pixi/core/lib/fragments/defaultFilter.vert.mjs
  var $defaultFilterVertex;
  var init_defaultFilter_vert2 = __esm({
    "node_modules/@pixi/core/lib/fragments/defaultFilter.vert.mjs"() {
      $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
    }
  });

  // node_modules/@pixi/core/lib/fragments/index.mjs
  var defaultVertex4, defaultFilterVertex;
  var init_fragments = __esm({
    "node_modules/@pixi/core/lib/fragments/index.mjs"() {
      init_default_vert();
      init_defaultFilter_vert2();
      defaultVertex4 = $defaultVertex;
      defaultFilterVertex = $defaultFilterVertex;
    }
  });

  // node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs
  var MultisampleSystem;
  var init_MultisampleSystem = __esm({
    "node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs"() {
      init_lib();
      init_lib5();
      MultisampleSystem = class {
        constructor(renderer) {
          this.renderer = renderer;
        }
        contextChange(gl) {
          let samples;
          if (this.renderer.context.webGLVersion === 1) {
            const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          } else {
            const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), samples = gl.getParameter(gl.SAMPLES), gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
          }
          samples >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : samples >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : samples >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;
        }
        destroy() {
        }
      };
      MultisampleSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "_multisample"
      };
      extensions.add(MultisampleSystem);
    }
  });

  // node_modules/@pixi/core/lib/geometry/GLBuffer.mjs
  var GLBuffer;
  var init_GLBuffer = __esm({
    "node_modules/@pixi/core/lib/geometry/GLBuffer.mjs"() {
      GLBuffer = class {
        constructor(buffer) {
          this.buffer = buffer || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/geometry/BufferSystem.mjs
  var BufferSystem;
  var init_BufferSystem = __esm({
    "node_modules/@pixi/core/lib/geometry/BufferSystem.mjs"() {
      init_lib5();
      init_GLBuffer();
      BufferSystem = class {
        constructor(renderer) {
          this.renderer = renderer, this.managedBuffers = {}, this.boundBufferBases = {};
        }
        destroy() {
          this.renderer = null;
        }
        contextChange() {
          this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        }
        bind(buffer) {
          const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
          gl.bindBuffer(buffer.type, glBuffer.buffer);
        }
        unbind(type) {
          const { gl } = this;
          gl.bindBuffer(type, null);
        }
        bindBufferBase(buffer, index) {
          const { gl, CONTEXT_UID } = this;
          if (this.boundBufferBases[index] !== buffer) {
            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
            this.boundBufferBases[index] = buffer, gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
          }
        }
        bindBufferRange(buffer, index, offset) {
          const { gl, CONTEXT_UID } = this;
          offset = offset || 0;
          const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
        }
        update(buffer) {
          const { gl, CONTEXT_UID } = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
          if (buffer._updateID !== glBuffer.updateID)
            if (glBuffer.updateID = buffer._updateID, gl.bindBuffer(buffer.type, glBuffer.buffer), glBuffer.byteLength >= buffer.data.byteLength)
              gl.bufferSubData(buffer.type, 0, buffer.data);
            else {
              const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
              glBuffer.byteLength = buffer.data.byteLength, gl.bufferData(buffer.type, buffer.data, drawType);
            }
        }
        dispose(buffer, contextLost) {
          if (!this.managedBuffers[buffer.id])
            return;
          delete this.managedBuffers[buffer.id];
          const glBuffer = buffer._glBuffers[this.CONTEXT_UID], gl = this.gl;
          buffer.disposeRunner.remove(this), glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]);
        }
        disposeAll(contextLost) {
          const all = Object.keys(this.managedBuffers);
          for (let i2 = 0; i2 < all.length; i2++)
            this.dispose(this.managedBuffers[all[i2]], contextLost);
        }
        createGLBuffer(buffer) {
          const { CONTEXT_UID, gl } = this;
          return buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer()), this.managedBuffers[buffer.id] = buffer, buffer.disposeRunner.add(this), buffer._glBuffers[CONTEXT_UID];
        }
      };
      BufferSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "buffer"
      };
      extensions.add(BufferSystem);
    }
  });

  // node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs
  var ObjectRendererSystem;
  var init_ObjectRendererSystem = __esm({
    "node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs"() {
      init_lib5();
      ObjectRendererSystem = class {
        constructor(renderer) {
          this.renderer = renderer;
        }
        render(displayObject, options) {
          const renderer = this.renderer;
          let renderTexture, clear, transform2, skipUpdateTransform;
          if (options && (renderTexture = options.renderTexture, clear = options.clear, transform2 = options.transform, skipUpdateTransform = options.skipUpdateTransform), this.renderingToScreen = !renderTexture, renderer.runners.prerender.emit(), renderer.emit("prerender"), renderer.projection.transform = transform2, !renderer.context.isLost) {
            if (renderTexture || (this.lastObjectRendered = displayObject), !skipUpdateTransform) {
              const cacheParent = displayObject.enableTempParent();
              displayObject.updateTransform(), displayObject.disableTempParent(cacheParent);
            }
            renderer.renderTexture.bind(renderTexture), renderer.batch.currentRenderer.start(), (clear ?? renderer.background.clearBeforeRender) && renderer.renderTexture.clear(), displayObject.render(renderer), renderer.batch.currentRenderer.flush(), renderTexture && (options.blit && renderer.framebuffer.blit(), renderTexture.baseTexture.update()), renderer.runners.postrender.emit(), renderer.projection.transform = null, renderer.emit("postrender");
          }
        }
        destroy() {
          this.renderer = null, this.lastObjectRendered = null;
        }
      };
      ObjectRendererSystem.extension = {
        type: ExtensionType.RendererSystem,
        name: "objectRenderer"
      };
      extensions.add(ObjectRendererSystem);
    }
  });

  // node_modules/@pixi/core/lib/Renderer.mjs
  var _Renderer, Renderer;
  var init_Renderer = __esm({
    "node_modules/@pixi/core/lib/Renderer.mjs"() {
      init_lib();
      init_lib5();
      init_lib7();
      init_lib2();
      init_lib4();
      init_UniformGroup();
      init_SystemManager();
      _Renderer = class _Renderer2 extends SystemManager {
        constructor(options) {
          super(), this.type = RENDERER_TYPE.WEBGL, options = Object.assign({}, settings.RENDER_OPTIONS, options), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new UniformGroup({
            projectionMatrix: new Matrix()
          }, true);
          const systemConfig = {
            runners: [
              "init",
              "destroy",
              "contextChange",
              "resolutionChange",
              "reset",
              "update",
              "postrender",
              "prerender",
              "resize"
            ],
            systems: _Renderer2.__systems,
            priority: [
              "_view",
              "textureGenerator",
              "background",
              "_plugin",
              "startup",
              "context",
              "state",
              "texture",
              "buffer",
              "geometry",
              "framebuffer",
              "transformFeedback",
              "mask",
              "scissor",
              "stencil",
              "projection",
              "textureGC",
              "filter",
              "renderTexture",
              "batch",
              "objectRenderer",
              "_multisample"
            ]
          };
          this.setup(systemConfig), "useContextAlpha" in options && (deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied", options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha), this._plugin.rendererPlugins = _Renderer2.__plugins, this.options = options, this.startup.run(this.options);
        }
        static test(options) {
          return options?.forceCanvas ? false : isWebGLSupported();
        }
        render(displayObject, options) {
          this.objectRenderer.render(displayObject, options);
        }
        resize(desiredScreenWidth, desiredScreenHeight) {
          this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
        }
        reset() {
          return this.runners.reset.emit(), this;
        }
        clear() {
          this.renderTexture.bind(), this.renderTexture.clear();
        }
        destroy(removeView = false) {
          this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
            _view: removeView
          }), super.destroy();
        }
        get plugins() {
          return this._plugin.plugins;
        }
        get multisample() {
          return this._multisample.multisample;
        }
        get width() {
          return this._view.element.width;
        }
        get height() {
          return this._view.element.height;
        }
        get resolution() {
          return this._view.resolution;
        }
        set resolution(value) {
          this._view.resolution = value, this.runners.resolutionChange.emit(value);
        }
        get autoDensity() {
          return this._view.autoDensity;
        }
        get view() {
          return this._view.element;
        }
        get screen() {
          return this._view.screen;
        }
        get lastObjectRendered() {
          return this.objectRenderer.lastObjectRendered;
        }
        get renderingToScreen() {
          return this.objectRenderer.renderingToScreen;
        }
        get rendererLogId() {
          return `WebGL ${this.context.webGLVersion}`;
        }
        get clearBeforeRender() {
          return deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;
        }
        get useContextAlpha() {
          return deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;
        }
        get preserveDrawingBuffer() {
          return deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;
        }
        get backgroundColor() {
          return deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
        }
        set backgroundColor(value) {
          deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = value;
        }
        get backgroundAlpha() {
          return deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
        }
        set backgroundAlpha(value) {
          deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = value;
        }
        get powerPreference() {
          return deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;
        }
        generateTexture(displayObject, options) {
          return this.textureGenerator.generateTexture(displayObject, options);
        }
      };
      _Renderer.extension = {
        type: ExtensionType.Renderer,
        priority: 1
      }, _Renderer.__plugins = {}, _Renderer.__systems = {};
      Renderer = _Renderer;
      extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
      extensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);
      extensions.add(Renderer);
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs
  var AbstractMultiResource;
  var init_AbstractMultiResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs"() {
      init_BaseTexture();
      init_autoDetectResource();
      init_Resource();
      AbstractMultiResource = class extends Resource {
        constructor(length, options) {
          const { width, height } = options || {};
          super(width, height), this.items = [], this.itemDirtyIds = [];
          for (let i2 = 0; i2 < length; i2++) {
            const partTexture = new BaseTexture();
            this.items.push(partTexture), this.itemDirtyIds.push(-2);
          }
          this.length = length, this._load = null, this.baseTexture = null;
        }
        initFromArray(resources, options) {
          for (let i2 = 0; i2 < this.length; i2++)
            resources[i2] && (resources[i2].castToBaseTexture ? this.addBaseTextureAt(resources[i2].castToBaseTexture(), i2) : resources[i2] instanceof Resource ? this.addResourceAt(resources[i2], i2) : this.addResourceAt(autoDetectResource(resources[i2], options), i2));
        }
        dispose() {
          for (let i2 = 0, len = this.length; i2 < len; i2++)
            this.items[i2].destroy();
          this.items = null, this.itemDirtyIds = null, this._load = null;
        }
        addResourceAt(resource, index) {
          if (!this.items[index])
            throw new Error(`Index ${index} is out of bounds`);
          return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;
        }
        bind(baseTexture) {
          if (this.baseTexture !== null)
            throw new Error("Only one base texture per TextureArray is allowed");
          super.bind(baseTexture);
          for (let i2 = 0; i2 < this.length; i2++)
            this.items[i2].parentTextureArray = baseTexture, this.items[i2].on("update", baseTexture.update, baseTexture);
        }
        unbind(baseTexture) {
          super.unbind(baseTexture);
          for (let i2 = 0; i2 < this.length; i2++)
            this.items[i2].parentTextureArray = null, this.items[i2].off("update", baseTexture.update, baseTexture);
        }
        load() {
          if (this._load)
            return this._load;
          const promises = this.items.map((item) => item.resource).filter((item) => item).map((item) => item.load());
          return this._load = Promise.all(promises).then(
            () => {
              const { realWidth, realHeight } = this.items[0];
              return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);
            }
          ), this._load;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs
  var ArrayResource;
  var init_ArrayResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs"() {
      init_lib();
      init_AbstractMultiResource();
      ArrayResource = class extends AbstractMultiResource {
        constructor(source2, options) {
          const { width, height } = options || {};
          let urls, length;
          Array.isArray(source2) ? (urls = source2, length = source2.length) : length = source2, super(length, { width, height }), urls && this.initFromArray(urls, options);
        }
        addBaseTextureAt(baseTexture, index) {
          if (baseTexture.resource)
            this.addResourceAt(baseTexture.resource, index);
          else
            throw new Error("ArrayResource does not support RenderTexture");
          return this;
        }
        bind(baseTexture) {
          super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;
        }
        upload(renderer, texture, glTexture) {
          const { length, itemDirtyIds, items } = this, { gl } = renderer;
          glTexture.dirtyId < 0 && gl.texImage3D(
            gl.TEXTURE_2D_ARRAY,
            0,
            glTexture.internalFormat,
            this._width,
            this._height,
            length,
            0,
            texture.format,
            glTexture.type,
            null
          );
          for (let i2 = 0; i2 < length; i2++) {
            const item = items[i2];
            itemDirtyIds[i2] < item.dirtyId && (itemDirtyIds[i2] = item.dirtyId, item.valid && gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              i2,
              item.resource.width,
              item.resource.height,
              1,
              texture.format,
              glTexture.type,
              item.resource.source
            ));
          }
          return true;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs
  var CanvasResource;
  var init_CanvasResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs"() {
      init_BaseImageResource();
      CanvasResource = class extends BaseImageResource {
        constructor(source2) {
          super(source2);
        }
        static test(source2) {
          const { OffscreenCanvas: OffscreenCanvas2 } = globalThis;
          return OffscreenCanvas2 && source2 instanceof OffscreenCanvas2 ? true : globalThis.HTMLCanvasElement && source2 instanceof HTMLCanvasElement;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs
  var _CubeResource, CubeResource;
  var init_CubeResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs"() {
      init_lib();
      init_AbstractMultiResource();
      _CubeResource = class _CubeResource2 extends AbstractMultiResource {
        constructor(source2, options) {
          const { width, height, autoLoad, linkBaseTexture } = options || {};
          if (source2 && source2.length !== _CubeResource2.SIDES)
            throw new Error(`Invalid length. Got ${source2.length}, expected 6`);
          super(6, { width, height });
          for (let i2 = 0; i2 < _CubeResource2.SIDES; i2++)
            this.items[i2].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
          this.linkBaseTexture = linkBaseTexture !== false, source2 && this.initFromArray(source2, options), autoLoad !== false && this.load();
        }
        bind(baseTexture) {
          super.bind(baseTexture), baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;
        }
        addBaseTextureAt(baseTexture, index, linkBaseTexture) {
          if (linkBaseTexture === void 0 && (linkBaseTexture = this.linkBaseTexture), !this.items[index])
            throw new Error(`Index ${index} is out of bounds`);
          if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0)
            if (baseTexture.resource)
              this.addResourceAt(baseTexture.resource, index);
            else
              throw new Error("CubeResource does not support copying of renderTexture.");
          else
            baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;
          return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;
        }
        upload(renderer, _baseTexture, glTexture) {
          const dirty = this.itemDirtyIds;
          for (let i2 = 0; i2 < _CubeResource2.SIDES; i2++) {
            const side = this.items[i2];
            (dirty[i2] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i2] = side.dirtyId) : dirty[i2] < -1 && (renderer.gl.texImage2D(
              side.target,
              0,
              glTexture.internalFormat,
              _baseTexture.realWidth,
              _baseTexture.realHeight,
              0,
              _baseTexture.format,
              glTexture.type,
              null
            ), dirty[i2] = -1));
          }
          return true;
        }
        static test(source2) {
          return Array.isArray(source2) && source2.length === _CubeResource2.SIDES;
        }
      };
      _CubeResource.SIDES = 6;
      CubeResource = _CubeResource;
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs
  var ImageBitmapResource;
  var init_ImageBitmapResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs"() {
      init_lib();
      init_lib2();
      init_BaseImageResource();
      ImageBitmapResource = class extends BaseImageResource {
        constructor(source2, options) {
          options = options || {};
          let baseSource, url2, ownsImageBitmap;
          typeof source2 == "string" ? (baseSource = ImageBitmapResource.EMPTY, url2 = source2, ownsImageBitmap = true) : (baseSource = source2, url2 = null, ownsImageBitmap = false), super(baseSource), this.url = url2, this.crossOrigin = options.crossOrigin ?? true, this.alphaMode = typeof options.alphaMode == "number" ? options.alphaMode : null, this.ownsImageBitmap = options.ownsImageBitmap ?? ownsImageBitmap, this._load = null, options.autoLoad !== false && this.load();
        }
        load() {
          return this._load ? this._load : (this._load = new Promise(async (resolve2, reject) => {
            if (this.url === null) {
              resolve2(this);
              return;
            }
            try {
              const response = await settings.ADAPTER.fetch(this.url, {
                mode: this.crossOrigin ? "cors" : "no-cors"
              });
              if (this.destroyed)
                return;
              const imageBlob = await response.blob();
              if (this.destroyed)
                return;
              const imageBitmap = await createImageBitmap(imageBlob, {
                premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
              });
              if (this.destroyed) {
                imageBitmap.close();
                return;
              }
              this.source = imageBitmap, this.update(), resolve2(this);
            } catch (e2) {
              if (this.destroyed)
                return;
              reject(e2), this.onError.emit(e2);
            }
          }), this._load);
        }
        upload(renderer, baseTexture, glTexture) {
          return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (baseTexture.alphaMode = this.alphaMode), super.upload(renderer, baseTexture, glTexture)) : (this.load(), false);
        }
        dispose() {
          this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null;
        }
        static test(source2) {
          return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof source2 == "string" || source2 instanceof ImageBitmap);
        }
        static get EMPTY() {
          return ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0), ImageBitmapResource._EMPTY;
        }
      };
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs
  var _SVGResource, SVGResource;
  var init_SVGResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs"() {
      init_lib2();
      init_lib4();
      init_BaseImageResource();
      _SVGResource = class _SVGResource2 extends BaseImageResource {
        constructor(sourceBase64, options) {
          options = options || {}, super(settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = sourceBase64, this.scale = options.scale || 1, this._overrideWidth = options.width, this._overrideHeight = options.height, this._resolve = null, this._crossorigin = options.crossorigin, this._load = null, options.autoLoad !== false && this.load();
        }
        load() {
          return this._load ? this._load : (this._load = new Promise((resolve2) => {
            if (this._resolve = () => {
              this.update(), resolve2(this);
            }, _SVGResource2.SVG_XML.test(this.svg.trim())) {
              if (!btoa)
                throw new Error("Your browser doesn't support base64 conversions.");
              this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
            }
            this._loadSvg();
          }), this._load);
        }
        _loadSvg() {
          const tempImage = new Image();
          BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin), tempImage.src = this.svg, tempImage.onerror = (event) => {
            this._resolve && (tempImage.onerror = null, this.onError.emit(event));
          }, tempImage.onload = () => {
            if (!this._resolve)
              return;
            const svgWidth = tempImage.width, svgHeight = tempImage.height;
            if (!svgWidth || !svgHeight)
              throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let width = svgWidth * this.scale, height = svgHeight * this.scale;
            (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight), width = Math.round(width), height = Math.round(height);
            const canvas = this.source;
            canvas.width = width, canvas.height = height, canvas._pixiId = `canvas_${uid()}`, canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height), this._resolve(), this._resolve = null;
          };
        }
        static getSize(svgString) {
          const sizeMatch = _SVGResource2.SVG_SIZE.exec(svgString), size = {};
          return sizeMatch && (size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3])), size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]))), size;
        }
        dispose() {
          super.dispose(), this._resolve = null, this._crossorigin = null;
        }
        static test(source2, extension) {
          return extension === "svg" || typeof source2 == "string" && source2.startsWith("data:image/svg+xml") || typeof source2 == "string" && _SVGResource2.SVG_XML.test(source2);
        }
      };
      _SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, _SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
      SVGResource = _SVGResource;
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs
  var _VideoResource, VideoResource;
  var init_VideoResource = __esm({
    "node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs"() {
      init_lib8();
      init_BaseImageResource();
      _VideoResource = class _VideoResource2 extends BaseImageResource {
        constructor(source2, options) {
          if (options = options || {}, !(source2 instanceof HTMLVideoElement)) {
            const videoElement = document.createElement("video");
            options.autoLoad !== false && videoElement.setAttribute("preload", "auto"), options.playsinline !== false && (videoElement.setAttribute("webkit-playsinline", ""), videoElement.setAttribute("playsinline", "")), options.muted === true && (videoElement.setAttribute("muted", ""), videoElement.muted = true), options.loop === true && videoElement.setAttribute("loop", ""), options.autoPlay !== false && videoElement.setAttribute("autoplay", ""), typeof source2 == "string" && (source2 = [source2]);
            const firstSrc = source2[0].src || source2[0];
            BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
            for (let i2 = 0; i2 < source2.length; ++i2) {
              const sourceElement = document.createElement("source");
              let { src, mime } = source2[i2];
              if (src = src || source2[i2], src.startsWith("data:"))
                mime = src.slice(5, src.indexOf(";"));
              else if (!src.startsWith("blob:")) {
                const baseSrc = src.split("?").shift().toLowerCase(), ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
                mime = mime || _VideoResource2.MIME_TYPES[ext] || `video/${ext}`;
              }
              sourceElement.src = src, mime && (sourceElement.type = mime), videoElement.appendChild(sourceElement);
            }
            source2 = videoElement;
          }
          super(source2), this.noSubImage = true, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = options.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = options.autoPlay !== false, this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), options.autoLoad !== false && this.load();
        }
        update(_deltaTime = 0) {
          if (!this.destroyed) {
            if (this._updateFPS) {
              const elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
              this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
            }
            (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
          }
        }
        _videoFrameRequestCallback() {
          this.update(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
        load() {
          if (this._load)
            return this._load;
          const source2 = this.source;
          return (source2.readyState === source2.HAVE_ENOUGH_DATA || source2.readyState === source2.HAVE_FUTURE_DATA) && source2.width && source2.height && (source2.complete = true), source2.addEventListener("play", this._onPlayStart), source2.addEventListener("pause", this._onPlayStop), source2.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source2.addEventListener("canplay", this._onCanPlay), source2.addEventListener("canplaythrough", this._onCanPlay), source2.addEventListener("error", this._onError, true)), this._load = new Promise((resolve2, reject) => {
            this.valid ? resolve2(this) : (this._resolve = resolve2, this._reject = reject, source2.load());
          }), this._load;
        }
        _onError(event) {
          this.source.removeEventListener("error", this._onError, true), this.onError.emit(event), this._reject && (this._reject(event), this._reject = null, this._resolve = null);
        }
        _isSourcePlaying() {
          const source2 = this.source;
          return !source2.paused && !source2.ended && this._isSourceReady();
        }
        _isSourceReady() {
          return this.source.readyState > 2;
        }
        _onPlayStart() {
          this.valid || this._onCanPlay(), this._configureAutoUpdate();
        }
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        _onSeeked() {
          this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);
        }
        _onCanPlay() {
          const source2 = this.source;
          source2.removeEventListener("canplay", this._onCanPlay), source2.removeEventListener("canplaythrough", this._onCanPlay);
          const valid = this.valid;
          this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0, !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source2.play();
        }
        dispose() {
          this._configureAutoUpdate();
          const source2 = this.source;
          source2 && (source2.removeEventListener("play", this._onPlayStart), source2.removeEventListener("pause", this._onPlayStop), source2.removeEventListener("seeked", this._onSeeked), source2.removeEventListener("canplay", this._onCanPlay), source2.removeEventListener("canplaythrough", this._onCanPlay), source2.removeEventListener("error", this._onError, true), source2.pause(), source2.src = "", source2.load()), super.dispose();
        }
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());
        }
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value) {
          value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());
        }
        _configureAutoUpdate() {
          this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          ))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ticker.shared.add(this.update, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
        }
        static test(source2, extension) {
          return globalThis.HTMLVideoElement && source2 instanceof HTMLVideoElement || _VideoResource2.TYPES.includes(extension);
        }
      };
      _VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], _VideoResource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      VideoResource = _VideoResource;
    }
  });

  // node_modules/@pixi/core/lib/textures/resources/index.mjs
  var init_resources = __esm({
    "node_modules/@pixi/core/lib/textures/resources/index.mjs"() {
      init_ArrayResource();
      init_autoDetectResource();
      init_autoDetectResource();
      init_BufferResource();
      init_CanvasResource();
      init_CubeResource();
      init_ImageBitmapResource();
      init_ImageResource();
      init_SVGResource();
      init_VideoResource();
      init_BaseImageResource();
      init_Resource();
      init_AbstractMultiResource();
      INSTALLED.push(
        ImageBitmapResource,
        ImageResource,
        CanvasResource,
        VideoResource,
        SVGResource,
        BufferResource,
        CubeResource,
        ArrayResource
      );
    }
  });

  // node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs
  var init_TransformFeedback = __esm({
    "node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs"() {
      init_lib6();
    }
  });

  // node_modules/@pixi/core/lib/index.mjs
  var init_lib9 = __esm({
    "node_modules/@pixi/core/lib/index.mjs"() {
      init_settings3();
      init_lib3();
      init_lib();
      init_lib5();
      init_lib7();
      init_lib6();
      init_lib2();
      init_lib8();
      init_lib4();
      init_autoDetectRenderer();
      init_BackgroundSystem();
      init_BatchDrawCall();
      init_BatchGeometry();
      init_BatchRenderer();
      init_BatchShaderGenerator();
      init_BatchSystem();
      init_BatchTextureArray();
      init_ObjectRenderer();
      init_ContextSystem();
      init_Filter();
      init_FilterState();
      init_FilterSystem();
      init_SpriteMaskFilter();
      init_fragments();
      init_Framebuffer();
      init_FramebufferSystem();
      init_GLFramebuffer();
      init_MultisampleSystem();
      init_Attribute();
      init_Buffer();
      init_BufferSystem();
      init_Geometry();
      init_GeometrySystem();
      init_ViewableBuffer();
      init_MaskData();
      init_MaskSystem();
      init_ScissorSystem();
      init_StencilSystem();
      init_PluginSystem();
      init_ProjectionSystem();
      init_ObjectRendererSystem();
      init_Renderer();
      init_BaseRenderTexture();
      init_GenerateTextureSystem();
      init_RenderTexture();
      init_RenderTexturePool();
      init_RenderTextureSystem();
      init_GLProgram();
      init_Program();
      init_Shader();
      init_ShaderSystem();
      init_UniformGroup();
      init_checkMaxIfStatementsInShader();
      init_generateProgram();
      init_generateUniformBufferSync();
      init_getTestContext();
      init_uniformParsers();
      init_unsafeEvalSupported();
      init_StartupSystem();
      init_State();
      init_StateSystem();
      init_systems();
      init_BaseTexture();
      init_GLTexture();
      init_resources();
      init_Texture();
      init_TextureGCSystem();
      init_TextureMatrix();
      init_TextureSystem();
      init_TextureUvs();
      init_TransformFeedback();
      init_TransformFeedbackSystem();
      init_Quad();
      init_QuadUv();
      init_ViewSystem();
      init_SystemManager();
      init_BaseImageResource();
      init_Resource();
      init_AbstractMultiResource();
      init_ArrayResource();
      init_autoDetectResource();
      init_BufferResource();
      init_CanvasResource();
      init_CubeResource();
      init_ImageBitmapResource();
      init_ImageResource();
      init_SVGResource();
      init_VideoResource();
    }
  });

  // node_modules/@pixi/display/lib/Bounds.mjs
  var Bounds;
  var init_Bounds = __esm({
    "node_modules/@pixi/display/lib/Bounds.mjs"() {
      init_lib9();
      Bounds = class {
        constructor() {
          this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
        }
        isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }
        clear() {
          this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
        }
        getRectangle(rect) {
          return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (rect = rect || new Rectangle(0, 0, 1, 1), rect.x = this.minX, rect.y = this.minY, rect.width = this.maxX - this.minX, rect.height = this.maxY - this.minY, rect);
        }
        addPoint(point) {
          this.minX = Math.min(this.minX, point.x), this.maxX = Math.max(this.maxX, point.x), this.minY = Math.min(this.minY, point.y), this.maxY = Math.max(this.maxY, point.y);
        }
        addPointMatrix(matrix, point) {
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix, x2 = a2 * point.x + c2 * point.y + tx, y2 = b2 * point.x + d2 * point.y + ty;
          this.minX = Math.min(this.minX, x2), this.maxX = Math.max(this.maxX, x2), this.minY = Math.min(this.minY, y2), this.maxY = Math.max(this.maxY, y2);
        }
        addQuad(vertices) {
          let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x2 = vertices[0], y2 = vertices[1];
          minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = vertices[2], y2 = vertices[3], minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = vertices[4], y2 = vertices[5], minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = vertices[6], y2 = vertices[7], minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
        }
        addFrame(transform2, x0, y0, x1, y1) {
          this.addFrameMatrix(transform2.worldTransform, x0, y0, x1, y1);
        }
        addFrameMatrix(matrix, x0, y0, x1, y1) {
          const a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
          let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x2 = a2 * x0 + c2 * y0 + tx, y2 = b2 * x0 + d2 * y0 + ty;
          minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = a2 * x1 + c2 * y0 + tx, y2 = b2 * x1 + d2 * y0 + ty, minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = a2 * x0 + c2 * y1 + tx, y2 = b2 * x0 + d2 * y1 + ty, minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, x2 = a2 * x1 + c2 * y1 + tx, y2 = b2 * x1 + d2 * y1 + ty, minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY, this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
        }
        addVertexData(vertexData, beginOffset, endOffset) {
          let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
          for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
            const x2 = vertexData[i2], y2 = vertexData[i2 + 1];
            minX = x2 < minX ? x2 : minX, minY = y2 < minY ? y2 : minY, maxX = x2 > maxX ? x2 : maxX, maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
        }
        addVertices(transform2, vertices, beginOffset, endOffset) {
          this.addVerticesMatrix(transform2.worldTransform, vertices, beginOffset, endOffset);
        }
        addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
          const a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
          let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
          for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
            const rawX = vertices[i2], rawY = vertices[i2 + 1], x2 = a2 * rawX + c2 * rawY + tx, y2 = d2 * rawY + b2 * rawX + ty;
            minX = Math.min(minX, x2 - padX), maxX = Math.max(maxX, x2 + padX), minY = Math.min(minY, y2 - padY), maxY = Math.max(maxY, y2 + padY);
          }
          this.minX = minX, this.minY = minY, this.maxX = maxX, this.maxY = maxY;
        }
        addBounds(bounds) {
          const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
          this.minX = bounds.minX < minX ? bounds.minX : minX, this.minY = bounds.minY < minY ? bounds.minY : minY, this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX, this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
        }
        addBoundsMask(bounds, mask) {
          const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX, _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY, _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX, _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
          if (_minX <= _maxX && _minY <= _maxY) {
            const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;
          }
        }
        addBoundsMatrix(bounds, matrix) {
          this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        }
        addBoundsArea(bounds, area) {
          const _minX = bounds.minX > area.x ? bounds.minX : area.x, _minY = bounds.minY > area.y ? bounds.minY : area.y, _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width, _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
          if (_minX <= _maxX && _minY <= _maxY) {
            const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX, this.minY = _minY < minY ? _minY : minY, this.maxX = _maxX > maxX ? _maxX : maxX, this.maxY = _maxY > maxY ? _maxY : maxY;
          }
        }
        pad(paddingX = 0, paddingY = paddingX) {
          this.isEmpty() || (this.minX -= paddingX, this.maxX += paddingX, this.minY -= paddingY, this.maxY += paddingY);
        }
        addFramePad(x0, y0, x1, y1, padX, padY) {
          x0 -= padX, y0 -= padY, x1 += padX, y1 += padY, this.minX = this.minX < x0 ? this.minX : x0, this.maxX = this.maxX > x1 ? this.maxX : x1, this.minY = this.minY < y0 ? this.minY : y0, this.maxY = this.maxY > y1 ? this.maxY : y1;
        }
      };
    }
  });

  // node_modules/@pixi/display/lib/DisplayObject.mjs
  var DisplayObject, TemporaryDisplayObject;
  var init_DisplayObject = __esm({
    "node_modules/@pixi/display/lib/DisplayObject.mjs"() {
      init_lib9();
      init_Bounds();
      DisplayObject = class extends lib_exports.EventEmitter {
        constructor() {
          super(), this.tempDisplayObjectParent = null, this.transform = new Transform(), this.alpha = 1, this.visible = true, this.renderable = true, this.cullable = false, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Bounds(), this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = false, this.isSprite = false, this.isMask = false;
        }
        static mixin(source2) {
          const keys = Object.keys(source2);
          for (let i2 = 0; i2 < keys.length; ++i2) {
            const propertyName = keys[i2];
            Object.defineProperty(
              DisplayObject.prototype,
              propertyName,
              Object.getOwnPropertyDescriptor(source2, propertyName)
            );
          }
        }
        get destroyed() {
          return this._destroyed;
        }
        _recursivePostUpdateTransform() {
          this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
        updateTransform() {
          this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
        }
        getBounds(skipUpdate, rect) {
          return skipUpdate || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), rect || (this._boundsRect || (this._boundsRect = new Rectangle()), rect = this._boundsRect), this._bounds.getRectangle(rect);
        }
        getLocalBounds(rect) {
          rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());
          const transformRef = this.transform, parentRef = this.parent;
          this.parent = null, this._tempDisplayObjectParent.worldAlpha = parentRef?.worldAlpha ?? 1, this.transform = this._tempDisplayObjectParent.transform;
          const worldBounds = this._bounds, worldBoundsID = this._boundsID;
          this._bounds = this._localBounds;
          const bounds = this.getBounds(false, rect);
          return this.parent = parentRef, this.transform = transformRef, this._bounds = worldBounds, this._bounds.updateID += this._boundsID - worldBoundsID, bounds;
        }
        toGlobal(position, point, skipUpdate = false) {
          return skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(position, point);
        }
        toLocal(position, from, point, skipUpdate) {
          return from && (position = from.toGlobal(position, point, skipUpdate)), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(position, point);
        }
        setParent(container) {
          if (!container || !container.addChild)
            throw new Error("setParent: Argument must be a Container");
          return container.addChild(this), container;
        }
        removeFromParent() {
          this.parent?.removeChild(this);
        }
        setTransform(x2 = 0, y2 = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
          return this.position.x = x2, this.position.y = y2, this.scale.x = scaleX || 1, this.scale.y = scaleY || 1, this.rotation = rotation, this.skew.x = skewX, this.skew.y = skewY, this.pivot.x = pivotX, this.pivot.y = pivotY, this;
        }
        destroy(_options) {
          this.removeFromParent(), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.eventMode = "auto", this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
        }
        get _tempDisplayObjectParent() {
          return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
        }
        enableTempParent() {
          const myParent = this.parent;
          return this.parent = this._tempDisplayObjectParent, myParent;
        }
        disableTempParent(cacheParent) {
          this.parent = cacheParent;
        }
        get x() {
          return this.position.x;
        }
        set x(value) {
          this.transform.position.x = value;
        }
        get y() {
          return this.position.y;
        }
        set y(value) {
          this.transform.position.y = value;
        }
        get worldTransform() {
          return this.transform.worldTransform;
        }
        get localTransform() {
          return this.transform.localTransform;
        }
        get position() {
          return this.transform.position;
        }
        set position(value) {
          this.transform.position.copyFrom(value);
        }
        get scale() {
          return this.transform.scale;
        }
        set scale(value) {
          this.transform.scale.copyFrom(value);
        }
        get pivot() {
          return this.transform.pivot;
        }
        set pivot(value) {
          this.transform.pivot.copyFrom(value);
        }
        get skew() {
          return this.transform.skew;
        }
        set skew(value) {
          this.transform.skew.copyFrom(value);
        }
        get rotation() {
          return this.transform.rotation;
        }
        set rotation(value) {
          this.transform.rotation = value;
        }
        get angle() {
          return this.transform.rotation * RAD_TO_DEG;
        }
        set angle(value) {
          this.transform.rotation = value * DEG_TO_RAD;
        }
        get zIndex() {
          return this._zIndex;
        }
        set zIndex(value) {
          this._zIndex = value, this.parent && (this.parent.sortDirty = true);
        }
        get worldVisible() {
          let item = this;
          do {
            if (!item.visible)
              return false;
            item = item.parent;
          } while (item);
          return true;
        }
        get mask() {
          return this._mask;
        }
        set mask(value) {
          if (this._mask !== value) {
            if (this._mask) {
              const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
              maskObject && (maskObject._maskRefCount--, maskObject._maskRefCount === 0 && (maskObject.renderable = true, maskObject.isMask = false));
            }
            if (this._mask = value, this._mask) {
              const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
              maskObject && (maskObject._maskRefCount === 0 && (maskObject.renderable = false, maskObject.isMask = true), maskObject._maskRefCount++);
            }
          }
        }
      };
      TemporaryDisplayObject = class extends DisplayObject {
        constructor() {
          super(...arguments), this.sortDirty = null;
        }
      };
      DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
    }
  });

  // node_modules/@pixi/display/lib/Container.mjs
  function sortChildren(a2, b2) {
    return a2.zIndex === b2.zIndex ? a2._lastSortedIndex - b2._lastSortedIndex : a2.zIndex - b2.zIndex;
  }
  var tempMatrix3, _Container, Container;
  var init_Container = __esm({
    "node_modules/@pixi/display/lib/Container.mjs"() {
      init_lib9();
      init_DisplayObject();
      tempMatrix3 = new Matrix();
      _Container = class _Container2 extends DisplayObject {
        constructor() {
          super(), this.children = [], this.sortableChildren = _Container2.defaultSortableChildren, this.sortDirty = false;
        }
        onChildrenChange(_length) {
        }
        addChild(...children) {
          if (children.length > 1)
            for (let i2 = 0; i2 < children.length; i2++)
              this.addChild(children[i2]);
          else {
            const child = children[0];
            child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = true, child.transform._parentID = -1, this.children.push(child), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", child, this, this.children.length - 1), child.emit("added", this);
          }
          return children[0];
        }
        addChildAt(child, index) {
          if (index < 0 || index > this.children.length)
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
          return child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = true, child.transform._parentID = -1, this.children.splice(index, 0, child), this._boundsID++, this.onChildrenChange(index), child.emit("added", this), this.emit("childAdded", child, this, index), child;
        }
        swapChildren(child, child2) {
          if (child === child2)
            return;
          const index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);
          this.children[index1] = child2, this.children[index2] = child, this.onChildrenChange(index1 < index2 ? index1 : index2);
        }
        getChildIndex(child) {
          const index = this.children.indexOf(child);
          if (index === -1)
            throw new Error("The supplied DisplayObject must be a child of the caller");
          return index;
        }
        setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length)
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
          const currentIndex = this.getChildIndex(child);
          lib_exports.removeItems(this.children, currentIndex, 1), this.children.splice(index, 0, child), this.onChildrenChange(index);
        }
        getChildAt(index) {
          if (index < 0 || index >= this.children.length)
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
          return this.children[index];
        }
        removeChild(...children) {
          if (children.length > 1)
            for (let i2 = 0; i2 < children.length; i2++)
              this.removeChild(children[i2]);
          else {
            const child = children[0], index = this.children.indexOf(child);
            if (index === -1)
              return null;
            child.parent = null, child.transform._parentID = -1, lib_exports.removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index);
          }
          return children[0];
        }
        removeChildAt(index) {
          const child = this.getChildAt(index);
          return child.parent = null, child.transform._parentID = -1, lib_exports.removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index), child;
        }
        removeChildren(beginIndex = 0, endIndex = this.children.length) {
          const begin3 = beginIndex, end = endIndex, range = end - begin3;
          let removed;
          if (range > 0 && range <= end) {
            removed = this.children.splice(begin3, range);
            for (let i2 = 0; i2 < removed.length; ++i2)
              removed[i2].parent = null, removed[i2].transform && (removed[i2].transform._parentID = -1);
            this._boundsID++, this.onChildrenChange(beginIndex);
            for (let i2 = 0; i2 < removed.length; ++i2)
              removed[i2].emit("removed", this), this.emit("childRemoved", removed[i2], this, i2);
            return removed;
          } else if (range === 0 && this.children.length === 0)
            return [];
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        }
        sortChildren() {
          let sortRequired = false;
          for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
            const child = this.children[i2];
            child._lastSortedIndex = i2, !sortRequired && child.zIndex !== 0 && (sortRequired = true);
          }
          sortRequired && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = false;
        }
        updateTransform() {
          this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
          for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
            const child = this.children[i2];
            child.visible && child.updateTransform();
          }
        }
        calculateBounds() {
          this._bounds.clear(), this._calculateBounds();
          for (let i2 = 0; i2 < this.children.length; i2++) {
            const child = this.children[i2];
            if (!(!child.visible || !child.renderable))
              if (child.calculateBounds(), child._mask) {
                const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
                maskObject ? (maskObject.calculateBounds(), this._bounds.addBoundsMask(child._bounds, maskObject._bounds)) : this._bounds.addBounds(child._bounds);
              } else
                child.filterArea ? this._bounds.addBoundsArea(child._bounds, child.filterArea) : this._bounds.addBounds(child._bounds);
          }
          this._bounds.updateID = this._boundsID;
        }
        getLocalBounds(rect, skipChildrenUpdate = false) {
          const result = super.getLocalBounds(rect);
          if (!skipChildrenUpdate)
            for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
              const child = this.children[i2];
              child.visible && child.updateTransform();
            }
          return result;
        }
        _calculateBounds() {
        }
        _renderWithCulling(renderer) {
          const sourceFrame = renderer.renderTexture.sourceFrame;
          if (!(sourceFrame.width > 0 && sourceFrame.height > 0))
            return;
          let bounds, transform2;
          this.cullArea ? (bounds = this.cullArea, transform2 = this.worldTransform) : this._render !== _Container2.prototype._render && (bounds = this.getBounds(true));
          const projectionTransform = renderer.projection.transform;
          if (projectionTransform && (transform2 ? (transform2 = tempMatrix3.copyFrom(transform2), transform2.prepend(projectionTransform)) : transform2 = projectionTransform), bounds && sourceFrame.intersects(bounds, transform2))
            this._render(renderer);
          else if (this.cullArea)
            return;
          for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
            const child = this.children[i2], childCullable = child.cullable;
            child.cullable = childCullable || !this.cullArea, child.render(renderer), child.cullable = childCullable;
          }
        }
        render(renderer) {
          if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || this.filters?.length)
              this.renderAdvanced(renderer);
            else if (this.cullable)
              this._renderWithCulling(renderer);
            else {
              this._render(renderer);
              for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2)
                this.children[i2].render(renderer);
            }
        }
        renderAdvanced(renderer) {
          const filters2 = this.filters, mask = this._mask;
          if (filters2) {
            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
            for (let i2 = 0; i2 < filters2.length; i2++)
              filters2[i2].enabled && this._enabledFilters.push(filters2[i2]);
          }
          const flush = filters2 && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));
          if (flush && renderer.batch.flush(), filters2 && this._enabledFilters?.length && renderer.filter.push(this, this._enabledFilters), mask && renderer.mask.push(this, this._mask), this.cullable)
            this._renderWithCulling(renderer);
          else {
            this._render(renderer);
            for (let i2 = 0, j2 = this.children.length; i2 < j2; ++i2)
              this.children[i2].render(renderer);
          }
          flush && renderer.batch.flush(), mask && renderer.mask.pop(this), filters2 && this._enabledFilters?.length && renderer.filter.pop();
        }
        _render(_renderer) {
        }
        destroy(options) {
          super.destroy(), this.sortDirty = false;
          const destroyChildren = typeof options == "boolean" ? options : options?.children, oldChildren = this.removeChildren(0, this.children.length);
          if (destroyChildren)
            for (let i2 = 0; i2 < oldChildren.length; ++i2)
              oldChildren[i2].destroy(options);
        }
        get width() {
          return this.scale.x * this.getLocalBounds().width;
        }
        set width(value) {
          const width = this.getLocalBounds().width;
          width !== 0 ? this.scale.x = value / width : this.scale.x = 1, this._width = value;
        }
        get height() {
          return this.scale.y * this.getLocalBounds().height;
        }
        set height(value) {
          const height = this.getLocalBounds().height;
          height !== 0 ? this.scale.y = value / height : this.scale.y = 1, this._height = value;
        }
      };
      _Container.defaultSortableChildren = false;
      Container = _Container;
      Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
    }
  });

  // node_modules/@pixi/display/lib/settings.mjs
  var init_settings5 = __esm({
    "node_modules/@pixi/display/lib/settings.mjs"() {
      init_lib9();
      init_lib9();
      init_Container();
      Object.defineProperties(settings, {
        SORTABLE_CHILDREN: {
          get() {
            return Container.defaultSortableChildren;
          },
          set(value) {
            lib_exports.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), Container.defaultSortableChildren = value;
          }
        }
      });
    }
  });

  // node_modules/@pixi/display/lib/index.mjs
  var init_lib10 = __esm({
    "node_modules/@pixi/display/lib/index.mjs"() {
      init_settings5();
      init_Bounds();
      init_Container();
      init_DisplayObject();
    }
  });

  // node_modules/@pixi/sprite/lib/Sprite.mjs
  var tempPoint, indices, Sprite;
  var init_Sprite = __esm({
    "node_modules/@pixi/sprite/lib/Sprite.mjs"() {
      init_lib9();
      init_lib10();
      tempPoint = new Point();
      indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
      Sprite = class extends Container {
        constructor(texture) {
          super(), this._anchor = new ObservablePoint(
            this._onAnchorUpdate,
            this,
            texture ? texture.defaultAnchor.x : 0,
            texture ? texture.defaultAnchor.y : 0
          ), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new Color(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = BLEND_MODES.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = texture || Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = indices, this.pluginName = "batch", this.isSprite = true, this._roundPixels = settings.ROUND_PIXELS;
        }
        _onTextureUpdate() {
          this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = lib_exports.sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = lib_exports.sign(this.scale.y) * this._height / this._texture.orig.height);
        }
        _onAnchorUpdate() {
          this._transformID = -1, this._transformTrimmedID = -1;
        }
        calculateVertices() {
          const texture = this._texture;
          if (this._transformID === this.transform._worldID && this._textureID === texture._updateID)
            return;
          this._textureID !== texture._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = texture._updateID;
          const wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData, trim = texture.trim, orig = texture.orig, anchor = this._anchor;
          let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
          if (trim ? (w1 = trim.x - anchor._x * orig.width, w0 = w1 + trim.width, h1 = trim.y - anchor._y * orig.height, h0 = h1 + trim.height) : (w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height), vertexData[0] = a2 * w1 + c2 * h1 + tx, vertexData[1] = d2 * h1 + b2 * w1 + ty, vertexData[2] = a2 * w0 + c2 * h1 + tx, vertexData[3] = d2 * h1 + b2 * w0 + ty, vertexData[4] = a2 * w0 + c2 * h0 + tx, vertexData[5] = d2 * h0 + b2 * w0 + ty, vertexData[6] = a2 * w1 + c2 * h0 + tx, vertexData[7] = d2 * h0 + b2 * w1 + ty, this._roundPixels) {
            const resolution = settings.RESOLUTION;
            for (let i2 = 0; i2 < vertexData.length; ++i2)
              vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
          }
        }
        calculateTrimmedVertices() {
          if (!this.vertexTrimmedData)
            this.vertexTrimmedData = new Float32Array(8);
          else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
            return;
          this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
          const texture = this._texture, vertexData = this.vertexTrimmedData, orig = texture.orig, anchor = this._anchor, wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, w1 = -anchor._x * orig.width, w0 = w1 + orig.width, h1 = -anchor._y * orig.height, h0 = h1 + orig.height;
          if (vertexData[0] = a2 * w1 + c2 * h1 + tx, vertexData[1] = d2 * h1 + b2 * w1 + ty, vertexData[2] = a2 * w0 + c2 * h1 + tx, vertexData[3] = d2 * h1 + b2 * w0 + ty, vertexData[4] = a2 * w0 + c2 * h0 + tx, vertexData[5] = d2 * h0 + b2 * w0 + ty, vertexData[6] = a2 * w1 + c2 * h0 + tx, vertexData[7] = d2 * h0 + b2 * w1 + ty, this._roundPixels) {
            const resolution = settings.RESOLUTION;
            for (let i2 = 0; i2 < vertexData.length; ++i2)
              vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
          }
        }
        _render(renderer) {
          this.calculateVertices(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this);
        }
        _calculateBounds() {
          const trim = this._texture.trim, orig = this._texture.orig;
          !trim || trim.width === orig.width && trim.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
        }
        getLocalBounds(rect) {
          return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), rect = this._localBoundsRect), this._localBounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);
        }
        containsPoint(point) {
          this.worldTransform.applyInverse(point, tempPoint);
          const width = this._texture.orig.width, height = this._texture.orig.height, x1 = -width * this.anchor.x;
          let y1 = 0;
          return tempPoint.x >= x1 && tempPoint.x < x1 + width && (y1 = -height * this.anchor.y, tempPoint.y >= y1 && tempPoint.y < y1 + height);
        }
        destroy(options) {
          if (super.destroy(options), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof options == "boolean" ? options : options?.texture) {
            const destroyBaseTexture = typeof options == "boolean" ? options : options?.baseTexture;
            this._texture.destroy(!!destroyBaseTexture);
          }
          this._texture = null;
        }
        static from(source2, options) {
          const texture = source2 instanceof Texture ? source2 : Texture.from(source2, options);
          return new Sprite(texture);
        }
        set roundPixels(value) {
          this._roundPixels !== value && (this._transformID = -1, this._transformTrimmedID = -1), this._roundPixels = value;
        }
        get roundPixels() {
          return this._roundPixels;
        }
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value) {
          const s2 = lib_exports.sign(this.scale.x) || 1;
          this.scale.x = s2 * value / this._texture.orig.width, this._width = value;
        }
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value) {
          const s2 = lib_exports.sign(this.scale.y) || 1;
          this.scale.y = s2 * value / this._texture.orig.height, this._height = value;
        }
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          this._anchor.copyFrom(value);
        }
        get tint() {
          return this._tintColor.value;
        }
        set tint(value) {
          this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber();
        }
        get tintValue() {
          return this._tintColor.toNumber();
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          this._texture !== value && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = value || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once("update", this._onTextureUpdate, this)));
        }
      };
    }
  });

  // node_modules/@pixi/sprite/lib/index.mjs
  var init_lib11 = __esm({
    "node_modules/@pixi/sprite/lib/index.mjs"() {
      init_Sprite();
    }
  });

  // node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs
  var _tempMatrix, CacheData;
  var init_lib12 = __esm({
    "node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs"() {
      init_lib9();
      init_lib10();
      init_lib11();
      _tempMatrix = new Matrix();
      DisplayObject.prototype._cacheAsBitmap = false;
      DisplayObject.prototype._cacheData = null;
      DisplayObject.prototype._cacheAsBitmapResolution = null;
      DisplayObject.prototype._cacheAsBitmapMultisample = null;
      CacheData = class {
        constructor() {
          this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
        }
      };
      Object.defineProperties(DisplayObject.prototype, {
        cacheAsBitmapResolution: {
          get() {
            return this._cacheAsBitmapResolution;
          },
          set(resolution) {
            resolution !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = resolution, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
          }
        },
        cacheAsBitmapMultisample: {
          get() {
            return this._cacheAsBitmapMultisample;
          },
          set(multisample) {
            multisample !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = multisample, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
          }
        },
        cacheAsBitmap: {
          get() {
            return this._cacheAsBitmap;
          },
          set(value) {
            if (this._cacheAsBitmap === value)
              return;
            this._cacheAsBitmap = value;
            let data;
            value ? (this._cacheData || (this._cacheData = new CacheData()), data = this._cacheData, data.originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (data = this._cacheData, data.sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, this._mask = data.originalMask, this.filterArea = data.originalFilterArea);
          }
        }
      });
      DisplayObject.prototype._renderCached = function(renderer) {
        !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer));
      };
      DisplayObject.prototype._initCachedDisplayObject = function(renderer) {
        if (this._cacheData?.sprite)
          return;
        const cacheAlpha = this.alpha;
        this.alpha = 1, renderer.batch.flush();
        const bounds = this.getLocalBounds(new Rectangle(), true);
        if (this.filters?.length) {
          const padding = this.filters[0].padding;
          bounds.pad(padding);
        }
        const resolution = this.cacheAsBitmapResolution || renderer.resolution;
        bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);
        const cachedRenderTexture = renderer.renderTexture.current, cachedSourceFrame = renderer.renderTexture.sourceFrame.clone(), cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone(), cachedProjectionTransform = renderer.projection.transform, renderTexture = RenderTexture.create({
          width: bounds.width,
          height: bounds.height,
          resolution,
          multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
        }), textureCacheId = `cacheAsBitmap_${lib_exports.uid()}`;
        this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId);
        const m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
        this.render = this._cacheData.originalRender, renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false }), renderer.framebuffer.blit(), renderer.projection.transform = cachedProjectionTransform, renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;
        const cachedSprite = new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
      };
      DisplayObject.prototype._renderCachedCanvas = function(renderer) {
        !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer));
      };
      DisplayObject.prototype._initCachedDisplayObjectCanvas = function(renderer) {
        if (this._cacheData?.sprite)
          return;
        const bounds = this.getLocalBounds(new Rectangle(), true), cacheAlpha = this.alpha;
        this.alpha = 1;
        const cachedRenderTarget = renderer.canvasContext.activeContext, cachedProjectionTransform = renderer._projTransform, resolution = this.cacheAsBitmapResolution || renderer.resolution;
        bounds.ceil(resolution), bounds.width = Math.max(bounds.width, 1 / resolution), bounds.height = Math.max(bounds.height, 1 / resolution);
        const renderTexture = RenderTexture.create({
          width: bounds.width,
          height: bounds.height,
          resolution
        }), textureCacheId = `cacheAsBitmap_${lib_exports.uid()}`;
        this._cacheData.textureCacheId = textureCacheId, BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId), Texture.addToCache(renderTexture, textureCacheId);
        const m2 = _tempMatrix;
        this.transform.localTransform.copyTo(m2), m2.invert(), m2.tx -= bounds.x, m2.ty -= bounds.y, this.renderCanvas = this._cacheData.originalRenderCanvas, renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false }), renderer.canvasContext.activeContext = cachedRenderTarget, renderer._projTransform = cachedProjectionTransform, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = cacheAlpha;
        const cachedSprite = new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform, cachedSprite.anchor.x = -(bounds.x / bounds.width), cachedSprite.anchor.y = -(bounds.y / bounds.height), cachedSprite.alpha = cacheAlpha, cachedSprite._bounds = this._bounds, this._cacheData.sprite = cachedSprite, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
      };
      DisplayObject.prototype._calculateCachedBounds = function() {
        this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
      };
      DisplayObject.prototype._getCachedLocalBounds = function() {
        return this._cacheData.sprite.getLocalBounds(null);
      };
      DisplayObject.prototype._destroyCachedDisplayObject = function() {
        this._cacheData.sprite._texture.destroy(true), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
      };
      DisplayObject.prototype._cacheAsBitmapDestroy = function(options) {
        this.cacheAsBitmap = false, this.destroy(options);
      };
    }
  });

  // node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs
  var init_lib13 = __esm({
    "node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs"() {
      init_lib10();
      DisplayObject.prototype.name = null;
      Container.prototype.getChildByName = function(name, deep) {
        for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++)
          if (this.children[i2].name === name)
            return this.children[i2];
        if (deep)
          for (let i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
            const child = this.children[i2];
            if (!child.getChildByName)
              continue;
            const target = child.getChildByName(name, true);
            if (target)
              return target;
          }
        return null;
      };
    }
  });

  // node_modules/@pixi/mixin-get-global-position/lib/index.mjs
  var init_lib14 = __esm({
    "node_modules/@pixi/mixin-get-global-position/lib/index.mjs"() {
      init_lib9();
      init_lib10();
      DisplayObject.prototype.getGlobalPosition = function(point = new Point(), skipUpdate = false) {
        return this.parent ? this.parent.toGlobal(this.position, point, skipUpdate) : (point.x = this.position.x, point.y = this.position.y), point;
      };
    }
  });

  // node_modules/@pixi/filter-alpha/lib/alpha.frag.mjs
  var fragment2;
  var init_alpha_frag = __esm({
    "node_modules/@pixi/filter-alpha/lib/alpha.frag.mjs"() {
      fragment2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
    }
  });

  // node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs
  var AlphaFilter;
  var init_AlphaFilter = __esm({
    "node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs"() {
      init_lib9();
      init_alpha_frag();
      AlphaFilter = class extends Filter {
        constructor(alpha = 1) {
          super(defaultVertex4, fragment2, { uAlpha: 1 }), this.alpha = alpha;
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(value) {
          this.uniforms.uAlpha = value;
        }
      };
    }
  });

  // node_modules/@pixi/filter-alpha/lib/index.mjs
  var init_lib15 = __esm({
    "node_modules/@pixi/filter-alpha/lib/index.mjs"() {
      init_AlphaFilter();
    }
  });

  // node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs
  function generateBlurFragSource(kernelSize) {
    const kernel = GAUSSIAN_VALUES[kernelSize], halfLength = kernel.length;
    let fragSource = fragTemplate2, blurLoop = "";
    const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let value;
    for (let i2 = 0; i2 < kernelSize; i2++) {
      let blur = template.replace("%index%", i2.toString());
      value = i2, i2 >= halfLength && (value = kernelSize - i2 - 1), blur = blur.replace("%value%", kernel[value].toString()), blurLoop += blur, blurLoop += `
`;
    }
    return fragSource = fragSource.replace("%blur%", blurLoop), fragSource = fragSource.replace("%size%", kernelSize.toString()), fragSource;
  }
  var GAUSSIAN_VALUES, fragTemplate2;
  var init_generateBlurFragSource = __esm({
    "node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs"() {
      GAUSSIAN_VALUES = {
        5: [0.153388, 0.221461, 0.250301],
        7: [0.071303, 0.131514, 0.189879, 0.214607],
        9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
        11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
        13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
        15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
      };
      fragTemplate2 = [
        "varying vec2 vBlurTexCoords[%size%];",
        "uniform sampler2D uSampler;",
        "void main(void)",
        "{",
        "    gl_FragColor = vec4(0.0);",
        "    %blur%",
        "}"
      ].join(`
`);
    }
  });

  // node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs
  function generateBlurVertSource(kernelSize, x2) {
    const halfLength = Math.ceil(kernelSize / 2);
    let vertSource = vertTemplate, blurLoop = "", template;
    x2 ? template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let i2 = 0; i2 < kernelSize; i2++) {
      let blur = template.replace("%index%", i2.toString());
      blur = blur.replace("%sampleIndex%", `${i2 - (halfLength - 1)}.0`), blurLoop += blur, blurLoop += `
`;
    }
    return vertSource = vertSource.replace("%blur%", blurLoop), vertSource = vertSource.replace("%size%", kernelSize.toString()), vertSource;
  }
  var vertTemplate;
  var init_generateBlurVertSource = __esm({
    "node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs"() {
      vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
    }
  });

  // node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs
  var BlurFilterPass;
  var init_BlurFilterPass = __esm({
    "node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs"() {
      init_lib9();
      init_generateBlurFragSource();
      init_generateBlurVertSource();
      BlurFilterPass = class extends Filter {
        constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
          const vertSrc = generateBlurVertSource(kernelSize, horizontal), fragSrc = generateBlurFragSource(kernelSize);
          super(
            vertSrc,
            fragSrc
          ), this.horizontal = horizontal, this.resolution = resolution, this._quality = 0, this.quality = quality, this.blur = strength;
        }
        apply(filterManager, input, output, clearMode) {
          if (output ? this.horizontal ? this.uniforms.strength = 1 / output.width * (output.width / input.width) : this.uniforms.strength = 1 / output.height * (output.height / input.height) : this.horizontal ? this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width) : this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
            filterManager.applyFilter(this, input, output, clearMode);
          else {
            const renderTarget = filterManager.getFilterTexture(), renderer = filterManager.renderer;
            let flip = input, flop = renderTarget;
            this.state.blend = false, filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
            for (let i2 = 1; i2 < this.passes - 1; i2++) {
              filterManager.bindAndClear(flip, CLEAR_MODES.BLIT), this.uniforms.uSampler = flop;
              const temp = flop;
              flop = flip, flip = temp, renderer.shader.bind(this), renderer.geometry.draw(5);
            }
            this.state.blend = true, filterManager.applyFilter(this, flop, output, clearMode), filterManager.returnFilterTexture(renderTarget);
          }
        }
        get blur() {
          return this.strength;
        }
        set blur(value) {
          this.padding = 1 + Math.abs(value) * 2, this.strength = value;
        }
        get quality() {
          return this._quality;
        }
        set quality(value) {
          this._quality = value, this.passes = value;
        }
      };
    }
  });

  // node_modules/@pixi/filter-blur/lib/BlurFilter.mjs
  var BlurFilter;
  var init_BlurFilter = __esm({
    "node_modules/@pixi/filter-blur/lib/BlurFilter.mjs"() {
      init_lib9();
      init_BlurFilterPass();
      BlurFilter = class extends Filter {
        constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {
          super(), this._repeatEdgePixels = false, this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize), this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize), this.resolution = resolution, this.quality = quality, this.blur = strength, this.repeatEdgePixels = false;
        }
        apply(filterManager, input, output, clearMode) {
          const xStrength = Math.abs(this.blurXFilter.strength), yStrength = Math.abs(this.blurYFilter.strength);
          if (xStrength && yStrength) {
            const renderTarget = filterManager.getFilterTexture();
            this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR), this.blurYFilter.apply(filterManager, renderTarget, output, clearMode), filterManager.returnFilterTexture(renderTarget);
          } else
            yStrength ? this.blurYFilter.apply(filterManager, input, output, clearMode) : this.blurXFilter.apply(filterManager, input, output, clearMode);
        }
        updatePadding() {
          this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
        get blur() {
          return this.blurXFilter.blur;
        }
        set blur(value) {
          this.blurXFilter.blur = this.blurYFilter.blur = value, this.updatePadding();
        }
        get quality() {
          return this.blurXFilter.quality;
        }
        set quality(value) {
          this.blurXFilter.quality = this.blurYFilter.quality = value;
        }
        get blurX() {
          return this.blurXFilter.blur;
        }
        set blurX(value) {
          this.blurXFilter.blur = value, this.updatePadding();
        }
        get blurY() {
          return this.blurYFilter.blur;
        }
        set blurY(value) {
          this.blurYFilter.blur = value, this.updatePadding();
        }
        get blendMode() {
          return this.blurYFilter.blendMode;
        }
        set blendMode(value) {
          this.blurYFilter.blendMode = value;
        }
        get repeatEdgePixels() {
          return this._repeatEdgePixels;
        }
        set repeatEdgePixels(value) {
          this._repeatEdgePixels = value, this.updatePadding();
        }
      };
    }
  });

  // node_modules/@pixi/filter-blur/lib/index.mjs
  var init_lib16 = __esm({
    "node_modules/@pixi/filter-blur/lib/index.mjs"() {
      init_BlurFilter();
      init_BlurFilterPass();
    }
  });

  // node_modules/@pixi/filter-color-matrix/lib/colorMatrix.frag.mjs
  var fragment3;
  var init_colorMatrix_frag = __esm({
    "node_modules/@pixi/filter-color-matrix/lib/colorMatrix.frag.mjs"() {
      fragment3 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
    }
  });

  // node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs
  var ColorMatrixFilter;
  var init_ColorMatrixFilter = __esm({
    "node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs"() {
      init_lib9();
      init_colorMatrix_frag();
      ColorMatrixFilter = class extends Filter {
        constructor() {
          const uniforms = {
            m: new Float32Array([
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ]),
            uAlpha: 1
          };
          super(defaultFilterVertex, fragment3, uniforms), this.alpha = 1;
        }
        _loadMatrix(matrix, multiply = false) {
          let newMatrix = matrix;
          multiply && (this._multiply(newMatrix, this.uniforms.m, matrix), newMatrix = this._colorMatrix(newMatrix)), this.uniforms.m = newMatrix;
        }
        _multiply(out2, a2, b2) {
          return out2[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15], out2[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16], out2[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17], out2[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18], out2[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4], out2[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15], out2[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16], out2[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17], out2[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18], out2[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9], out2[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15], out2[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16], out2[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17], out2[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18], out2[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14], out2[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15], out2[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16], out2[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17], out2[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18], out2[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19], out2;
        }
        _colorMatrix(matrix) {
          const m2 = new Float32Array(matrix);
          return m2[4] /= 255, m2[9] /= 255, m2[14] /= 255, m2[19] /= 255, m2;
        }
        brightness(b2, multiply) {
          const matrix = [
            b2,
            0,
            0,
            0,
            0,
            0,
            b2,
            0,
            0,
            0,
            0,
            0,
            b2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        tint(color, multiply) {
          const [r2, g2, b2] = Color.shared.setValue(color).toArray(), matrix = [
            r2,
            0,
            0,
            0,
            0,
            0,
            g2,
            0,
            0,
            0,
            0,
            0,
            b2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        greyscale(scale, multiply) {
          const matrix = [
            scale,
            scale,
            scale,
            0,
            0,
            scale,
            scale,
            scale,
            0,
            0,
            scale,
            scale,
            scale,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        blackAndWhite(multiply) {
          const matrix = [
            0.3,
            0.6,
            0.1,
            0,
            0,
            0.3,
            0.6,
            0.1,
            0,
            0,
            0.3,
            0.6,
            0.1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        hue(rotation, multiply) {
          rotation = (rotation || 0) / 180 * Math.PI;
          const cosR = Math.cos(rotation), sinR = Math.sin(rotation), sqrt = Math.sqrt, w2 = 1 / 3, sqrW = sqrt(w2), a00 = cosR + (1 - cosR) * w2, a01 = w2 * (1 - cosR) - sqrW * sinR, a02 = w2 * (1 - cosR) + sqrW * sinR, a10 = w2 * (1 - cosR) + sqrW * sinR, a11 = cosR + w2 * (1 - cosR), a12 = w2 * (1 - cosR) - sqrW * sinR, a20 = w2 * (1 - cosR) - sqrW * sinR, a21 = w2 * (1 - cosR) + sqrW * sinR, a22 = cosR + w2 * (1 - cosR), matrix = [
            a00,
            a01,
            a02,
            0,
            0,
            a10,
            a11,
            a12,
            0,
            0,
            a20,
            a21,
            a22,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        contrast(amount, multiply) {
          const v2 = (amount || 0) + 1, o2 = -0.5 * (v2 - 1), matrix = [
            v2,
            0,
            0,
            0,
            o2,
            0,
            v2,
            0,
            0,
            o2,
            0,
            0,
            v2,
            0,
            o2,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        saturate(amount = 0, multiply) {
          const x2 = amount * 2 / 3 + 1, y2 = (x2 - 1) * -0.5, matrix = [
            x2,
            y2,
            y2,
            0,
            0,
            y2,
            x2,
            y2,
            0,
            0,
            y2,
            y2,
            x2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        desaturate() {
          this.saturate(-1);
        }
        negative(multiply) {
          const matrix = [
            -1,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            -1,
            1,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        sepia(multiply) {
          const matrix = [
            0.393,
            0.7689999,
            0.18899999,
            0,
            0,
            0.349,
            0.6859999,
            0.16799999,
            0,
            0,
            0.272,
            0.5339999,
            0.13099999,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        technicolor(multiply) {
          const matrix = [
            1.9125277891456083,
            -0.8545344976951645,
            -0.09155508482755585,
            0,
            11.793603434377337,
            -0.3087833385928097,
            1.7658908555458428,
            -0.10601743074722245,
            0,
            -70.35205161461398,
            -0.231103377548616,
            -0.7501899197440212,
            1.847597816108189,
            0,
            30.950940869491138,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        polaroid(multiply) {
          const matrix = [
            1.438,
            -0.062,
            -0.062,
            0,
            0,
            -0.122,
            1.378,
            -0.122,
            0,
            0,
            -0.016,
            -0.016,
            1.483,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        toBGR(multiply) {
          const matrix = [
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        kodachrome(multiply) {
          const matrix = [
            1.1285582396593525,
            -0.3967382283601348,
            -0.03992559172921793,
            0,
            63.72958762196502,
            -0.16404339962244616,
            1.0835251566291304,
            -0.05498805115633132,
            0,
            24.732407896706203,
            -0.16786010706155763,
            -0.5603416277695248,
            1.6014850761964943,
            0,
            35.62982807460946,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        browni(multiply) {
          const matrix = [
            0.5997023498159715,
            0.34553243048391263,
            -0.2708298674538042,
            0,
            47.43192855600873,
            -0.037703249837783157,
            0.8609577587992641,
            0.15059552388459913,
            0,
            -36.96841498319127,
            0.24113635128153335,
            -0.07441037908422492,
            0.44972182064877153,
            0,
            -7.562075277591283,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        vintage(multiply) {
          const matrix = [
            0.6279345635605994,
            0.3202183420819367,
            -0.03965408211312453,
            0,
            9.651285835294123,
            0.02578397704808868,
            0.6441188644374771,
            0.03259127616149294,
            0,
            7.462829176470591,
            0.0466055556782719,
            -0.0851232987247891,
            0.5241648018700465,
            0,
            5.159190588235296,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        colorTone(desaturation, toned, lightColor, darkColor, multiply) {
          desaturation = desaturation || 0.2, toned = toned || 0.15, lightColor = lightColor || 16770432, darkColor = darkColor || 3375104;
          const temp = Color.shared, [lR, lG, lB] = temp.setValue(lightColor).toArray(), [dR, dG, dB] = temp.setValue(darkColor).toArray(), matrix = [
            0.3,
            0.59,
            0.11,
            0,
            0,
            lR,
            lG,
            lB,
            desaturation,
            0,
            dR,
            dG,
            dB,
            toned,
            0,
            lR - dR,
            lG - dG,
            lB - dB,
            0,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        night(intensity, multiply) {
          intensity = intensity || 0.1;
          const matrix = [
            intensity * -2,
            -intensity,
            0,
            0,
            0,
            -intensity,
            0,
            intensity,
            0,
            0,
            0,
            intensity,
            intensity * 2,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        predator(amount, multiply) {
          const matrix = [
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        lsd(multiply) {
          const matrix = [
            2,
            -0.4,
            0.5,
            0,
            0,
            -0.5,
            2,
            -0.4,
            0,
            0,
            -0.4,
            -0.5,
            3,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, multiply);
        }
        reset() {
          const matrix = [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ];
          this._loadMatrix(matrix, false);
        }
        get matrix() {
          return this.uniforms.m;
        }
        set matrix(value) {
          this.uniforms.m = value;
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(value) {
          this.uniforms.uAlpha = value;
        }
      };
      ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
    }
  });

  // node_modules/@pixi/filter-color-matrix/lib/index.mjs
  var init_lib17 = __esm({
    "node_modules/@pixi/filter-color-matrix/lib/index.mjs"() {
      init_ColorMatrixFilter();
    }
  });

  // node_modules/@pixi/filter-displacement/lib/displacement.frag.mjs
  var fragment4;
  var init_displacement_frag = __esm({
    "node_modules/@pixi/filter-displacement/lib/displacement.frag.mjs"() {
      fragment4 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`;
    }
  });

  // node_modules/@pixi/filter-displacement/lib/displacement.vert.mjs
  var vertex2;
  var init_displacement_vert = __esm({
    "node_modules/@pixi/filter-displacement/lib/displacement.vert.mjs"() {
      vertex2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
    }
  });

  // node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs
  var DisplacementFilter;
  var init_DisplacementFilter = __esm({
    "node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs"() {
      init_lib9();
      init_displacement_frag();
      init_displacement_vert();
      DisplacementFilter = class extends Filter {
        constructor(sprite, scale) {
          const maskMatrix = new Matrix();
          sprite.renderable = false, super(vertex2, fragment4, {
            mapSampler: sprite._texture,
            filterMatrix: maskMatrix,
            scale: { x: 1, y: 1 },
            rotation: new Float32Array([1, 0, 0, 1])
          }), this.maskSprite = sprite, this.maskMatrix = maskMatrix, scale == null && (scale = 20), this.scale = new Point(scale, scale);
        }
        apply(filterManager, input, output, clearMode) {
          this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
          const wt = this.maskSprite.worldTransform, lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b), lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
          lenX !== 0 && lenY !== 0 && (this.uniforms.rotation[0] = wt.a / lenX, this.uniforms.rotation[1] = wt.b / lenX, this.uniforms.rotation[2] = wt.c / lenY, this.uniforms.rotation[3] = wt.d / lenY), filterManager.applyFilter(this, input, output, clearMode);
        }
        get map() {
          return this.uniforms.mapSampler;
        }
        set map(value) {
          this.uniforms.mapSampler = value;
        }
      };
    }
  });

  // node_modules/@pixi/filter-displacement/lib/index.mjs
  var init_lib18 = __esm({
    "node_modules/@pixi/filter-displacement/lib/index.mjs"() {
      init_DisplacementFilter();
    }
  });

  // node_modules/@pixi/filter-fxaa/lib/fxaa.frag.mjs
  var fragment5;
  var init_fxaa_frag = __esm({
    "node_modules/@pixi/filter-fxaa/lib/fxaa.frag.mjs"() {
      fragment5 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
    }
  });

  // node_modules/@pixi/filter-fxaa/lib/fxaa.vert.mjs
  var vertex3;
  var init_fxaa_vert = __esm({
    "node_modules/@pixi/filter-fxaa/lib/fxaa.vert.mjs"() {
      vertex3 = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
    }
  });

  // node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs
  var FXAAFilter;
  var init_FXAAFilter = __esm({
    "node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs"() {
      init_lib9();
      init_fxaa_frag();
      init_fxaa_vert();
      FXAAFilter = class extends Filter {
        constructor() {
          super(vertex3, fragment5);
        }
      };
    }
  });

  // node_modules/@pixi/filter-fxaa/lib/index.mjs
  var init_lib19 = __esm({
    "node_modules/@pixi/filter-fxaa/lib/index.mjs"() {
      init_FXAAFilter();
    }
  });

  // node_modules/@pixi/filter-noise/lib/noise.frag.mjs
  var fragment6;
  var init_noise_frag = __esm({
    "node_modules/@pixi/filter-noise/lib/noise.frag.mjs"() {
      fragment6 = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
    }
  });

  // node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs
  var NoiseFilter;
  var init_NoiseFilter = __esm({
    "node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs"() {
      init_lib9();
      init_noise_frag();
      NoiseFilter = class extends Filter {
        constructor(noise = 0.5, seed = Math.random()) {
          super(defaultFilterVertex, fragment6, {
            uNoise: 0,
            uSeed: 0
          }), this.noise = noise, this.seed = seed;
        }
        get noise() {
          return this.uniforms.uNoise;
        }
        set noise(value) {
          this.uniforms.uNoise = value;
        }
        get seed() {
          return this.uniforms.uSeed;
        }
        set seed(value) {
          this.uniforms.uSeed = value;
        }
      };
    }
  });

  // node_modules/@pixi/filter-noise/lib/index.mjs
  var init_lib20 = __esm({
    "node_modules/@pixi/filter-noise/lib/index.mjs"() {
      init_NoiseFilter();
    }
  });

  // node_modules/pixi-v7/lib/filters.mjs
  var filters;
  var init_filters = __esm({
    "node_modules/pixi-v7/lib/filters.mjs"() {
      init_lib9();
      init_lib15();
      init_lib16();
      init_lib17();
      init_lib18();
      init_lib19();
      init_lib20();
      filters = {
        AlphaFilter,
        BlurFilter,
        BlurFilterPass,
        ColorMatrixFilter,
        DisplacementFilter,
        FXAAFilter,
        NoiseFilter
      };
      Object.entries(filters).forEach(([key, FilterClass]) => {
        Object.defineProperty(filters, key, {
          get() {
            return lib_exports.deprecation("7.1.0", `filters.${key} has moved to ${key}`), FilterClass;
          }
        });
      });
    }
  });

  // node_modules/@pixi/events/lib/EventTicker.mjs
  var EventsTickerClass, EventsTicker;
  var init_EventTicker = __esm({
    "node_modules/@pixi/events/lib/EventTicker.mjs"() {
      init_lib9();
      EventsTickerClass = class {
        constructor() {
          this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this.tickerAdded = false, this._pauseUpdate = true;
        }
        init(events) {
          this.removeTickerListener(), this.events = events, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = false, this.tickerAdded = false, this._pauseUpdate = true;
        }
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused) {
          this._pauseUpdate = paused;
        }
        addTickerListener() {
          this.tickerAdded || !this.domElement || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = true);
        }
        removeTickerListener() {
          this.tickerAdded && (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = false);
        }
        pointerMoved() {
          this._didMove = true;
        }
        update() {
          if (!this.domElement || this._pauseUpdate)
            return;
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events.rootPointerEvent;
          this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY
          }));
        }
        tickerUpdate(deltaTime) {
          this._deltaTime += deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
        }
      };
      EventsTicker = new EventsTickerClass();
    }
  });

  // node_modules/@pixi/events/lib/FederatedEvent.mjs
  var FederatedEvent;
  var init_FederatedEvent = __esm({
    "node_modules/@pixi/events/lib/FederatedEvent.mjs"() {
      init_lib9();
      FederatedEvent = class {
        constructor(manager) {
          this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = new Point(), this.page = new Point(), this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
        }
        get layerX() {
          return this.layer.x;
        }
        get layerY() {
          return this.layer.y;
        }
        get pageX() {
          return this.page.x;
        }
        get pageY() {
          return this.page.y;
        }
        get data() {
          return this;
        }
        composedPath() {
          return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
        }
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        preventDefault() {
          this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
        }
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // node_modules/@pixi/events/lib/FederatedMouseEvent.mjs
  var FederatedMouseEvent;
  var init_FederatedMouseEvent = __esm({
    "node_modules/@pixi/events/lib/FederatedMouseEvent.mjs"() {
      init_lib9();
      init_FederatedEvent();
      FederatedMouseEvent = class extends FederatedEvent {
        constructor() {
          super(...arguments), this.client = new Point(), this.movement = new Point(), this.offset = new Point(), this.global = new Point(), this.screen = new Point();
        }
        get clientX() {
          return this.client.x;
        }
        get clientY() {
          return this.client.y;
        }
        get x() {
          return this.clientX;
        }
        get y() {
          return this.clientY;
        }
        get movementX() {
          return this.movement.x;
        }
        get movementY() {
          return this.movement.y;
        }
        get offsetX() {
          return this.offset.x;
        }
        get offsetY() {
          return this.offset.y;
        }
        get globalX() {
          return this.global.x;
        }
        get globalY() {
          return this.global.y;
        }
        get screenX() {
          return this.screen.x;
        }
        get screenY() {
          return this.screen.y;
        }
        getLocalPosition(displayObject, point, globalPos) {
          return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
        }
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // node_modules/@pixi/events/lib/FederatedPointerEvent.mjs
  var FederatedPointerEvent;
  var init_FederatedPointerEvent = __esm({
    "node_modules/@pixi/events/lib/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedPointerEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
        }
        getCoalescedEvents() {
          return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [];
        }
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // node_modules/@pixi/events/lib/FederatedWheelEvent.mjs
  var FederatedWheelEvent;
  var init_FederatedWheelEvent = __esm({
    "node_modules/@pixi/events/lib/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent();
      FederatedWheelEvent = class extends FederatedMouseEvent {
        constructor() {
          super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;
    }
  });

  // node_modules/@pixi/events/lib/EventBoundary.mjs
  var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
  var init_EventBoundary = __esm({
    "node_modules/@pixi/events/lib/EventBoundary.mjs"() {
      init_lib9();
      init_EventTicker();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      PROPAGATION_LIMIT = 2048;
      tempHitLocation = new Point();
      tempLocalMapping = new Point();
      EventBoundary = class {
        constructor(rootTarget) {
          this.dispatch = new lib_exports.EventEmitter(), this.moveOnAll = false, this.enableGlobalMoveEvents = true, this.mappingState = {
            trackingData: {}
          }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = false, this.rootTarget = rootTarget, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel);
        }
        addEventMapping(type, fn) {
          this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
            fn,
            priority: 0
          }), this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        dispatchEvent(e2, type) {
          e2.propagationStopped = false, e2.propagationImmediatelyStopped = false, this.propagate(e2, type), this.dispatch.emit(type || e2.type, e2);
        }
        mapEvent(e2) {
          if (!this.rootTarget)
            return;
          const mappers = this.mappingTable[e2.type];
          if (mappers)
            for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++)
              mappers[i2].fn(e2);
          else
            console.warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
        }
        hitTest(x2, y2) {
          EventsTicker.pauseUpdate = true;
          const fn = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        propagate(e2, type) {
          if (!e2.target)
            return;
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++)
            if (e2.currentTarget = composedPath[i2], this.notifyTarget(e2, type), e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          if (e2.eventPhase = e2.AT_TARGET, e2.currentTarget = e2.target, this.notifyTarget(e2, type), !(e2.propagationStopped || e2.propagationImmediatelyStopped)) {
            e2.eventPhase = e2.BUBBLING_PHASE;
            for (let i2 = composedPath.length - 2; i2 >= 0; i2--)
              if (e2.currentTarget = composedPath[i2], this.notifyTarget(e2, type), e2.propagationStopped || e2.propagationImmediatelyStopped)
                return;
          }
        }
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i2 = targets.length - 1; i2 >= 0; i2--)
            events.forEach((event) => {
              e2.currentTarget = targets[i2], this.notifyTarget(e2, event);
            });
        }
        propagationPath(target) {
          const propagationPath = [target];
          for (let i2 = 0; i2 < PROPAGATION_LIMIT && target !== this.rootTarget; i2++) {
            if (!target.parent)
              throw new Error("Cannot find propagation path to disconnected target");
            propagationPath.push(target.parent), target = target.parent;
          }
          return propagationPath.reverse(), propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventsTicker.pauseUpdate = false), currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              const child = children[i2], nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)
                  continue;
                const isInteractive = currentTarget.isInteractive();
                (nestedHit.length > 0 || isInteractive) && (isInteractive && this._allInteractiveElements.push(currentTarget), nestedHit.push(currentTarget)), this._hitElements.length === 0 && (this._hitElements = nestedHit), shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();
          return isInteractiveTarget && isInteractiveTarget && this._allInteractiveElements.push(currentTarget), ignore || this._hitElements.length > 0 ? null : shouldReturn ? this._hitElements : isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;
        }
        hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))
            return null;
          if ((currentTarget.eventMode === "dynamic" || eventMode === "dynamic") && (EventsTicker.pauseUpdate = false), currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              const child = children[i2], nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)
                  continue;
                const isInteractive = currentTarget.isInteractive();
                return (nestedHit.length > 0 || isInteractive) && nestedHit.push(currentTarget), nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();
          return isInteractiveMode && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(displayObject) {
          return !!(!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable || displayObject.eventMode === "none" || displayObject.eventMode === "passive" && !displayObject.interactiveChildren || displayObject.isMask);
        }
        hitPruneFn(displayObject, location) {
          if (displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)))
            return true;
          if (displayObject._mask) {
            const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
            if (maskObject && !maskObject.containsPoint?.(location))
              return true;
          }
          return false;
        }
        hitTestFn(displayObject, location) {
          return displayObject.eventMode === "passive" ? false : displayObject.hitArea ? true : displayObject.containsPoint ? displayObject.containsPoint(location) : false;
        }
        notifyTarget(e2, type) {
          type = type ?? e2.type;
          const handlerKey = `on${type}`;
          e2.currentTarget[handlerKey]?.(e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this.notifyListeners(e2, key), e2.eventPhase === e2.AT_TARGET && this.notifyListeners(e2, type);
        }
        mapPointerDown(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from);
          if (this.dispatchEvent(e2, "pointerdown"), e2.pointerType === "touch")
            this.dispatchEvent(e2, "touchstart");
          else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e2.composedPath(), this.freeEvent(e2);
        }
        mapPointerMove(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen", trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget);
            if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
              for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e2.composedPath().includes(leaveEvent.target); )
                leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e2.target; )
              overTargetAncestor = overTargetAncestor.parent;
            if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; )
                enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [], allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove"), allowGlobalPointerEvents && allMethods.push("globalpointermove"), e2.pointerType === "touch" && (this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove"), allowGlobalPointerEvents && allMethods.push("globaltouchmove")), isMouse && (this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove"), allowGlobalPointerEvents && allMethods.push("globalmousemove"), this.cursor = e2.target?.cursor), allMethods.length > 0 && this.all(e2, allMethods), this._allInteractiveElements.length = 0, this._hitElements.length = 0, trackingData.overTargets = e2.composedPath(), this.freeEvent(e2);
        }
        mapPointerOver(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId), e2 = this.createPointerEvent(from), isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover"), isMouse && this.dispatchEvent(e2, "mouseover"), e2.pointerType === "mouse" && (this.cursor = e2.target?.cursor);
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )
            enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
          trackingData.overTargets = e2.composedPath(), this.freeEvent(e2), this.freeEvent(enterEvent);
        }
        mapPointerOut(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen", outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )
              leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
            trackingData.overTargets = null, this.freeEvent(outEvent), this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        mapPointerUp(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now = performance.now(), e2 = this.createPointerEvent(from);
          if (this.dispatchEvent(e2, "pointerup"), e2.pointerType === "touch")
            this.dispatchEvent(e2, "touchend");
          else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            for (; currentTarget && !e2.composedPath().includes(currentTarget); ) {
              if (e2.currentTarget = currentTarget, this.notifyTarget(e2, "pointerupoutside"), e2.pointerType === "touch")
                this.notifyTarget(e2, "touchendoutside");
              else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget, clickEvent.path = null, trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            });
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else
              clickEvent.pointerType === "touch" && this.dispatchEvent(clickEvent, "tap");
            this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        mapPointerUpOutside(from) {
          if (!(from instanceof FederatedPointerEvent)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e2 = this.createPointerEvent(from);
          if (pressTarget) {
            let currentTarget = pressTarget;
            for (; currentTarget; )
              e2.currentTarget = currentTarget, this.notifyTarget(e2, "pointerupoutside"), e2.pointerType === "touch" ? this.notifyTarget(e2, "touchendoutside") : (e2.pointerType === "mouse" || e2.pointerType === "pen") && this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
            delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e2);
        }
        mapWheel(from) {
          if (!(from instanceof FederatedWheelEvent)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from);
          this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
        }
        findMountedTarget(propagationPath) {
          if (!propagationPath)
            return null;
          let currentTarget = propagationPath[0];
          for (let i2 = 1; i2 < propagationPath.length && propagationPath[i2].parent === currentTarget; i2++)
            currentTarget = propagationPath[i2];
          return currentTarget;
        }
        createPointerEvent(from, type, target) {
          const event = this.allocateEvent(FederatedPointerEvent);
          return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], typeof type == "string" && (event.type = type), event;
        }
        createWheelEvent(from) {
          const event = this.allocateEvent(FederatedWheelEvent);
          return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = this.hitTest(event.global.x, event.global.y), event;
        }
        clonePointerEvent(from, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = type ?? event.type, event;
        }
        copyWheelData(from, to) {
          to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
        }
        copyPointerData(from, to) {
          from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
        }
        copyMouseData(from, to) {
          from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), to.ctrlKey = from.ctrlKey, to.metaKey = from.metaKey, to.movement.copyFrom(from.movement), to.screen.copyFrom(from.screen), to.shiftKey = from.shiftKey, to.global.copyFrom(from.global));
        }
        copyData(from, to) {
          to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = performance.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);
        }
        trackingData(id) {
          return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          }), this.mappingState.trackingData[id];
        }
        allocateEvent(constructor) {
          this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          return event.eventPhase = event.NONE, event.currentTarget = null, event.path = null, event.target = null, event;
        }
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          this.eventPool.has(constructor) || this.eventPool.set(constructor, []), this.eventPool.get(constructor).push(event);
        }
        notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (listeners && e2.currentTarget.isInteractive())
            if ("fn" in listeners)
              listeners.once && e2.currentTarget.removeListener(type, listeners.fn, void 0, true), listeners.fn.call(listeners.context, e2);
            else
              for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++)
                listeners[i2].once && e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true), listeners[i2].fn.call(listeners[i2].context, e2);
        }
      };
    }
  });

  // node_modules/@pixi/events/lib/EventSystem.mjs
  var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
  var init_EventSystem = __esm({
    "node_modules/@pixi/events/lib/EventSystem.mjs"() {
      init_lib9();
      init_EventBoundary();
      init_EventTicker();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
      MOUSE_POINTER_ID = 1;
      TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem = class _EventSystem2 {
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = renderer, this.rootBoundary = new EventBoundary(null), EventsTicker.init(this), this.autoPreventDefault = true, this.eventsAdded = false, this.rootPointerEvent = new FederatedPointerEvent(null), this.rootWheelEvent = new FederatedWheelEvent(null), this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          }, this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
            set: (target, key, value) => (key === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = value), target[key] = value, true)
          }), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this);
        }
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        init(options) {
          const { view, resolution } = this.renderer;
          this.setTargetElement(view), this.resolution = resolution, _EventSystem2._defaultEventMode = options.eventMode ?? "auto", Object.assign(this.features, options.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        destroy() {
          this.setTargetElement(null), this.renderer = null;
        }
        setCursor(mode) {
          mode = mode || "default";
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (applyStyles = false), this.currentCursor === mode)
            return;
          this.currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style)
            switch (typeof style) {
              case "string":
                applyStyles && (this.domElement.style.cursor = style);
                break;
              case "function":
                style(mode);
                break;
              case "object":
                applyStyles && Object.assign(this.domElement.style, style);
                break;
            }
          else
            applyStyles && typeof mode == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode) && (this.domElement.style.cursor = mode);
        }
        get pointer() {
          return this.rootPointerEvent;
        }
        onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this.normalizeToPointerData(nativeEvent);
          this.autoPreventDefault && events[0].isNormalized && (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
          for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
            const nativeEvent2 = events[i2], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, EventsTicker.pointerMoved();
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target = nativeEvent.target;
          nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
          const outside = target !== this.domElement ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
            event.type += outside, this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(wheelEvent);
        }
        setTargetElement(element) {
          this.removeEvents(), this.domElement = element, EventsTicker.domElement = element, this.addEvents();
        }
        addEvents() {
          if (this.eventsAdded || !this.domElement)
            return;
          EventsTicker.addTickerListener();
          const style = this.domElement.style;
          style && (globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "none", style.msTouchAction = "none") : this.supportsPointerEvents && (style.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, true), this.domElement.addEventListener("pointerdown", this.onPointerDown, true), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true), this.domElement.addEventListener("pointerover", this.onPointerOverOut, true), globalThis.addEventListener("pointerup", this.onPointerUp, true)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, true), this.domElement.addEventListener("mousedown", this.onPointerDown, true), this.domElement.addEventListener("mouseout", this.onPointerOverOut, true), this.domElement.addEventListener("mouseover", this.onPointerOverOut, true), globalThis.addEventListener("mouseup", this.onPointerUp, true), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, true), this.domElement.addEventListener("touchend", this.onPointerUp, true), this.domElement.addEventListener("touchmove", this.onPointerMove, true))), this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          }), this.eventsAdded = true;
        }
        removeEvents() {
          if (!this.eventsAdded || !this.domElement)
            return;
          EventsTicker.removeTickerListener();
          const style = this.domElement.style;
          globalThis.navigator.msPointerEnabled ? (style.msContentZooming = "", style.msTouchAction = "") : this.supportsPointerEvents && (style.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, true), this.domElement.removeEventListener("pointerdown", this.onPointerDown, true), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true), globalThis.removeEventListener("pointerup", this.onPointerUp, true)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, true), this.domElement.removeEventListener("mousedown", this.onPointerDown, true), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true), globalThis.removeEventListener("mouseup", this.onPointerUp, true), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, true), this.domElement.removeEventListener("touchend", this.onPointerUp, true), this.domElement.removeEventListener("touchmove", this.onPointerMove, true))), this.domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this.eventsAdded = false;
        }
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          }, resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier, point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent)
            for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
              const touch = event.changedTouches[i2];
              typeof touch.button > "u" && (touch.button = 0), typeof touch.buttons > "u" && (touch.buttons = 1), typeof touch.isPrimary > "u" && (touch.isPrimary = event.touches.length === 1 && event.type === "touchstart"), typeof touch.width > "u" && (touch.width = touch.radiusX || 1), typeof touch.height > "u" && (touch.height = touch.radiusY || 1), typeof touch.tiltX > "u" && (touch.tiltX = 0), typeof touch.tiltY > "u" && (touch.tiltY = 0), typeof touch.pointerType > "u" && (touch.pointerType = "touch"), typeof touch.pointerId > "u" && (touch.pointerId = touch.identifier || 0), typeof touch.pressure > "u" && (touch.pressure = touch.force || 0.5), typeof touch.twist > "u" && (touch.twist = 0), typeof touch.tangentialPressure > "u" && (touch.tangentialPressure = 0), typeof touch.layerX > "u" && (touch.layerX = touch.offsetX = touch.clientX), typeof touch.layerY > "u" && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = true, touch.type = event.type, normalizedEvents.push(touch);
            }
          else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            typeof tempEvent.isPrimary > "u" && (tempEvent.isPrimary = true), typeof tempEvent.width > "u" && (tempEvent.width = 1), typeof tempEvent.height > "u" && (tempEvent.height = 1), typeof tempEvent.tiltX > "u" && (tempEvent.tiltX = 0), typeof tempEvent.tiltY > "u" && (tempEvent.tiltY = 0), typeof tempEvent.pointerType > "u" && (tempEvent.pointerType = "mouse"), typeof tempEvent.pointerId > "u" && (tempEvent.pointerId = MOUSE_POINTER_ID), typeof tempEvent.pressure > "u" && (tempEvent.pressure = 0.5), typeof tempEvent.twist > "u" && (tempEvent.twist = 0), typeof tempEvent.tangentialPressure > "u" && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = true, normalizedEvents.push(tempEvent);
          } else
            normalizedEvents.push(event);
          return normalizedEvents;
        }
        normalizeWheelEvent(nativeEvent) {
          const event = this.rootWheelEvent;
          return this.transferMouseData(event, nativeEvent), event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ, event.deltaMode = nativeEvent.deltaMode, this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
        }
        bootstrapEvent(event, nativeEvent) {
          return event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent), this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY), event.global.copyFrom(event.screen), event.offset.copyFrom(event.screen), event.isTrusted = nativeEvent.isTrusted, event.type === "pointerleave" && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
        }
        transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = performance.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null, event.shiftKey = nativeEvent.shiftKey;
        }
      };
      _EventSystem.extension = {
        name: "events",
        type: [
          ExtensionType.RendererSystem,
          ExtensionType.CanvasRendererSystem
        ]
      }, _EventSystem.defaultEventFeatures = {
        move: true,
        globalMove: true,
        click: true,
        wheel: true
      };
      EventSystem = _EventSystem;
      extensions.add(EventSystem);
    }
  });

  // node_modules/@pixi/events/lib/FederatedEventTarget.mjs
  function convertEventModeToInteractiveMode(mode) {
    return mode === "dynamic" || mode === "static";
  }
  var FederatedDisplayObject;
  var init_FederatedEventTarget = __esm({
    "node_modules/@pixi/events/lib/FederatedEventTarget.mjs"() {
      init_lib9();
      init_lib10();
      init_EventSystem();
      init_FederatedEvent();
      FederatedDisplayObject = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        _internalInteractive: void 0,
        get interactive() {
          return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);
        },
        set interactive(value) {
          lib_exports.deprecation(
            "7.2.0",
            "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."
          ), this._internalInteractive = value, this.eventMode = value ? "static" : "auto";
        },
        _internalEventMode: void 0,
        get eventMode() {
          return this._internalEventMode ?? EventSystem.defaultEventMode;
        },
        set eventMode(value) {
          this._internalInteractive = convertEventModeToInteractiveMode(value), this._internalEventMode = value;
        },
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        interactiveChildren: true,
        hitArea: null,
        addEventListener(type, listener, options) {
          const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context3 = typeof listener == "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type, listener = typeof listener == "function" ? listener : listener.handleEvent, this.on(type, listener, context3);
        },
        removeEventListener(type, listener, options) {
          const capture = typeof options == "boolean" && options || typeof options == "object" && options.capture, context3 = typeof listener == "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type, listener = typeof listener == "function" ? listener : listener.handleEvent, this.off(type, listener, context3);
        },
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent))
            throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
          return e2.defaultPrevented = false, e2.path = null, e2.target = this, e2.manager.dispatchEvent(e2), !e2.defaultPrevented;
        }
      };
      DisplayObject.mixin(FederatedDisplayObject);
    }
  });

  // node_modules/@pixi/events/lib/index.mjs
  var init_lib21 = __esm({
    "node_modules/@pixi/events/lib/index.mjs"() {
      init_EventBoundary();
      init_EventSystem();
      init_FederatedEvent();
      init_FederatedEventTarget();
      init_FederatedMouseEvent();
      init_FederatedPointerEvent();
      init_FederatedWheelEvent();
    }
  });

  // node_modules/@pixi/accessibility/lib/accessibleTarget.mjs
  var accessibleTarget;
  var init_accessibleTarget = __esm({
    "node_modules/@pixi/accessibility/lib/accessibleTarget.mjs"() {
      accessibleTarget = {
        accessible: false,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        _accessibleActive: false,
        _accessibleDiv: null,
        accessibleType: "button",
        accessiblePointerEvents: "auto",
        accessibleChildren: true,
        renderId: -1
      };
    }
  });

  // node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs
  var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilityManager;
  var init_AccessibilityManager = __esm({
    "node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs"() {
      init_lib9();
      init_lib10();
      init_lib21();
      init_accessibleTarget();
      DisplayObject.mixin(accessibleTarget);
      KEY_CODE_TAB = 9;
      DIV_TOUCH_SIZE = 100;
      DIV_TOUCH_POS_X = 0;
      DIV_TOUCH_POS_Y = 0;
      DIV_TOUCH_ZINDEX = 2;
      DIV_HOOK_SIZE = 1;
      DIV_HOOK_POS_X = -1e3;
      DIV_HOOK_POS_Y = -1e3;
      DIV_HOOK_ZINDEX = 2;
      AccessibilityManager = class {
        constructor(renderer) {
          this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (lib_exports.isMobile.tablet || lib_exports.isMobile.phone) && this.createTouchHook();
          const div = document.createElement("div");
          div.style.width = `${DIV_TOUCH_SIZE}px`, div.style.height = `${DIV_TOUCH_SIZE}px`, div.style.position = "absolute", div.style.top = `${DIV_TOUCH_POS_X}px`, div.style.left = `${DIV_TOUCH_POS_Y}px`, div.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = div, this.renderer = renderer, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        get isActive() {
          return this._isActive;
        }
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE}px`, hookDiv.style.height = `${DIV_HOOK_SIZE}px`, hookDiv.style.position = "absolute", hookDiv.style.top = `${DIV_HOOK_POS_X}px`, hookDiv.style.left = `${DIV_HOOK_POS_Y}px`, hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString(), hookDiv.style.backgroundColor = "#FF0000", hookDiv.title = "select to enable accessibility for this content", hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true, this.activate(), this.destroyTouchHook();
          }), document.body.appendChild(hookDiv), this._hookDiv = hookDiv;
        }
        destroyTouchHook() {
          this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
        }
        activate() {
          this._isActive || (this._isActive = true, globalThis.document.addEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown, false), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode?.appendChild(this.div));
        }
        deactivate() {
          !this._isActive || this._isMobileAccessibility || (this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.addEventListener("keydown", this._onKeyDown, false), this.renderer.off("postrender", this.update), this.div.parentNode?.removeChild(this.div));
        }
        updateAccessibleObjects(displayObject) {
          if (!displayObject.visible || !displayObject.accessibleChildren)
            return;
          displayObject.accessible && displayObject.isInteractive() && (displayObject._accessibleActive || this.addChild(displayObject), displayObject.renderId = this.renderId);
          const children = displayObject.children;
          if (children)
            for (let i2 = 0; i2 < children.length; i2++)
              this.updateAccessibleObjects(children[i2]);
        }
        update() {
          const now = performance.now();
          if (lib_exports.isMobile.android.device && now < this.androidUpdateCount || (this.androidUpdateCount = now + this.androidUpdateFrequency, !this.renderer.renderingToScreen))
            return;
          this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
          const { x: x2, y: y2, width, height } = this.renderer.view.getBoundingClientRect(), { width: viewWidth, height: viewHeight, resolution } = this.renderer, sx = width / viewWidth * resolution, sy = height / viewHeight * resolution;
          let div = this.div;
          div.style.left = `${x2}px`, div.style.top = `${y2}px`, div.style.width = `${viewWidth}px`, div.style.height = `${viewHeight}px`;
          for (let i2 = 0; i2 < this.children.length; i2++) {
            const child = this.children[i2];
            if (child.renderId !== this.renderId)
              child._accessibleActive = false, lib_exports.removeItems(this.children, i2, 1), this.div.removeChild(child._accessibleDiv), this.pool.push(child._accessibleDiv), child._accessibleDiv = null, i2--;
            else {
              div = child._accessibleDiv;
              let hitArea = child.hitArea;
              const wt = child.worldTransform;
              child.hitArea ? (div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`, div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`, div.style.width = `${hitArea.width * wt.a * sx}px`, div.style.height = `${hitArea.height * wt.d * sy}px`) : (hitArea = child.getBounds(), this.capHitArea(hitArea), div.style.left = `${hitArea.x * sx}px`, div.style.top = `${hitArea.y * sy}px`, div.style.width = `${hitArea.width * sx}px`, div.style.height = `${hitArea.height * sy}px`, div.title !== child.accessibleTitle && child.accessibleTitle !== null && (div.title = child.accessibleTitle), div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null && div.setAttribute("aria-label", child.accessibleHint)), (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) && (div.title = child.accessibleTitle, div.tabIndex = child.tabIndex, this.debug && this.updateDebugHTML(div));
            }
          }
          this.renderId++;
        }
        updateDebugHTML(div) {
          div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
        }
        capHitArea(hitArea) {
          hitArea.x < 0 && (hitArea.width += hitArea.x, hitArea.x = 0), hitArea.y < 0 && (hitArea.height += hitArea.y, hitArea.y = 0);
          const { width: viewWidth, height: viewHeight } = this.renderer;
          hitArea.x + hitArea.width > viewWidth && (hitArea.width = viewWidth - hitArea.x), hitArea.y + hitArea.height > viewHeight && (hitArea.height = viewHeight - hitArea.y);
        }
        addChild(displayObject) {
          let div = this.pool.pop();
          div || (div = document.createElement("button"), div.style.width = `${DIV_TOUCH_SIZE}px`, div.style.height = `${DIV_TOUCH_SIZE}px`, div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", div.style.position = "absolute", div.style.zIndex = DIV_TOUCH_ZINDEX.toString(), div.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? div.setAttribute("aria-live", "off") : div.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? div.setAttribute("aria-relevant", "additions") : div.setAttribute("aria-relevant", "text"), div.addEventListener("click", this._onClick.bind(this)), div.addEventListener("focus", this._onFocus.bind(this)), div.addEventListener("focusout", this._onFocusOut.bind(this))), div.style.pointerEvents = displayObject.accessiblePointerEvents, div.type = displayObject.accessibleType, displayObject.accessibleTitle && displayObject.accessibleTitle !== null ? div.title = displayObject.accessibleTitle : (!displayObject.accessibleHint || displayObject.accessibleHint === null) && (div.title = `displayObject ${displayObject.tabIndex}`), displayObject.accessibleHint && displayObject.accessibleHint !== null && div.setAttribute("aria-label", displayObject.accessibleHint), this.debug && this.updateDebugHTML(div), displayObject._accessibleActive = true, displayObject._accessibleDiv = div, div.displayObject = displayObject, this.children.push(displayObject), this.div.appendChild(displayObject._accessibleDiv), displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
        }
        _dispatchEvent(e2, type) {
          const { displayObject: target } = e2.target, boundry = this.renderer.events.rootBoundary, event = Object.assign(new FederatedEvent(boundry), { target });
          boundry.rootTarget = this.renderer.lastObjectRendered, type.forEach((type2) => boundry.dispatchEvent(event, type2));
        }
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        _onFocus(e2) {
          e2.target.getAttribute("aria-live") || e2.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e2, ["mouseover"]);
        }
        _onFocusOut(e2) {
          e2.target.getAttribute("aria-live") || e2.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e2, ["mouseout"]);
        }
        _onKeyDown(e2) {
          e2.keyCode === KEY_CODE_TAB && this.activate();
        }
        _onMouseMove(e2) {
          e2.movementX === 0 && e2.movementY === 0 || this.deactivate();
        }
        destroy() {
          this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
        }
      };
      AccessibilityManager.extension = {
        name: "accessibility",
        type: [
          ExtensionType.RendererPlugin,
          ExtensionType.CanvasRendererPlugin
        ]
      };
      extensions.add(AccessibilityManager);
    }
  });

  // node_modules/@pixi/accessibility/lib/index.mjs
  var init_lib22 = __esm({
    "node_modules/@pixi/accessibility/lib/index.mjs"() {
      init_AccessibilityManager();
      init_accessibleTarget();
    }
  });

  // node_modules/@pixi/app/lib/Application.mjs
  var _Application, Application;
  var init_Application = __esm({
    "node_modules/@pixi/app/lib/Application.mjs"() {
      init_lib9();
      init_lib10();
      _Application = class _Application2 {
        constructor(options) {
          this.stage = new Container(), options = Object.assign({
            forceCanvas: false
          }, options), this.renderer = autoDetectRenderer(options), _Application2._plugins.forEach((plugin) => {
            plugin.init.call(this, options);
          });
        }
        render() {
          this.renderer.render(this.stage);
        }
        get view() {
          return this.renderer?.view;
        }
        get screen() {
          return this.renderer?.screen;
        }
        destroy(removeView, stageOptions) {
          const plugins = _Application2._plugins.slice(0);
          plugins.reverse(), plugins.forEach((plugin) => {
            plugin.destroy.call(this);
          }), this.stage.destroy(stageOptions), this.stage = null, this.renderer.destroy(removeView), this.renderer = null;
        }
      };
      _Application._plugins = [];
      Application = _Application;
      extensions.handleByList(ExtensionType.Application, Application._plugins);
    }
  });

  // node_modules/@pixi/app/lib/ResizePlugin.mjs
  var ResizePlugin;
  var init_ResizePlugin = __esm({
    "node_modules/@pixi/app/lib/ResizePlugin.mjs"() {
      init_lib9();
      ResizePlugin = class {
        static init(options) {
          Object.defineProperty(
            this,
            "resizeTo",
            {
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = dom, dom && (globalThis.addEventListener("resize", this.queueResize), this.resize());
              },
              get() {
                return this._resizeTo;
              }
            }
          ), this.queueResize = () => {
            this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()));
          }, this.cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null);
          }, this.resize = () => {
            if (!this._resizeTo)
              return;
            this.cancelResize();
            let width, height;
            if (this._resizeTo === globalThis.window)
              width = globalThis.innerWidth, height = globalThis.innerHeight;
            else {
              const { clientWidth, clientHeight } = this._resizeTo;
              width = clientWidth, height = clientHeight;
            }
            this.renderer.resize(width, height), this.render();
          }, this._resizeId = null, this._resizeTo = null, this.resizeTo = options.resizeTo || null;
        }
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
        }
      };
      ResizePlugin.extension = ExtensionType.Application;
      extensions.add(ResizePlugin);
    }
  });

  // node_modules/@pixi/app/lib/index.mjs
  var init_lib23 = __esm({
    "node_modules/@pixi/app/lib/index.mjs"() {
      init_Application();
      init_ResizePlugin();
    }
  });

  // node_modules/@pixi/assets/lib/AssetExtension.mjs
  var assetKeyMap;
  var init_AssetExtension = __esm({
    "node_modules/@pixi/assets/lib/AssetExtension.mjs"() {
      init_lib9();
      assetKeyMap = {
        loader: ExtensionType.LoadParser,
        resolver: ExtensionType.ResolveParser,
        cache: ExtensionType.CacheParser,
        detection: ExtensionType.DetectionParser
      };
      extensions.handle(ExtensionType.Asset, (extension) => {
        const ref = extension.ref;
        Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
          ref[key],
          { extension: ref[key].extension ?? type }
        )));
      }, (extension) => {
        const ref = extension.ref;
        Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
      });
    }
  });

  // node_modules/@pixi/assets/lib/BackgroundLoader.mjs
  var BackgroundLoader;
  var init_BackgroundLoader = __esm({
    "node_modules/@pixi/assets/lib/BackgroundLoader.mjs"() {
      BackgroundLoader = class {
        constructor(loader, verbose = false) {
          this._loader = loader, this._assetList = [], this._isLoading = false, this._maxConcurrent = 1, this.verbose = verbose;
        }
        add(assetUrls) {
          assetUrls.forEach((a2) => {
            this._assetList.push(a2);
          }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
        }
        async _next() {
          if (this._assetList.length && this._isActive) {
            this._isLoading = true;
            const toLoad = [], toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i2 = 0; i2 < toLoadAmount; i2++)
              toLoad.push(this._assetList.pop());
            await this._loader.load(toLoad), this._isLoading = false, this._next();
          }
        }
        get active() {
          return this._isActive;
        }
        set active(value) {
          this._isActive !== value && (this._isActive = value, value && !this._isLoading && this._next());
        }
      };
    }
  });

  // node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs
  function checkDataUrl(url2, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes)
        if (url2.startsWith(`data:${mime}`))
          return true;
      return false;
    }
    return url2.startsWith(`data:${mimes}`);
  }
  var init_checkDataUrl = __esm({
    "node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs"() {
    }
  });

  // node_modules/@pixi/assets/lib/utils/checkExtension.mjs
  function checkExtension(url2, extension) {
    const tempURL = url2.split("?")[0], ext = lib_exports.path.extname(tempURL).toLowerCase();
    return Array.isArray(extension) ? extension.includes(ext) : ext === extension;
  }
  var init_checkExtension = __esm({
    "node_modules/@pixi/assets/lib/utils/checkExtension.mjs"() {
      init_lib9();
    }
  });

  // node_modules/@pixi/assets/lib/utils/convertToList.mjs
  var convertToList;
  var init_convertToList = __esm({
    "node_modules/@pixi/assets/lib/utils/convertToList.mjs"() {
      convertToList = (input, transform2, forceTransform = false) => (Array.isArray(input) || (input = [input]), transform2 ? input.map((item) => typeof item == "string" || forceTransform ? transform2(item) : item) : input);
    }
  });

  // node_modules/@pixi/assets/lib/utils/copySearchParams.mjs
  var copySearchParams;
  var init_copySearchParams = __esm({
    "node_modules/@pixi/assets/lib/utils/copySearchParams.mjs"() {
      copySearchParams = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        return searchParams && (targetUrl += `?${searchParams}`), targetUrl;
      };
    }
  });

  // node_modules/@pixi/assets/lib/utils/createStringVariations.mjs
  function processX(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i2 = 0; i2 < id.length; i2++) {
      const value = id[i2];
      depth < ids.length - 1 ? processX(base.replace(result[depth], value), ids, depth + 1, result, tags) : tags.push(base.replace(result[depth], value));
    }
  }
  function createStringVariations(string) {
    const regex = /\{(.*?)\}/g, result = string.match(regex), tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      }), processX(string, ids, 0, result, tags);
    } else
      tags.push(string);
    return tags;
  }
  var init_createStringVariations = __esm({
    "node_modules/@pixi/assets/lib/utils/createStringVariations.mjs"() {
    }
  });

  // node_modules/@pixi/assets/lib/utils/isSingleItem.mjs
  var isSingleItem;
  var init_isSingleItem = __esm({
    "node_modules/@pixi/assets/lib/utils/isSingleItem.mjs"() {
      isSingleItem = (item) => !Array.isArray(item);
    }
  });

  // node_modules/@pixi/assets/lib/utils/index.mjs
  var init_utils2 = __esm({
    "node_modules/@pixi/assets/lib/utils/index.mjs"() {
      init_checkDataUrl();
      init_checkExtension();
      init_convertToList();
      init_copySearchParams();
      init_createStringVariations();
      init_isSingleItem();
    }
  });

  // node_modules/@pixi/assets/lib/cache/Cache.mjs
  var CacheClass, Cache;
  var init_Cache = __esm({
    "node_modules/@pixi/assets/lib/cache/Cache.mjs"() {
      init_lib9();
      init_utils2();
      init_convertToList();
      CacheClass = class {
        constructor() {
          this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
        }
        reset() {
          this._cacheMap.clear(), this._cache.clear();
        }
        has(key) {
          return this._cache.has(key);
        }
        get(key) {
          const result = this._cache.get(key);
          return result || console.warn(`[Assets] Asset id ${key} was not found in the Cache`), result;
        }
        set(key, value) {
          const keys = convertToList(key);
          let cacheableAssets;
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parser = this.parsers[i2];
            if (parser.test(value)) {
              cacheableAssets = parser.getCacheableAssets(keys, value);
              break;
            }
          }
          cacheableAssets || (cacheableAssets = {}, keys.forEach((key2) => {
            cacheableAssets[key2] = value;
          }));
          const cacheKeys = Object.keys(cacheableAssets), cachedAssets = {
            cacheKeys,
            keys
          };
          if (keys.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          }), cacheKeys.forEach((key2) => {
            this._cache.has(key2) && this._cache.get(key2) !== value && console.warn("[Cache] already has key:", key2), this._cache.set(key2, cacheableAssets[key2]);
          }), value instanceof Texture) {
            const texture = value;
            keys.forEach((key2) => {
              texture.baseTexture !== Texture.EMPTY.baseTexture && BaseTexture.addToCache(texture.baseTexture, key2), Texture.addToCache(texture, key2);
            });
          }
        }
        remove(key) {
          if (!this._cacheMap.has(key)) {
            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          cacheMap2.cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          }), cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        get parsers() {
          return this._parsers;
        }
      };
      Cache = new CacheClass();
    }
  });

  // node_modules/@pixi/assets/lib/loader/Loader.mjs
  var Loader;
  var init_Loader = __esm({
    "node_modules/@pixi/assets/lib/loader/Loader.mjs"() {
      init_lib9();
      init_utils2();
      init_isSingleItem();
      init_convertToList();
      Loader = class {
        constructor() {
          this._parsers = [], this._parsersValidated = false, this.parsers = new Proxy(this._parsers, {
            set: (target, key, value) => (this._parsersValidated = false, target[key] = value, true)
          }), this.promiseCache = {};
        }
        reset() {
          this._parsersValidated = false, this.promiseCache = {};
        }
        _getLoadPromiseAndParser(url2, data) {
          const result = {
            promise: null,
            parser: null
          };
          return result.promise = (async () => {
            let asset = null, parser = null;
            if (data.loadParser && (parser = this._parserHash[data.loadParser], parser || console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`)), !parser) {
              for (let i2 = 0; i2 < this.parsers.length; i2++) {
                const parserX = this.parsers[i2];
                if (parserX.load && parserX.test?.(url2, data, this)) {
                  parser = parserX;
                  break;
                }
              }
              if (!parser)
                return console.warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
            }
            asset = await parser.load(url2, data, this), result.parser = parser;
            for (let i2 = 0; i2 < this.parsers.length; i2++) {
              const parser2 = this.parsers[i2];
              parser2.parse && parser2.parse && await parser2.testParse?.(asset, data, this) && (asset = await parser2.parse(asset, data, this) || asset, result.parser = parser2);
            }
            return asset;
          })(), result;
        }
        async load(assetsToLoadIn, onProgress) {
          this._parsersValidated || this._validateParsers();
          let count2 = 0;
          const assets = {}, singleAsset = isSingleItem(assetsToLoadIn), assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
            alias: [item],
            src: item
          })), total = assetsToLoad.length, promises = assetsToLoad.map(async (asset) => {
            const url2 = lib_exports.path.toAbsolute(asset.src);
            if (!assets[asset.src])
              try {
                this.promiseCache[url2] || (this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset)), assets[asset.src] = await this.promiseCache[url2].promise, onProgress && onProgress(++count2 / total);
              } catch (e2) {
                throw delete this.promiseCache[url2], delete assets[asset.src], new Error(`[Loader.load] Failed to load ${url2}.
${e2}`);
              }
          });
          return await Promise.all(promises), singleAsset ? assets[assetsToLoad[0].src] : assets;
        }
        async unload(assetsToUnloadIn) {
          const promises = convertToList(assetsToUnloadIn, (item) => ({
            alias: [item],
            src: item
          })).map(async (asset) => {
            const url2 = lib_exports.path.toAbsolute(asset.src), loadPromise = this.promiseCache[url2];
            if (loadPromise) {
              const loadedAsset = await loadPromise.promise;
              delete this.promiseCache[url2], loadPromise.parser?.unload?.(loadedAsset, asset, this);
            }
          });
          await Promise.all(promises);
        }
        _validateParsers() {
          this._parsersValidated = true, this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => (hash[parser.name] && console.warn(`[Assets] loadParser name conflict "${parser.name}"`), { ...hash, [parser.name]: parser }), {});
        }
      };
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority;
  var init_LoaderParser = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs"() {
      LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority22) => (LoaderParserPriority22[LoaderParserPriority22.Low = 0] = "Low", LoaderParserPriority22[LoaderParserPriority22.Normal = 1] = "Normal", LoaderParserPriority22[LoaderParserPriority22.High = 2] = "High", LoaderParserPriority22))(LoaderParserPriority || {});
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs
  var validJSONExtension, validJSONMIME, loadJson;
  var init_loadJson = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs"() {
      init_lib9();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validJSONExtension = ".json";
      validJSONMIME = "application/json";
      loadJson = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadJson",
        test(url2) {
          return checkDataUrl(url2, validJSONMIME) || checkExtension(url2, validJSONExtension);
        },
        async load(url2) {
          return await (await settings.ADAPTER.fetch(url2)).json();
        }
      };
      extensions.add(loadJson);
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs
  var validTXTExtension, validTXTMIME, loadTxt;
  var init_loadTxt = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs"() {
      init_lib9();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validTXTExtension = ".txt";
      validTXTMIME = "text/plain";
      loadTxt = {
        name: "loadTxt",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        test(url2) {
          return checkDataUrl(url2, validTXTMIME) || checkExtension(url2, validTXTExtension);
        },
        async load(url2) {
          return await (await settings.ADAPTER.fetch(url2)).text();
        }
      };
      extensions.add(loadTxt);
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs
  function getFontFamilyName(url2) {
    const ext = lib_exports.path.extname(url2), nameTokens = lib_exports.path.basename(url2, ext).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens)
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        valid = false;
        break;
      }
    let fontFamilyName = nameTokens.join(" ");
    return valid || (fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`), fontFamilyName;
  }
  var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, loadWebFont;
  var init_loadWebFont = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs"() {
      init_lib9();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      validWeights = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
      validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
      validFontMIMEs = [
        "font/ttf",
        "font/otf",
        "font/woff",
        "font/woff2"
      ];
      CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
      loadWebFont = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Low
        },
        name: "loadWebFont",
        test(url2) {
          return checkDataUrl(url2, validFontMIMEs) || checkExtension(url2, validFontExtensions);
        },
        async load(url2, options) {
          const fonts = settings.ADAPTER.getFontFaceSet();
          if (fonts) {
            const fontFaces = [], name = options.data?.family ?? getFontFamilyName(url2), weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"], data = options.data ?? {};
            for (let i2 = 0; i2 < weights.length; i2++) {
              const weight = weights[i2], font = new FontFace(name, `url(${encodeURI(url2)})`, {
                ...data,
                weight
              });
              await font.load(), fonts.add(font), fontFaces.push(font);
            }
            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
          }
          return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
        },
        unload(font) {
          (Array.isArray(font) ? font : [font]).forEach((t2) => settings.ADAPTER.getFontFaceSet().delete(t2));
        }
      };
      extensions.add(loadWebFont);
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs
  var UUID, MAX_WORKERS, WHITE_PNG, checkImageBitmapCode, workerCode, workerURL, WorkerManagerClass, WorkerManager;
  var init_WorkerManager = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs"() {
      UUID = 0;
      WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
      checkImageBitmapCode = {
        id: "checkImageBitmap",
        code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
      };
      workerCode = {
        id: "loadImageBitmap",
        code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
      };
      WorkerManagerClass = class {
        constructor() {
          this._initialized = false, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {};
        }
        isImageBitmapSupported() {
          return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((resolve2) => {
            const workerURL2 = URL.createObjectURL(new Blob(
              [checkImageBitmapCode.code],
              { type: "application/javascript" }
            )), worker = new Worker(workerURL2);
            worker.addEventListener("message", (event) => {
              worker.terminate(), URL.revokeObjectURL(workerURL2), resolve2(event.data);
            });
          }), this._isImageBitmapSupported);
        }
        loadImageBitmap(src) {
          return this._run("loadImageBitmap", [src]);
        }
        async _initWorkers() {
          this._initialized || (this._initialized = true);
        }
        getWorker() {
          MAX_WORKERS === void 0 && (MAX_WORKERS = navigator.hardwareConcurrency || 4);
          let worker = this.workerPool.pop();
          return !worker && this._createdWorkers < MAX_WORKERS && (workerURL || (workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }))), this._createdWorkers++, worker = new Worker(workerURL), worker.addEventListener("message", (event) => {
            this.complete(event.data), this.returnWorker(event.target), this.next();
          })), worker;
        }
        returnWorker(worker) {
          this.workerPool.push(worker);
        }
        complete(data) {
          data.error !== void 0 ? this.resolveHash[data.uuid].reject(data.error) : this.resolveHash[data.uuid].resolve(data.data), this.resolveHash[data.uuid] = null;
        }
        async _run(id, args) {
          await this._initWorkers();
          const promise3 = new Promise((resolve2, reject) => {
            this.queue.push({ id, arguments: args, resolve: resolve2, reject });
          });
          return this.next(), promise3;
        }
        next() {
          if (!this.queue.length)
            return;
          const worker = this.getWorker();
          if (!worker)
            return;
          const toDo = this.queue.pop(), id = toDo.id;
          this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject }, worker.postMessage({
            data: toDo.arguments,
            uuid: UUID++,
            id
          });
        }
      };
      WorkerManager = new WorkerManagerClass();
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs
  function createTexture(base, loader, url2) {
    base.resource.internal = true;
    const texture = new Texture(base), unload = () => {
      delete loader.promiseCache[url2], Cache.has(url2) && Cache.remove(url2);
    };
    return texture.baseTexture.once("destroyed", () => {
      url2 in loader.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."), unload());
    }), texture.once("destroyed", () => {
      base.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), unload());
    }), texture;
  }
  var init_createTexture = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs"() {
      init_lib9();
      init_Cache();
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs
  async function loadImageBitmap(url2) {
    const response = await settings.ADAPTER.fetch(url2);
    if (!response.ok)
      throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
    const imageBlob = await response.blob();
    return await createImageBitmap(imageBlob);
  }
  var validImageExtensions, validImageMIMEs, loadTextures;
  var init_loadTextures = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs"() {
      init_lib9();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      init_WorkerManager();
      init_createTexture();
      validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
      validImageMIMEs = [
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif"
      ];
      loadTextures = {
        name: "loadTextures",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High
        },
        config: {
          preferWorkers: true,
          preferCreateImageBitmap: true,
          crossOrigin: "anonymous"
        },
        test(url2) {
          return checkDataUrl(url2, validImageMIMEs) || checkExtension(url2, validImageExtensions);
        },
        async load(url2, asset, loader) {
          const useImageBitmap = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
          let src;
          useImageBitmap ? this.config.preferWorkers && await WorkerManager.isImageBitmapSupported() ? src = await WorkerManager.loadImageBitmap(url2) : src = await loadImageBitmap(url2) : src = await new Promise((resolve2, reject) => {
            const src2 = new Image();
            src2.crossOrigin = this.config.crossOrigin, src2.src = url2, src2.complete ? resolve2(src2) : (src2.onload = () => resolve2(src2), src2.onerror = (e2) => reject(e2));
          });
          const options = { ...asset.data };
          options.resolution ?? (options.resolution = lib_exports.getResolutionOfUrl(url2)), useImageBitmap && options.resourceOptions?.ownsImageBitmap === void 0 && (options.resourceOptions = { ...options.resourceOptions }, options.resourceOptions.ownsImageBitmap = true);
          const base = new BaseTexture(src, options);
          return base.resource.src = url2, createTexture(base, loader, url2);
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
      extensions.add(loadTextures);
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs
  var validSVGExtension, validSVGMIME, loadSVG;
  var init_loadSVG = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs"() {
      init_lib9();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      init_loadTextures();
      init_createTexture();
      validSVGExtension = ".svg";
      validSVGMIME = "image/svg+xml";
      loadSVG = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High
        },
        name: "loadSVG",
        test(url2) {
          return checkDataUrl(url2, validSVGMIME) || checkExtension(url2, validSVGExtension);
        },
        async testParse(data) {
          return SVGResource.test(data);
        },
        async parse(asset, data, loader) {
          const src = new SVGResource(asset, data?.data?.resourceOptions);
          await src.load();
          const base = new BaseTexture(src, {
            resolution: lib_exports.getResolutionOfUrl(asset),
            ...data?.data
          });
          return base.resource.src = data.src, createTexture(base, loader, data.src);
        },
        async load(url2, _options) {
          return (await settings.ADAPTER.fetch(url2)).text();
        },
        unload: loadTextures.unload
      };
      extensions.add(loadSVG);
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.mjs
  var validVideoExtensions, validVideoMIMEs, loadVideo;
  var init_loadVideo = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/textures/loadVideo.mjs"() {
      init_lib9();
      init_checkDataUrl();
      init_checkExtension();
      init_LoaderParser();
      init_createTexture();
      validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogv"];
      validVideoMIMEs = [
        "video/mp4",
        "video/webm",
        "video/ogg"
      ];
      loadVideo = {
        name: "loadVideo",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High
        },
        config: {
          defaultAutoPlay: true
        },
        test(url2) {
          return checkDataUrl(url2, validVideoMIMEs) || checkExtension(url2, validVideoExtensions);
        },
        async load(url2, loadAsset, loader) {
          let texture;
          const blob = await (await settings.ADAPTER.fetch(url2)).blob(), blobURL = URL.createObjectURL(blob);
          try {
            const options = {
              autoPlay: this.config.defaultAutoPlay,
              ...loadAsset?.data?.resourceOptions
            }, src = new VideoResource(blobURL, options);
            await src.load();
            const base = new BaseTexture(src, {
              alphaMode: await lib_exports.detectVideoAlphaMode(),
              resolution: lib_exports.getResolutionOfUrl(url2),
              ...loadAsset?.data
            });
            base.resource.src = url2, texture = createTexture(base, loader, url2), texture.baseTexture.once("destroyed", () => {
              URL.revokeObjectURL(blobURL);
            });
          } catch (e2) {
            throw URL.revokeObjectURL(blobURL), e2;
          }
          return texture;
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
      extensions.add(loadVideo);
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs
  var init_utils3 = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs"() {
      init_createTexture();
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs
  var init_textures = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs"() {
      init_loadSVG();
      init_loadTextures();
      init_loadVideo();
      init_utils3();
    }
  });

  // node_modules/@pixi/assets/lib/loader/parsers/index.mjs
  var init_parsers = __esm({
    "node_modules/@pixi/assets/lib/loader/parsers/index.mjs"() {
      init_LoaderParser();
      init_loadJson();
      init_loadTxt();
      init_loadWebFont();
      init_textures();
    }
  });

  // node_modules/@pixi/assets/lib/resolver/Resolver.mjs
  var Resolver;
  var init_Resolver = __esm({
    "node_modules/@pixi/assets/lib/resolver/Resolver.mjs"() {
      init_lib9();
      init_convertToList();
      init_createStringVariations();
      init_isSingleItem();
      Resolver = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
        }
        setBundleIdentifier(bundleIdentifier) {
          if (this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector, this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer), prefer.priority || (prefer.priority = Object.keys(prefer.params));
          }), this._resolverHash = {};
        }
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        get parsers() {
          return this._parsers;
        }
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
        }
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams == "string")
            this._defaultSearchParams = searchParams;
          else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        getAlias(asset) {
          const { alias, name, src, srcs } = asset;
          return convertToList(
            alias || name || src || srcs,
            (value) => typeof value == "string" ? value : Array.isArray(value) ? value.map((v2) => v2?.src ?? v2?.srcs ?? v2) : value?.src || value?.srcs ? value.src ?? value.srcs : value,
            true
          );
        }
        addManifest(manifest) {
          this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = manifest, manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        addBundle(bundleId, assets) {
          const assetNames = [];
          Array.isArray(assets) ? assets.forEach((asset) => {
            const srcs = asset.src ?? asset.srcs, aliases = asset.alias ?? asset.name;
            let ids;
            if (typeof aliases == "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId), ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds), ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              alias: ids,
              src: srcs
            });
          }) : Object.keys(assets).forEach((key) => {
            const aliases = [key, this._createBundleAssetId(bundleId, key)];
            if (typeof assets[key] == "string")
              this.add({
                alias: aliases,
                src: assets[key]
              });
            else if (Array.isArray(assets[key]))
              this.add({
                alias: aliases,
                src: assets[key]
              });
            else {
              const asset = assets[key], assetSrc = asset.src ?? asset.srcs;
              this.add({
                ...asset,
                alias: aliases,
                src: Array.isArray(assetSrc) ? assetSrc : [assetSrc]
              });
            }
            assetNames.push(...aliases);
          }), this._bundles[bundleId] = assetNames;
        }
        add(aliases, srcs, data, format2, loadParser) {
          const assets = [];
          typeof aliases == "string" || Array.isArray(aliases) && typeof aliases[0] == "string" ? (lib_exports.deprecation("7.2.0", `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`), assets.push({ alias: aliases, src: srcs, data, format: format2, loadParser })) : Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);
          let keyCheck;
          keyCheck = (key) => {
            this.hasKey(key) && console.warn(`[Resolver] already has key: ${key} overwriting`);
          }, convertToList(assets).forEach((asset) => {
            const { src, srcs: srcs2 } = asset;
            let { data: data2, format: format22, loadParser: loadParser2 } = asset;
            const srcsToUse = convertToList(src || srcs2).map((src2) => typeof src2 == "string" ? createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]), aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs3) => {
              srcs3.forEach((src2) => {
                let formattedAsset = {};
                if (typeof src2 != "object") {
                  formattedAsset.src = src2;
                  for (let i2 = 0; i2 < this._parsers.length; i2++) {
                    const parser = this._parsers[i2];
                    if (parser.test(src2)) {
                      formattedAsset = parser.parse(src2);
                      break;
                    }
                  }
                } else
                  data2 = src2.data ?? data2, format22 = src2.format ?? format22, loadParser2 = src2.loadParser ?? loadParser2, formattedAsset = {
                    ...formattedAsset,
                    ...src2
                  };
                if (!aliasesToUse)
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                formattedAsset = this.buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data: data2,
                  format: format22,
                  loadParser: loadParser2
                }), resolvedAssets.push(formattedAsset);
              });
            }), aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem(bundleIds);
          bundleIds = convertToList(bundleIds);
          const out2 = {};
          return bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames), assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          }), singleAsset ? out2[bundleIds[0]] : out2;
        }
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key != "string") {
            const out2 = {};
            for (const i2 in result)
              out2[i2] = result[i2].src;
            return out2;
          }
          return result.src;
        }
        resolve(keys) {
          const singleAsset = isSingleItem(keys);
          keys = convertToList(keys);
          const result = {};
          return keys.forEach((key) => {
            if (!this._resolverHash[key])
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const bestAsset = assets[0], preferredOrder = this._getPreferredOrder(assets);
                preferredOrder?.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value) => {
                    const filteredAssets = assets.filter((asset) => asset[priorityKey] ? asset[priorityKey] === value : false);
                    filteredAssets.length && (assets = filteredAssets);
                  });
                }), this._resolverHash[key] = assets[0] ?? bestAsset;
              } else
                this._resolverHash[key] = this.buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
            result[key] = this._resolverHash[key];
          }), singleAsset ? result[keys[0]] : result;
        }
        hasKey(key) {
          return !!this._assetMap[key];
        }
        hasBundle(key) {
          return !!this._bundles[key];
        }
        _getPreferredOrder(assets) {
          for (let i2 = 0; i2 < assets.length; i2++) {
            const asset = assets[0], preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred)
              return preferred;
          }
          return this._preferredOrder[0];
        }
        _appendDefaultSearchParams(url2) {
          if (!this._defaultSearchParams)
            return url2;
          const paramConnector = /\?/.test(url2) ? "&" : "?";
          return `${url2}${paramConnector}${this._defaultSearchParams}`;
        }
        buildResolvedAsset(formattedAsset, data) {
          const { aliases, data: assetData, loadParser, format: format2 } = data;
          return (this._basePath || this._rootPath) && (formattedAsset.src = lib_exports.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath)), formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src], formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src), formattedAsset.data = { ...assetData || {}, ...formattedAsset.data }, formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser, formattedAsset.format = format2 ?? formattedAsset.src.split(".").pop(), formattedAsset.srcs = formattedAsset.src, formattedAsset.name = formattedAsset.alias, formattedAsset;
        }
      };
    }
  });

  // node_modules/@pixi/assets/lib/Assets.mjs
  var AssetsClass, Assets;
  var init_Assets = __esm({
    "node_modules/@pixi/assets/lib/Assets.mjs"() {
      init_lib9();
      init_BackgroundLoader();
      init_Cache();
      init_Loader();
      init_parsers();
      init_Resolver();
      init_convertToList();
      init_isSingleItem();
      init_loadTextures();
      AssetsClass = class {
        constructor() {
          this._detections = [], this._initialized = false, this.resolver = new Resolver(), this.loader = new Loader(), this.cache = Cache, this._backgroundLoader = new BackgroundLoader(this.loader), this._backgroundLoader.active = true, this.reset();
        }
        async init(options = {}) {
          if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return;
          }
          if (this._initialized = true, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {
            let manifest = options.manifest;
            typeof manifest == "string" && (manifest = await this.load(manifest)), this.resolver.addManifest(manifest);
          }
          const resolutionPref = options.texturePreference?.resolution ?? 1, resolution = typeof resolutionPref == "number" ? [resolutionPref] : resolutionPref, formats2 = await this._detectFormats({
            preferredFormats: options.texturePreference?.format,
            skipDetections: options.skipDetections,
            detections: this._detections
          });
          this.resolver.prefer({
            params: {
              format: formats2,
              resolution
            }
          }), options.preferences && this.setPreferences(options.preferences);
        }
        add(aliases, srcs, data, format2, loadParser) {
          this.resolver.add(aliases, srcs, data, format2, loadParser);
        }
        async load(urls, onProgress) {
          this._initialized || await this.init();
          const singleAsset = isSingleItem(urls), urlArray = convertToList(urls).map((url2) => {
            if (typeof url2 != "string") {
              const aliases = this.resolver.getAlias(url2);
              return aliases.some((alias) => !this.resolver.hasKey(alias)) && this.add(url2), Array.isArray(aliases) ? aliases[0] : aliases;
            }
            return this.resolver.hasKey(url2) || this.add({ alias: url2, src: url2 }), url2;
          }), resolveResults = this.resolver.resolve(urlArray), out2 = await this._mapLoadToResolve(resolveResults, onProgress);
          return singleAsset ? out2[urlArray[0]] : out2;
        }
        addBundle(bundleId, assets) {
          this.resolver.addBundle(bundleId, assets);
        }
        async loadBundle(bundleIds, onProgress) {
          this._initialized || await this.init();
          let singleAsset = false;
          typeof bundleIds == "string" && (singleAsset = true, bundleIds = [bundleIds]);
          const resolveResults = this.resolver.resolveBundle(bundleIds), out2 = {}, keys = Object.keys(resolveResults);
          let count2 = 0, total = 0;
          const _onProgress = () => {
            onProgress?.(++count2 / total);
          }, promises = keys.map((bundleId) => {
            const resolveResult = resolveResults[bundleId];
            return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
              out2[bundleId] = resolveResult2;
            });
          });
          return await Promise.all(promises), singleAsset ? out2[bundleIds[0]] : out2;
        }
        async backgroundLoad(urls) {
          this._initialized || await this.init(), typeof urls == "string" && (urls = [urls]);
          const resolveResults = this.resolver.resolve(urls);
          this._backgroundLoader.add(Object.values(resolveResults));
        }
        async backgroundLoadBundle(bundleIds) {
          this._initialized || await this.init(), typeof bundleIds == "string" && (bundleIds = [bundleIds]);
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          Object.values(resolveResults).forEach((resolveResult) => {
            this._backgroundLoader.add(Object.values(resolveResult));
          });
        }
        reset() {
          this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = false;
        }
        get(keys) {
          if (typeof keys == "string")
            return Cache.get(keys);
          const assets = {};
          for (let i2 = 0; i2 < keys.length; i2++)
            assets[i2] = Cache.get(keys[i2]);
          return assets;
        }
        async _mapLoadToResolve(resolveResults, onProgress) {
          const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);
          this._backgroundLoader.active = false;
          const loadedAssets = await this.loader.load(resolveArray, onProgress);
          this._backgroundLoader.active = true;
          const out2 = {};
          return resolveArray.forEach((resolveResult, i2) => {
            const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];
            resolveResult.alias && keys.push(...resolveResult.alias), out2[resolveKeys[i2]] = asset, Cache.set(keys, asset);
          }), out2;
        }
        async unload(urls) {
          this._initialized || await this.init();
          const urlArray = convertToList(urls).map((url2) => typeof url2 != "string" ? url2.src : url2), resolveResults = this.resolver.resolve(urlArray);
          await this._unloadFromResolved(resolveResults);
        }
        async unloadBundle(bundleIds) {
          this._initialized || await this.init(), bundleIds = convertToList(bundleIds);
          const resolveResults = this.resolver.resolveBundle(bundleIds), promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
          await Promise.all(promises);
        }
        async _unloadFromResolved(resolveResult) {
          const resolveArray = Object.values(resolveResult);
          resolveArray.forEach((resolveResult2) => {
            Cache.remove(resolveResult2.src);
          }), await this.loader.unload(resolveArray);
        }
        async _detectFormats(options) {
          let formats2 = [];
          options.preferredFormats && (formats2 = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);
          for (const detection of options.detections)
            options.skipDetections || await detection.test() ? formats2 = await detection.add(formats2) : options.skipDetections || (formats2 = await detection.remove(formats2));
          return formats2 = formats2.filter((format2, index) => formats2.indexOf(format2) === index), formats2;
        }
        get detections() {
          return this._detections;
        }
        get preferWorkers() {
          return loadTextures.config.preferWorkers;
        }
        set preferWorkers(value) {
          lib_exports.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({ preferWorkers: value });
        }
        setPreferences(preferences) {
          this.loader.parsers.forEach((parser) => {
            parser.config && Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
              parser.config[key] = preferences[key];
            });
          });
        }
      };
      Assets = new AssetsClass();
      extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
    }
  });

  // node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs
  var cacheTextureArray;
  var init_cacheTextureArray = __esm({
    "node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs"() {
      init_lib9();
      cacheTextureArray = {
        extension: ExtensionType.CacheParser,
        test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
        getCacheableAssets: (keys, asset) => {
          const out2 = {};
          return keys.forEach((key) => {
            asset.forEach((item, i2) => {
              out2[key + (i2 === 0 ? "" : i2 + 1)] = item;
            });
          }), out2;
        }
      };
      extensions.add(cacheTextureArray);
    }
  });

  // node_modules/@pixi/assets/lib/cache/parsers/index.mjs
  var init_parsers2 = __esm({
    "node_modules/@pixi/assets/lib/cache/parsers/index.mjs"() {
      init_cacheTextureArray();
    }
  });

  // node_modules/@pixi/assets/lib/cache/index.mjs
  var init_cache = __esm({
    "node_modules/@pixi/assets/lib/cache/index.mjs"() {
      init_Cache();
      init_parsers2();
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs
  var detectAvif;
  var init_detectAvif = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs"() {
      init_lib9();
      detectAvif = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 1
        },
        test: async () => {
          const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
          return new Promise((resolve2) => {
            const avif = new Image();
            avif.onload = () => {
              resolve2(true);
            }, avif.onerror = () => {
              resolve2(false);
            }, avif.src = avifData;
          });
        },
        add: async (formats2) => [...formats2, "avif"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "avif")
      };
      extensions.add(detectAvif);
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs
  var detectWebp;
  var init_detectWebp = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs"() {
      init_lib9();
      detectWebp = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => {
          const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
          return new Promise((resolve2) => {
            const webp = new Image();
            webp.onload = () => {
              resolve2(true);
            }, webp.onerror = () => {
              resolve2(false);
            }, webp.src = webpData;
          });
        },
        add: async (formats2) => [...formats2, "webp"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "webp")
      };
      extensions.add(detectWebp);
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs
  var imageFormats, detectDefaults;
  var init_detectDefaults = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs"() {
      init_lib9();
      imageFormats = ["png", "jpg", "jpeg"];
      detectDefaults = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: -1
        },
        test: () => Promise.resolve(true),
        add: async (formats2) => [...formats2, ...imageFormats],
        remove: async (formats2) => formats2.filter((f2) => !imageFormats.includes(f2))
      };
      extensions.add(detectDefaults);
    }
  });

  // node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.mjs
  function testVideoFormat(mimeType) {
    return inWorker ? false : document.createElement("video").canPlayType(mimeType) !== "";
  }
  var inWorker;
  var init_testVideoFormat = __esm({
    "node_modules/@pixi/assets/lib/detections/utils/testVideoFormat.mjs"() {
      inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/detectWebm.mjs
  var detectWebm;
  var init_detectWebm = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/detectWebm.mjs"() {
      init_lib9();
      init_testVideoFormat();
      detectWebm = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/webm"),
        add: async (formats2) => [...formats2, "webm"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "webm")
      };
      extensions.add(detectWebm);
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/detectMp4.mjs
  var detectMp4;
  var init_detectMp4 = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/detectMp4.mjs"() {
      init_lib9();
      init_testVideoFormat();
      detectMp4 = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/mp4"),
        add: async (formats2) => [...formats2, "mp4", "m4v"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
      };
      extensions.add(detectMp4);
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/detectOgv.mjs
  var detectOgv;
  var init_detectOgv = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/detectOgv.mjs"() {
      init_lib9();
      init_testVideoFormat();
      detectOgv = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat("video/ogg"),
        add: async (formats2) => [...formats2, "ogv"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "ogv")
      };
      extensions.add(detectOgv);
    }
  });

  // node_modules/@pixi/assets/lib/detections/parsers/index.mjs
  var init_parsers3 = __esm({
    "node_modules/@pixi/assets/lib/detections/parsers/index.mjs"() {
      init_detectAvif();
      init_detectWebp();
      init_detectDefaults();
      init_detectWebm();
      init_detectMp4();
      init_detectOgv();
    }
  });

  // node_modules/@pixi/assets/lib/detections/index.mjs
  var init_detections = __esm({
    "node_modules/@pixi/assets/lib/detections/index.mjs"() {
      init_parsers3();
    }
  });

  // node_modules/@pixi/assets/lib/loader/index.mjs
  var init_loader = __esm({
    "node_modules/@pixi/assets/lib/loader/index.mjs"() {
      init_parsers();
    }
  });

  // node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs
  var resolveTextureUrl;
  var init_resolveTextureUrl = __esm({
    "node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs"() {
      init_lib9();
      init_loader();
      init_loadTextures();
      resolveTextureUrl = {
        extension: ExtensionType.ResolveParser,
        test: loadTextures.test,
        parse: (value) => ({
          resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: value.split(".").pop(),
          src: value
        })
      };
      extensions.add(resolveTextureUrl);
    }
  });

  // node_modules/@pixi/assets/lib/resolver/parsers/index.mjs
  var init_parsers4 = __esm({
    "node_modules/@pixi/assets/lib/resolver/parsers/index.mjs"() {
      init_resolveTextureUrl();
    }
  });

  // node_modules/@pixi/assets/lib/resolver/index.mjs
  var init_resolver = __esm({
    "node_modules/@pixi/assets/lib/resolver/index.mjs"() {
      init_parsers4();
    }
  });

  // node_modules/@pixi/assets/lib/index.mjs
  var init_lib24 = __esm({
    "node_modules/@pixi/assets/lib/index.mjs"() {
      init_AssetExtension();
      init_Assets();
      init_cache();
      init_detections();
      init_loader();
      init_resolver();
      init_utils2();
      init_Cache();
      init_cacheTextureArray();
      init_detectAvif();
      init_detectWebp();
      init_detectDefaults();
      init_detectWebm();
      init_detectMp4();
      init_detectOgv();
      init_LoaderParser();
      init_loadJson();
      init_loadTxt();
      init_loadWebFont();
      init_loadSVG();
      init_loadTextures();
      init_loadVideo();
      init_createTexture();
      init_resolveTextureUrl();
      init_checkDataUrl();
      init_checkExtension();
      init_convertToList();
      init_copySearchParams();
      init_createStringVariations();
      init_isSingleItem();
    }
  });

  // node_modules/@pixi/compressed-textures/lib/const.mjs
  var INTERNAL_FORMATS, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL;
  var init_const4 = __esm({
    "node_modules/@pixi/compressed-textures/lib/const.mjs"() {
      INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => (INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", INTERNAL_FORMATS2[INTERNAL_FORMATS2.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", INTERNAL_FORMATS2))(INTERNAL_FORMATS || {});
      INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
        33776: 0.5,
        33777: 0.5,
        33778: 1,
        33779: 1,
        35916: 0.5,
        35917: 0.5,
        35918: 1,
        35919: 1,
        37488: 0.5,
        37489: 0.5,
        37490: 1,
        37491: 1,
        37492: 0.5,
        37496: 1,
        37493: 0.5,
        37497: 1,
        37494: 0.5,
        37495: 0.5,
        35840: 0.5,
        35842: 0.5,
        35841: 0.25,
        35843: 0.25,
        36196: 0.5,
        35986: 0.5,
        35986: 1,
        34798: 1,
        37808: 1
      };
    }
  });

  // node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs
  function getCompressedTextureExtensions() {
    extensions2 = {
      s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
      astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
    };
  }
  var storedGl, extensions2, detectCompressedTextures;
  var init_detectCompressedTextures = __esm({
    "node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs"() {
      init_lib9();
      detectCompressedTextures = {
        extension: {
          type: ExtensionType.DetectionParser,
          priority: 2
        },
        test: async () => {
          const gl = settings.ADAPTER.createCanvas().getContext("webgl");
          return gl ? (storedGl = gl, true) : (console.warn("WebGL not available for compressed textures."), false);
        },
        add: async (formats2) => {
          extensions2 || getCompressedTextureExtensions();
          const textureFormats = [];
          for (const extensionName in extensions2)
            extensions2[extensionName] && textureFormats.push(extensionName);
          return [...textureFormats, ...formats2];
        },
        remove: async (formats2) => (extensions2 || getCompressedTextureExtensions(), formats2.filter((f2) => !(f2 in extensions2)))
      };
      extensions.add(detectCompressedTextures);
    }
  });

  // node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs
  var BlobResource;
  var init_BlobResource = __esm({
    "node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs"() {
      init_lib9();
      BlobResource = class extends BufferResource {
        constructor(source2, options = { width: 1, height: 1, autoLoad: true }) {
          let origin, data;
          typeof source2 == "string" ? (origin = source2, data = new Uint8Array()) : (origin = null, data = source2), super(data, options), this.origin = origin, this.buffer = data ? new ViewableBuffer(data) : null, this._load = null, this.loaded = false, this.origin !== null && options.autoLoad !== false && this.load(), this.origin === null && this.buffer && (this._load = Promise.resolve(this), this.loaded = true, this.onBlobLoaded(this.buffer.rawBinaryData));
        }
        onBlobLoaded(_data) {
        }
        load() {
          return this._load ? this._load : (this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => (this.data = new Uint32Array(arrayBuffer), this.buffer = new ViewableBuffer(arrayBuffer), this.loaded = true, this.onBlobLoaded(arrayBuffer), this.update(), this)), this._load);
        }
      };
    }
  });

  // node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs
  var CompressedTextureResource;
  var init_CompressedTextureResource = __esm({
    "node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs"() {
      init_const4();
      init_BlobResource();
      CompressedTextureResource = class extends BlobResource {
        constructor(source2, options) {
          super(source2, options), this.format = options.format, this.levels = options.levels || 1, this._width = options.width, this._height = options.height, this._extension = CompressedTextureResource._formatToExtension(this.format), (options.levelBuffers || this.buffer) && (this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(
            source2 instanceof Uint8Array ? source2 : this.buffer.uint8View,
            this.format,
            this.levels,
            4,
            4,
            this.width,
            this.height
          ));
        }
        upload(renderer, _texture, _glTexture) {
          const gl = renderer.gl;
          if (!renderer.context.extensions[this._extension])
            throw new Error(`${this._extension} textures are not supported on the current machine`);
          if (!this._levelBuffers)
            return false;
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
          for (let i2 = 0, j2 = this.levels; i2 < j2; i2++) {
            const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i2];
            gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
          }
          return true;
        }
        onBlobLoaded() {
          this._levelBuffers = CompressedTextureResource._createLevelBuffers(
            this.buffer.uint8View,
            this.format,
            this.levels,
            4,
            4,
            this.width,
            this.height
          );
        }
        static _formatToExtension(format2) {
          if (format2 >= 33776 && format2 <= 33779)
            return "s3tc";
          if (format2 >= 37488 && format2 <= 37497)
            return "etc";
          if (format2 >= 35840 && format2 <= 35843)
            return "pvrtc";
          if (format2 >= 36196)
            return "etc1";
          if (format2 >= 35986 && format2 <= 34798)
            return "atc";
          throw new Error("Invalid (compressed) texture format given!");
        }
        static _createLevelBuffers(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
          const buffers = new Array(levels);
          let offset = buffer.byteOffset, levelWidth = imageWidth, levelHeight = imageHeight, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
          for (let i2 = 0; i2 < levels; i2++)
            buffers[i2] = {
              levelID: i2,
              levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
              levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
              levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
            }, offset += levelSize, levelWidth = levelWidth >> 1 || 1, levelHeight = levelHeight >> 1 || 1, alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
          return buffers;
        }
      };
    }
  });

  // node_modules/@pixi/compressed-textures/lib/resources/index.mjs
  var init_resources2 = __esm({
    "node_modules/@pixi/compressed-textures/lib/resources/index.mjs"() {
      init_BlobResource();
      init_CompressedTextureResource();
    }
  });

  // node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs
  function parseDDS(arrayBuffer) {
    const data = new Uint32Array(arrayBuffer);
    if (data[0] !== DDS_MAGIC)
      throw new Error("Invalid DDS file magic word");
    const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), height = header[DDS_FIELDS.HEIGHT], width = header[DDS_FIELDS.WIDTH], mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT], pixelFormat = new Uint32Array(
      arrayBuffer,
      DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,
      DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT
    ), formatFlags = pixelFormat[PF_FLAGS];
    if (formatFlags & DDPF_FOURCC) {
      const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
      if (fourCC !== FOURCC_DX10) {
        const internalFormat2 = FOURCC_TO_FORMAT[fourCC], dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, texData = new Uint8Array(arrayBuffer, dataOffset2);
        return [new CompressedTextureResource(texData, {
          format: internalFormat2,
          width,
          height,
          levels: mipmapCount
        })];
      }
      const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, dx10Header = new Uint32Array(
        data.buffer,
        dx10Offset,
        DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
      ), dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT], resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION], miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG], arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE], internalFormat = DXGI_TO_FORMAT[dxgiFormat];
      if (internalFormat === void 0)
        throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
      if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE)
        throw new Error("DDSParser does not support cubemap textures");
      if (resourceDimension === 6)
        throw new Error("DDSParser does not supported 3D texture data");
      const imageBuffers = new Array(), dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
      if (arraySize === 1)
        imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
      else {
        const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
        let imageSize = 0, levelWidth = width, levelHeight = height;
        for (let i2 = 0; i2 < mipmapCount; i2++) {
          const alignedLevelWidth = Math.max(1, levelWidth + 3 & -4), alignedLevelHeight = Math.max(1, levelHeight + 3 & -4), levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
          imageSize += levelSize, levelWidth = levelWidth >>> 1, levelHeight = levelHeight >>> 1;
        }
        let imageOffset = dataOffset;
        for (let i2 = 0; i2 < arraySize; i2++)
          imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize)), imageOffset += imageSize;
      }
      return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {
        format: internalFormat,
        width,
        height,
        levels: mipmapCount
      }));
    }
    throw formatFlags & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : formatFlags & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : formatFlags & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : formatFlags & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
  }
  var DDS_MAGIC_SIZE, DDS_HEADER_SIZE, DDS_HEADER_PF_SIZE, DDS_HEADER_DX10_SIZE, DDS_MAGIC, DDS_FIELDS, DDS_PF_FIELDS, DDS_DX10_FIELDS, PF_FLAGS, DDPF_ALPHA, DDPF_FOURCC, DDPF_RGB, DDPF_YUV, DDPF_LUMINANCE, FOURCC_DXT1, FOURCC_DXT3, FOURCC_DXT5, FOURCC_DX10, DDS_RESOURCE_MISC_TEXTURECUBE, FOURCC_TO_FORMAT, DXGI_TO_FORMAT;
  var init_parseDDS = __esm({
    "node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs"() {
      init_const4();
      init_resources2();
      init_CompressedTextureResource();
      DDS_MAGIC_SIZE = 4;
      DDS_HEADER_SIZE = 124;
      DDS_HEADER_PF_SIZE = 32;
      DDS_HEADER_DX10_SIZE = 20;
      DDS_MAGIC = 542327876;
      DDS_FIELDS = {
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19
      };
      DDS_PF_FIELDS = {
        SIZE: 0,
        FLAGS: 1,
        FOURCC: 2,
        RGB_BITCOUNT: 3,
        R_BIT_MASK: 4,
        G_BIT_MASK: 5,
        B_BIT_MASK: 6,
        A_BIT_MASK: 7
      };
      DDS_DX10_FIELDS = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
      };
      PF_FLAGS = 1;
      DDPF_ALPHA = 2;
      DDPF_FOURCC = 4;
      DDPF_RGB = 64;
      DDPF_YUV = 512;
      DDPF_LUMINANCE = 131072;
      FOURCC_DXT1 = 827611204;
      FOURCC_DXT3 = 861165636;
      FOURCC_DXT5 = 894720068;
      FOURCC_DX10 = 808540228;
      DDS_RESOURCE_MISC_TEXTURECUBE = 4;
      FOURCC_TO_FORMAT = {
        [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
      };
      DXGI_TO_FORMAT = {
        70: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        71: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        73: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        74: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        76: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        77: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        72: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        75: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        78: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      };
    }
  });

  // node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs
  function parseKTX(url2, arrayBuffer, loadKeyValueData = false) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(url2, dataView))
      return null;
    const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS, glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian), glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian), glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian), pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian), pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1, pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1, numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1, numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian), numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian), bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1)
      throw new Error("Only 2D textures are supported");
    if (numberOfFaces !== 1)
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (numberOfArrayElements !== 1)
      throw new Error("WebGL does not support array textures");
    const blockWidth = 4, blockHeight = 4, alignedWidth = pixelWidth + 3 & -4, alignedHeight = pixelHeight + 3 & -4, imageBuffers = new Array(numberOfArrayElements);
    let imagePixels = pixelWidth * pixelHeight;
    glType === 0 && (imagePixels = alignedWidth * alignedHeight);
    let imagePixelByteSize;
    if (glType !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[glType] ? imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat] : imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType] : imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat], imagePixelByteSize === void 0)
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
    let mipByteSize = imagePixels * imagePixelByteSize, mipWidth = pixelWidth, mipHeight = pixelHeight, alignedMipWidth = alignedWidth, alignedMipHeight = alignedHeight, imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      const imageSize = dataView.getUint32(imageOffset, littleEndian);
      let elementOffset = imageOffset + 4;
      for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
        let mips = imageBuffers[arrayElement];
        mips || (mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels)), mips[mipmapLevel] = {
          levelID: mipmapLevel,
          levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
          levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
          levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
        }, elementOffset += mipByteSize;
      }
      imageOffset += imageSize + 4, imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset, mipWidth = mipWidth >> 1 || 1, mipHeight = mipHeight >> 1 || 1, alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1), alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1), mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    return glType !== 0 ? {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer = levelBuffers[0].levelBuffer, convertToInt = false;
        return glType === TYPES.FLOAT ? buffer = new Float32Array(
          levelBuffers[0].levelBuffer.buffer,
          levelBuffers[0].levelBuffer.byteOffset,
          levelBuffers[0].levelBuffer.byteLength / 4
        ) : glType === TYPES.UNSIGNED_INT ? (convertToInt = true, buffer = new Uint32Array(
          levelBuffers[0].levelBuffer.buffer,
          levelBuffers[0].levelBuffer.byteOffset,
          levelBuffers[0].levelBuffer.byteLength / 4
        )) : glType === TYPES.INT && (convertToInt = true, buffer = new Int32Array(
          levelBuffers[0].levelBuffer.buffer,
          levelBuffers[0].levelBuffer.byteOffset,
          levelBuffers[0].levelBuffer.byteLength / 4
        )), {
          resource: new BufferResource(
            buffer,
            {
              width: levelBuffers[0].levelWidth,
              height: levelBuffers[0].levelHeight
            }
          ),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    } : {
      compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {
        format: glInternalFormat,
        width: pixelWidth,
        height: pixelHeight,
        levels: numberOfMipmapLevels,
        levelBuffers
      })),
      kvData
    };
  }
  function validate(url2, dataView) {
    for (let i2 = 0; i2 < FILE_IDENTIFIER.length; i2++)
      if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2])
        return console.error(`${url2} is not a valid *.ktx file!`), false;
    return true;
  }
  function convertFormatToInteger(format2) {
    switch (format2) {
      case FORMATS.RGBA:
        return FORMATS.RGBA_INTEGER;
      case FORMATS.RGB:
        return FORMATS.RGB_INTEGER;
      case FORMATS.RG:
        return FORMATS.RG_INTEGER;
      case FORMATS.RED:
        return FORMATS.RED_INTEGER;
      default:
        return format2;
    }
  }
  function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
    const kvData = /* @__PURE__ */ new Map();
    let bytesIntoKeyValueData = 0;
    for (; bytesIntoKeyValueData < bytesOfKeyValueData; ) {
      const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian), keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4, valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
      if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
        console.error("KTXLoader: keyAndValueByteSize out of bounds");
        break;
      }
      let keyNulByte = 0;
      for (; keyNulByte < keyAndValueByteSize && dataView.getUint8(keyAndValueByteOffset + keyNulByte) !== 0; keyNulByte++)
        ;
      if (keyNulByte === -1) {
        console.error("KTXLoader: Failed to find null byte terminating kvData key");
        break;
      }
      const key = new TextDecoder().decode(
        new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte)
      ), value = new DataView(
        dataView.buffer,
        keyAndValueByteOffset + keyNulByte + 1,
        keyAndValueByteSize - keyNulByte - 1
      );
      kvData.set(key, value), bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
    }
    return kvData;
  }
  var FILE_IDENTIFIER, ENDIANNESS, KTX_FIELDS, FILE_HEADER_SIZE, TYPES_TO_BYTES_PER_COMPONENT, FORMATS_TO_COMPONENTS, TYPES_TO_BYTES_PER_PIXEL;
  var init_parseKTX = __esm({
    "node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs"() {
      init_lib9();
      init_const4();
      init_resources2();
      init_CompressedTextureResource();
      FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
      ENDIANNESS = 67305985;
      KTX_FIELDS = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
      };
      FILE_HEADER_SIZE = 64;
      TYPES_TO_BYTES_PER_COMPONENT = {
        [TYPES.UNSIGNED_BYTE]: 1,
        [TYPES.UNSIGNED_SHORT]: 2,
        [TYPES.INT]: 4,
        [TYPES.UNSIGNED_INT]: 4,
        [TYPES.FLOAT]: 4,
        [TYPES.HALF_FLOAT]: 8
      };
      FORMATS_TO_COMPONENTS = {
        [FORMATS.RGBA]: 4,
        [FORMATS.RGB]: 3,
        [FORMATS.RG]: 2,
        [FORMATS.RED]: 1,
        [FORMATS.LUMINANCE]: 1,
        [FORMATS.LUMINANCE_ALPHA]: 2,
        [FORMATS.ALPHA]: 1
      };
      TYPES_TO_BYTES_PER_PIXEL = {
        [TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
        [TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
        [TYPES.UNSIGNED_SHORT_5_6_5]: 2
      };
    }
  });

  // node_modules/@pixi/compressed-textures/lib/parsers/index.mjs
  var init_parsers5 = __esm({
    "node_modules/@pixi/compressed-textures/lib/parsers/index.mjs"() {
      init_parseDDS();
      init_parseKTX();
    }
  });

  // node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs
  var loadDDS;
  var init_loadDDS = __esm({
    "node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs"() {
      init_lib24();
      init_lib9();
      init_parsers5();
      init_parseDDS();
      loadDDS = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High
        },
        name: "loadDDS",
        test(url2) {
          return checkExtension(url2, ".dds");
        },
        async load(url2, asset, loader) {
          const arrayBuffer = await (await settings.ADAPTER.fetch(url2)).arrayBuffer(), textures = parseDDS(arrayBuffer).map((resource) => {
            const base = new BaseTexture(resource, {
              mipmap: MIPMAP_MODES.OFF,
              alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
              resolution: lib_exports.getResolutionOfUrl(url2),
              ...asset.data
            });
            return createTexture(base, loader, url2);
          });
          return textures.length === 1 ? textures[0] : textures;
        },
        unload(texture) {
          Array.isArray(texture) ? texture.forEach((t2) => t2.destroy(true)) : texture.destroy(true);
        }
      };
      extensions.add(loadDDS);
    }
  });

  // node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs
  var loadKTX;
  var init_loadKTX = __esm({
    "node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs"() {
      init_lib24();
      init_lib9();
      init_parsers5();
      init_parseKTX();
      loadKTX = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.High
        },
        name: "loadKTX",
        test(url2) {
          return checkExtension(url2, ".ktx");
        },
        async load(url2, asset, loader) {
          const arrayBuffer = await (await settings.ADAPTER.fetch(url2)).arrayBuffer(), { compressed, uncompressed, kvData } = parseKTX(url2, arrayBuffer), resources = compressed ?? uncompressed, options = {
            mipmap: MIPMAP_MODES.OFF,
            alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
            resolution: lib_exports.getResolutionOfUrl(url2),
            ...asset.data
          }, textures = resources.map((resource) => {
            resources === uncompressed && Object.assign(options, {
              type: resource.type,
              format: resource.format
            });
            const res = resource.resource ?? resource, base = new BaseTexture(res, options);
            return base.ktxKeyValueData = kvData, createTexture(base, loader, url2);
          });
          return textures.length === 1 ? textures[0] : textures;
        },
        unload(texture) {
          Array.isArray(texture) ? texture.forEach((t2) => t2.destroy(true)) : texture.destroy(true);
        }
      };
      extensions.add(loadKTX);
    }
  });

  // node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs
  var resolveCompressedTextureUrl;
  var init_resolveCompressedTextureUrl = __esm({
    "node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs"() {
      init_lib9();
      resolveCompressedTextureUrl = {
        extension: ExtensionType.ResolveParser,
        test: (value) => {
          const extension = value.split("?")[0].split(".").pop();
          return ["basis", "ktx", "dds"].includes(extension);
        },
        parse: (value) => {
          if (value.split("?")[0].split(".").pop() === "ktx") {
            const extensions22 = [
              ".s3tc.ktx",
              ".s3tc_sRGB.ktx",
              ".etc.ktx",
              ".etc1.ktx",
              ".pvrt.ktx",
              ".atc.ktx",
              ".astc.ktx"
            ];
            if (extensions22.some((ext) => value.endsWith(ext)))
              return {
                resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
                format: extensions22.find((ext) => value.endsWith(ext)),
                src: value
              };
          }
          return {
            resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: value.split(".").pop(),
            src: value
          };
        }
      };
      extensions.add(resolveCompressedTextureUrl);
    }
  });

  // node_modules/@pixi/compressed-textures/lib/loaders/index.mjs
  var init_loaders = __esm({
    "node_modules/@pixi/compressed-textures/lib/loaders/index.mjs"() {
      init_detectCompressedTextures();
      init_loadDDS();
      init_loadKTX();
      init_resolveCompressedTextureUrl();
    }
  });

  // node_modules/@pixi/compressed-textures/lib/index.mjs
  var init_lib25 = __esm({
    "node_modules/@pixi/compressed-textures/lib/index.mjs"() {
      init_const4();
      init_loaders();
      init_parsers5();
      init_resources2();
      init_detectCompressedTextures();
      init_loadDDS();
      init_loadKTX();
      init_resolveCompressedTextureUrl();
      init_parseDDS();
      init_parseKTX();
      init_BlobResource();
      init_CompressedTextureResource();
    }
  });

  // node_modules/@pixi/extract/lib/Extract.mjs
  var TEMP_RECT, BYTES_PER_PIXEL, _Extract, Extract;
  var init_Extract = __esm({
    "node_modules/@pixi/extract/lib/Extract.mjs"() {
      init_lib9();
      TEMP_RECT = new Rectangle();
      BYTES_PER_PIXEL = 4;
      _Extract = class _Extract2 {
        constructor(renderer) {
          this.renderer = renderer, this._rendererPremultipliedAlpha = false;
        }
        contextChange() {
          const attributes = this.renderer?.gl.getContextAttributes();
          this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
        }
        async image(target, format2, quality, frame) {
          const image = new Image();
          return image.src = await this.base64(target, format2, quality, frame), image;
        }
        async base64(target, format2, quality, frame) {
          const canvas = this.canvas(target, frame);
          if (canvas.toBlob !== void 0)
            return new Promise((resolve2, reject) => {
              canvas.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve2(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);
              }, format2, quality);
            });
          if (canvas.toDataURL !== void 0)
            return canvas.toDataURL(format2, quality);
          if (canvas.convertToBlob !== void 0) {
            const blob = await canvas.convertToBlob({ type: format2, quality });
            return new Promise((resolve2, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve2(reader.result), reader.onerror = reject, reader.readAsDataURL(blob);
            });
          }
          throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        canvas(target, frame) {
          const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);
          flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels);
          const canvasBuffer = new lib_exports.CanvasRenderTarget(width, height, 1), imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
          return canvasBuffer.context.putImageData(imageData, 0, 0), canvasBuffer.canvas;
        }
        pixels(target, frame) {
          const { pixels, width, height, flipY, premultipliedAlpha } = this._rawPixels(target, frame);
          return flipY && _Extract2._flipY(pixels, width, height), premultipliedAlpha && _Extract2._unpremultiplyAlpha(pixels), pixels;
        }
        _rawPixels(target, frame) {
          const renderer = this.renderer;
          if (!renderer)
            throw new Error("The Extract has already been destroyed");
          let resolution, flipY = false, premultipliedAlpha = false, renderTexture, generated = false;
          target && (target instanceof RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {
            region: frame,
            resolution: renderer.resolution,
            multisample: renderer.multisample
          }), generated = true, frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT)));
          const gl = renderer.gl;
          if (renderTexture) {
            if (resolution = renderTexture.baseTexture.resolution, frame = frame ?? renderTexture.frame, flipY = false, premultipliedAlpha = renderTexture.baseTexture.alphaMode > 0 && renderTexture.baseTexture.format === FORMATS.RGBA, !generated) {
              renderer.renderTexture.bind(renderTexture);
              const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
              fbo.blitFramebuffer && renderer.framebuffer.bind(fbo.blitFramebuffer);
            }
          } else
            resolution = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / resolution, frame.height = renderer.height / resolution), flipY = true, premultipliedAlpha = this._rendererPremultipliedAlpha, renderer.renderTexture.bind();
          const width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
          return gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width,
            height,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          ), generated && renderTexture?.destroy(true), { pixels, width, height, flipY, premultipliedAlpha };
        }
        destroy() {
          this.renderer = null;
        }
        static _flipY(pixels, width, height) {
          const w2 = width << 2, h2 = height >> 1, temp = new Uint8Array(w2);
          for (let y2 = 0; y2 < h2; y2++) {
            const t2 = y2 * w2, b2 = (height - y2 - 1) * w2;
            temp.set(pixels.subarray(t2, t2 + w2)), pixels.copyWithin(t2, b2, b2 + w2), pixels.set(temp, b2);
          }
        }
        static _unpremultiplyAlpha(pixels) {
          pixels instanceof Uint8ClampedArray && (pixels = new Uint8Array(pixels.buffer));
          const n2 = pixels.length;
          for (let i2 = 0; i2 < n2; i2 += 4) {
            const alpha = pixels[i2 + 3];
            if (alpha !== 0) {
              const a2 = 255.001 / alpha;
              pixels[i2] = pixels[i2] * a2 + 0.5, pixels[i2 + 1] = pixels[i2 + 1] * a2 + 0.5, pixels[i2 + 2] = pixels[i2 + 2] * a2 + 0.5;
            }
          }
        }
      };
      _Extract.extension = {
        name: "extract",
        type: ExtensionType.RendererSystem
      };
      Extract = _Extract;
      extensions.add(Extract);
    }
  });

  // node_modules/@pixi/extract/lib/index.mjs
  var init_lib26 = __esm({
    "node_modules/@pixi/extract/lib/index.mjs"() {
      init_Extract();
    }
  });

  // node_modules/@pixi/graphics/lib/utils/buildCircle.mjs
  var buildCircle;
  var init_buildCircle = __esm({
    "node_modules/@pixi/graphics/lib/utils/buildCircle.mjs"() {
      init_lib9();
      buildCircle = {
        build(graphicsData) {
          const points = graphicsData.points;
          let x2, y2, dx, dy, rx, ry;
          if (graphicsData.type === SHAPES.CIRC) {
            const circle = graphicsData.shape;
            x2 = circle.x, y2 = circle.y, rx = ry = circle.radius, dx = dy = 0;
          } else if (graphicsData.type === SHAPES.ELIP) {
            const ellipse = graphicsData.shape;
            x2 = ellipse.x, y2 = ellipse.y, rx = ellipse.width, ry = ellipse.height, dx = dy = 0;
          } else {
            const roundedRect = graphicsData.shape, halfWidth = roundedRect.width / 2, halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth, y2 = roundedRect.y + halfHeight, rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight))), dx = halfWidth - rx, dy = halfHeight - ry;
          }
          if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
            points.length = 0;
            return;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry)), m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (points.length = m2, m2 === 0)
            return;
          if (n2 === 0) {
            points.length = 8, points[0] = points[6] = x2 + dx, points[1] = points[3] = y2 + dy, points[2] = points[4] = x2 - dx, points[5] = points[7] = y2 - dy;
            return;
          }
          let j1 = 0, j2 = n2 * 4 + (dx ? 2 : 0) + 2, j3 = j2, j4 = m2;
          {
            const x0 = dx + rx, y0 = dy, x1 = x2 + x0, x22 = x2 - x0, y1 = y2 + y0;
            if (points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x22, dy) {
              const y22 = y2 - y0;
              points[j3++] = x22, points[j3++] = y22, points[--j4] = y22, points[--j4] = x1;
            }
          }
          for (let i2 = 1; i2 < n2; i2++) {
            const a2 = Math.PI / 2 * (i2 / n2), x0 = dx + Math.cos(a2) * rx, y0 = dy + Math.sin(a2) * ry, x1 = x2 + x0, x22 = x2 - x0, y1 = y2 + y0, y22 = y2 - y0;
            points[j1++] = x1, points[j1++] = y1, points[--j2] = y1, points[--j2] = x22, points[j3++] = x22, points[j3++] = y22, points[--j4] = y22, points[--j4] = x1;
          }
          {
            const x0 = dx, y0 = dy + ry, x1 = x2 + x0, x22 = x2 - x0, y1 = y2 + y0, y22 = y2 - y0;
            points[j1++] = x1, points[j1++] = y1, points[--j4] = y22, points[--j4] = x1, dx && (points[j1++] = x22, points[j1++] = y1, points[--j4] = y22, points[--j4] = x22);
          }
        },
        triangulate(graphicsData, graphicsGeometry) {
          const points = graphicsData.points, verts = graphicsGeometry.points, indices2 = graphicsGeometry.indices;
          if (points.length === 0)
            return;
          let vertPos = verts.length / 2;
          const center = vertPos;
          let x2, y2;
          if (graphicsData.type !== SHAPES.RREC) {
            const circle = graphicsData.shape;
            x2 = circle.x, y2 = circle.y;
          } else {
            const roundedRect = graphicsData.shape;
            x2 = roundedRect.x + roundedRect.width / 2, y2 = roundedRect.y + roundedRect.height / 2;
          }
          const matrix = graphicsData.matrix;
          verts.push(
            graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2,
            graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2
          ), vertPos++, verts.push(points[0], points[1]);
          for (let i2 = 2; i2 < points.length; i2 += 2)
            verts.push(points[i2], points[i2 + 1]), indices2.push(vertPos++, center, vertPos);
          indices2.push(center + 1, center, vertPos);
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/buildPoly.mjs
  function fixOrientation(points, hole = false) {
    const m2 = points.length;
    if (m2 < 6)
      return;
    let area = 0;
    for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
      const x2 = points[i2], y2 = points[i2 + 1];
      area += (x2 - x1) * (y2 + y1), x1 = x2, y1 = y2;
    }
    if (!hole && area > 0 || hole && area <= 0) {
      const n2 = m2 / 2;
      for (let i2 = n2 + n2 % 2; i2 < m2; i2 += 2) {
        const i1 = m2 - i2 - 2, i22 = m2 - i2 - 1, i3 = i2, i4 = i2 + 1;
        [points[i1], points[i3]] = [points[i3], points[i1]], [points[i22], points[i4]] = [points[i4], points[i22]];
      }
    }
  }
  var buildPoly;
  var init_buildPoly = __esm({
    "node_modules/@pixi/graphics/lib/utils/buildPoly.mjs"() {
      init_lib9();
      buildPoly = {
        build(graphicsData) {
          graphicsData.points = graphicsData.shape.points.slice();
        },
        triangulate(graphicsData, graphicsGeometry) {
          let points = graphicsData.points;
          const holes = graphicsData.holes, verts = graphicsGeometry.points, indices2 = graphicsGeometry.indices;
          if (points.length >= 6) {
            fixOrientation(points, false);
            const holeArray = [];
            for (let i2 = 0; i2 < holes.length; i2++) {
              const hole = holes[i2];
              fixOrientation(hole.points, true), holeArray.push(points.length / 2), points = points.concat(hole.points);
            }
            const triangles = lib_exports.earcut(points, holeArray, 2);
            if (!triangles)
              return;
            const vertPos = verts.length / 2;
            for (let i2 = 0; i2 < triangles.length; i2 += 3)
              indices2.push(triangles[i2] + vertPos), indices2.push(triangles[i2 + 1] + vertPos), indices2.push(triangles[i2 + 2] + vertPos);
            for (let i2 = 0; i2 < points.length; i2++)
              verts.push(points[i2]);
          }
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs
  var buildRectangle;
  var init_buildRectangle = __esm({
    "node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs"() {
      buildRectangle = {
        build(graphicsData) {
          const rectData = graphicsData.shape, x2 = rectData.x, y2 = rectData.y, width = rectData.width, height = rectData.height, points = graphicsData.points;
          points.length = 0, width >= 0 && height >= 0 && points.push(
            x2,
            y2,
            x2 + width,
            y2,
            x2 + width,
            y2 + height,
            x2,
            y2 + height
          );
        },
        triangulate(graphicsData, graphicsGeometry) {
          const points = graphicsData.points, verts = graphicsGeometry.points;
          if (points.length === 0)
            return;
          const vertPos = verts.length / 2;
          verts.push(
            points[0],
            points[1],
            points[2],
            points[3],
            points[6],
            points[7],
            points[4],
            points[5]
          ), graphicsGeometry.indices.push(
            vertPos,
            vertPos + 1,
            vertPos + 2,
            vertPos + 1,
            vertPos + 2,
            vertPos + 3
          );
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs
  var buildRoundedRectangle;
  var init_buildRoundedRectangle = __esm({
    "node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs"() {
      init_buildCircle();
      buildRoundedRectangle = {
        build(graphicsData) {
          buildCircle.build(graphicsData);
        },
        triangulate(graphicsData, graphicsGeometry) {
          buildCircle.triangulate(graphicsData, graphicsGeometry);
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/const.mjs
  var LINE_JOIN, LINE_CAP, curves;
  var init_const5 = __esm({
    "node_modules/@pixi/graphics/lib/const.mjs"() {
      LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => (LINE_JOIN2.MITER = "miter", LINE_JOIN2.BEVEL = "bevel", LINE_JOIN2.ROUND = "round", LINE_JOIN2))(LINE_JOIN || {});
      LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => (LINE_CAP2.BUTT = "butt", LINE_CAP2.ROUND = "round", LINE_CAP2.SQUARE = "square", LINE_CAP2))(LINE_CAP || {});
      curves = {
        adaptive: true,
        maxLength: 10,
        minSegments: 8,
        maxSegments: 2048,
        epsilon: 1e-4,
        _segmentsCount(length, defaultSegments = 20) {
          if (!this.adaptive || !length || isNaN(length))
            return defaultSegments;
          let result = Math.ceil(length / this.maxLength);
          return result < this.minSegments ? result = this.minSegments : result > this.maxSegments && (result = this.maxSegments), result;
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs
  var ArcUtils;
  var init_ArcUtils = __esm({
    "node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs"() {
      init_lib9();
      init_const5();
      ArcUtils = class {
        static curveTo(x1, y1, x2, y2, radius, points) {
          const fromX = points[points.length - 2], a1 = points[points.length - 1] - y1, b1 = fromX - x1, a2 = y2 - y1, b2 = x2 - x1, mm = Math.abs(a1 * b2 - b1 * a2);
          if (mm < 1e-8 || radius === 0)
            return (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) && points.push(x1, y1), null;
          const dd = a1 * a1 + b1 * b1, cc = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd) / mm, k2 = radius * Math.sqrt(cc) / mm, j1 = k1 * tt / dd, j2 = k2 * tt / cc, cx = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx), endAngle = Math.atan2(qy - cy, qx - cx);
          return {
            cx: cx + x1,
            cy: cy + y1,
            radius,
            startAngle,
            endAngle,
            anticlockwise: b1 * a2 > b2 * a1
          };
        }
        static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
          const sweep = endAngle - startAngle, n2 = curves._segmentsCount(
            Math.abs(sweep) * radius,
            Math.ceil(Math.abs(sweep) / PI_2) * 40
          ), theta = sweep / (n2 * 2), theta2 = theta * 2, cTheta = Math.cos(theta), sTheta = Math.sin(theta), segMinus = n2 - 1, remainder = segMinus % 1 / segMinus;
          for (let i2 = 0; i2 <= segMinus; ++i2) {
            const real = i2 + remainder * i2, angle = theta + startAngle + theta2 * real, c2 = Math.cos(angle), s2 = -Math.sin(angle);
            points.push(
              (cTheta * c2 + sTheta * s2) * radius + cx,
              (cTheta * -s2 + sTheta * c2) * radius + cy
            );
          }
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/BatchPart.mjs
  var BatchPart;
  var init_BatchPart = __esm({
    "node_modules/@pixi/graphics/lib/utils/BatchPart.mjs"() {
      BatchPart = class {
        constructor() {
          this.reset();
        }
        begin(style, startIndex, attribStart) {
          this.reset(), this.style = style, this.start = startIndex, this.attribStart = attribStart;
        }
        end(endIndex, endAttrib) {
          this.attribSize = endAttrib - this.attribStart, this.size = endIndex - this.start;
        }
        reset() {
          this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs
  var BezierUtils;
  var init_BezierUtils = __esm({
    "node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs"() {
      init_const5();
      BezierUtils = class {
        static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
          let result = 0, t2 = 0, t22 = 0, t3 = 0, nt = 0, nt2 = 0, nt3 = 0, x2 = 0, y2 = 0, dx = 0, dy = 0, prevX = fromX, prevY = fromY;
          for (let i2 = 1; i2 <= 10; ++i2)
            t2 = i2 / 10, t22 = t2 * t2, t3 = t22 * t2, nt = 1 - t2, nt2 = nt * nt, nt3 = nt2 * nt, x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX, y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY, dx = prevX - x2, dy = prevY - y2, prevX = x2, prevY = y2, result += Math.sqrt(dx * dx + dy * dy);
          return result;
        }
        static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
          const fromX = points[points.length - 2], fromY = points[points.length - 1];
          points.length -= 2;
          const n2 = curves._segmentsCount(
            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)
          );
          let dt = 0, dt2 = 0, dt3 = 0, t2 = 0, t3 = 0;
          points.push(fromX, fromY);
          for (let i2 = 1, j2 = 0; i2 <= n2; ++i2)
            j2 = i2 / n2, dt = 1 - j2, dt2 = dt * dt, dt3 = dt2 * dt, t2 = j2 * j2, t3 = t2 * j2, points.push(
              dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX,
              dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY
            );
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/buildLine.mjs
  function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight, iy = y2 - ny * innerWeight, ox = x2 + nx * outerWeight, oy = y2 + ny * outerWeight;
    let exx, eyy;
    clockwise ? (exx = ny, eyy = -nx) : (exx = -ny, eyy = nx);
    const eix = ix + exx, eiy = iy + eyy, eox = ox + exx, eoy = oy + eyy;
    return verts.push(
      eix,
      eiy,
      eox,
      eoy
    ), 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx, cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y), angle1 = Math.atan2(ex - cx, ey - cy);
    clockwise && angle0 < angle1 ? angle0 += Math.PI * 2 : !clockwise && angle0 > angle1 && (angle1 += Math.PI * 2);
    let startAngle = angle0;
    const angleDiff = angle1 - angle0, absAngleDiff = Math.abs(angleDiff), radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y), segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1, angleInc = angleDiff / segCount;
    if (startAngle += angleInc, clockwise) {
      verts.push(
        cx,
        cy,
        sx,
        sy
      );
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc)
        verts.push(
          cx,
          cy,
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      verts.push(
        cx,
        cy,
        ex,
        ey
      );
    } else {
      verts.push(
        sx,
        sy,
        cx,
        cy
      );
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc)
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius,
          cx,
          cy
        );
      verts.push(
        ex,
        ey,
        cx,
        cy
      );
    }
    return segCount * 2;
  }
  function buildNonNativeLine(graphicsData, graphicsGeometry) {
    const shape = graphicsData.shape;
    let points = graphicsData.points || shape.points.slice();
    const eps = graphicsGeometry.closePointEps;
    if (points.length === 0)
      return;
    const style = graphicsData.lineStyle, firstPoint = new Point(points[0], points[1]), lastPoint = new Point(points[points.length - 2], points[points.length - 1]), closedShape = shape.type !== SHAPES.POLY || shape.closeStroke, closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice(), closedPath && (points.pop(), points.pop(), lastPoint.set(points[points.length - 2], points[points.length - 1]));
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5, midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY), points.push(midPointX, midPointY);
    }
    const verts = graphicsGeometry.points, length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2, width = style.width / 2, widthSquared = width * width, miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0], y0 = points[1], x1 = points[2], y1 = points[3], x2 = 0, y2 = 0, perpx = -(y0 - y1), perpy = x0 - x1, perp1x = 0, perp1y = 0, dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist, perpy /= dist, perpx *= width, perpy *= width;
    const ratio = style.alignment, innerWeight = (1 - ratio) * 2, outerWeight = ratio * 2;
    closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(
      x0 - perpx * (innerWeight - outerWeight) * 0.5,
      y0 - perpy * (innerWeight - outerWeight) * 0.5,
      x0 - perpx * innerWeight,
      y0 - perpy * innerWeight,
      x0 + perpx * outerWeight,
      y0 + perpy * outerWeight,
      verts,
      true
    ) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts))), verts.push(
      x0 - perpx * innerWeight,
      y0 - perpy * innerWeight,
      x0 + perpx * outerWeight,
      y0 + perpy * outerWeight
    );
    for (let i2 = 1; i2 < length - 1; ++i2) {
      x0 = points[(i2 - 1) * 2], y0 = points[(i2 - 1) * 2 + 1], x1 = points[i2 * 2], y1 = points[i2 * 2 + 1], x2 = points[(i2 + 1) * 2], y2 = points[(i2 + 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, perp1x = -(y1 - y2), perp1y = x1 - x2, dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y), perp1x /= dist, perp1y /= dist, perp1x *= width, perp1y *= width;
      const dx0 = x1 - x0, dy0 = y0 - y1, dx1 = x1 - x2, dy1 = y2 - y1, dot = dx0 * dx1 + dy0 * dy1, cross = dy0 * dx1 - dy1 * dx0, clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpx * innerWeight,
          y1 - perpy * innerWeight,
          x1 + perpx * outerWeight,
          y1 + perpy * outerWeight
        ), dot >= 0 && (style.join === LINE_JOIN.ROUND ? indexCount += round(
          x1,
          y1,
          x1 - perpx * innerWeight,
          y1 - perpy * innerWeight,
          x1 - perp1x * innerWeight,
          y1 - perp1y * innerWeight,
          verts,
          false
        ) + 4 : indexCount += 2, verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight,
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        ));
        continue;
      }
      const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0), c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2), px = (dx0 * c2 - dx1 * c1) / cross, py = (dy1 * c1 - dy0 * c2) / cross, pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1), imx = x1 + (px - x1) * innerWeight, imy = y1 + (py - y1) * innerWeight, omx = x1 - (px - x1) * outerWeight, omy = y1 - (py - y1) * outerWeight, smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1), insideWeight = clockwise ? innerWeight : outerWeight, smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared, insideMiterOk = pdist <= smallerInsideDiagonalSq;
      let join = style.join;
      if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared && (join = LINE_JOIN.BEVEL), insideMiterOk)
        switch (join) {
          case LINE_JOIN.MITER: {
            verts.push(
              imx,
              imy,
              omx,
              omy
            );
            break;
          }
          case LINE_JOIN.BEVEL: {
            clockwise ? verts.push(
              imx,
              imy,
              x1 + perpx * outerWeight,
              y1 + perpy * outerWeight,
              imx,
              imy,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight
            ) : verts.push(
              x1 - perpx * innerWeight,
              y1 - perpy * innerWeight,
              omx,
              omy,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              omx,
              omy
            ), indexCount += 2;
            break;
          }
          case LINE_JOIN.ROUND: {
            clockwise ? (verts.push(
              imx,
              imy,
              x1 + perpx * outerWeight,
              y1 + perpy * outerWeight
            ), indexCount += round(
              x1,
              y1,
              x1 + perpx * outerWeight,
              y1 + perpy * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4, verts.push(
              imx,
              imy,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight
            )) : (verts.push(
              x1 - perpx * innerWeight,
              y1 - perpy * innerWeight,
              omx,
              omy
            ), indexCount += round(
              x1,
              y1,
              x1 - perpx * innerWeight,
              y1 - perpy * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4, verts.push(
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              omx,
              omy
            ));
            break;
          }
        }
      else {
        switch (verts.push(
          x1 - perpx * innerWeight,
          y1 - perpy * innerWeight,
          x1 + perpx * outerWeight,
          y1 + perpy * outerWeight
        ), join) {
          case LINE_JOIN.MITER: {
            clockwise ? verts.push(
              omx,
              omy,
              omx,
              omy
            ) : verts.push(
              imx,
              imy,
              imx,
              imy
            ), indexCount += 2;
            break;
          }
          case LINE_JOIN.ROUND: {
            clockwise ? indexCount += round(
              x1,
              y1,
              x1 + perpx * outerWeight,
              y1 + perpy * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2 : indexCount += round(
              x1,
              y1,
              x1 - perpx * innerWeight,
              y1 - perpy * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
            break;
          }
        }
        verts.push(
          x1 - perp1x * innerWeight,
          y1 - perp1y * innerWeight,
          x1 + perp1x * outerWeight,
          y1 + perp1y * outerWeight
        ), indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2], y0 = points[(length - 2) * 2 + 1], x1 = points[(length - 1) * 2], y1 = points[(length - 1) * 2 + 1], perpx = -(y0 - y1), perpy = x0 - x1, dist = Math.sqrt(perpx * perpx + perpy * perpy), perpx /= dist, perpy /= dist, perpx *= width, perpy *= width, verts.push(
      x1 - perpx * innerWeight,
      y1 - perpy * innerWeight,
      x1 + perpx * outerWeight,
      y1 + perpy * outerWeight
    ), closedShape || (style.cap === LINE_CAP.ROUND ? indexCount += round(
      x1 - perpx * (innerWeight - outerWeight) * 0.5,
      y1 - perpy * (innerWeight - outerWeight) * 0.5,
      x1 - perpx * innerWeight,
      y1 - perpy * innerWeight,
      x1 + perpx * outerWeight,
      y1 + perpy * outerWeight,
      verts,
      false
    ) + 2 : style.cap === LINE_CAP.SQUARE && (indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts)));
    const indices2 = graphicsGeometry.indices, eps2 = curves.epsilon * curves.epsilon;
    for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2)
      x0 = verts[i2 * 2], y0 = verts[i2 * 2 + 1], x1 = verts[(i2 + 1) * 2], y1 = verts[(i2 + 1) * 2 + 1], x2 = verts[(i2 + 2) * 2], y2 = verts[(i2 + 2) * 2 + 1], !(Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) && indices2.push(i2, i2 + 1, i2 + 2);
  }
  function buildNativeLine(graphicsData, graphicsGeometry) {
    let i2 = 0;
    const shape = graphicsData.shape, points = graphicsData.points || shape.points, closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
    if (points.length === 0)
      return;
    const verts = graphicsGeometry.points, indices2 = graphicsGeometry.indices, length = points.length / 2, startIndex = verts.length / 2;
    let currentIndex = startIndex;
    for (verts.push(points[0], points[1]), i2 = 1; i2 < length; i2++)
      verts.push(points[i2 * 2], points[i2 * 2 + 1]), indices2.push(currentIndex, currentIndex + 1), currentIndex++;
    closedShape && indices2.push(currentIndex, startIndex);
  }
  function buildLine(graphicsData, graphicsGeometry) {
    graphicsData.lineStyle.native ? buildNativeLine(graphicsData, graphicsGeometry) : buildNonNativeLine(graphicsData, graphicsGeometry);
  }
  var init_buildLine = __esm({
    "node_modules/@pixi/graphics/lib/utils/buildLine.mjs"() {
      init_lib9();
      init_const5();
    }
  });

  // node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs
  var QuadraticUtils;
  var init_QuadraticUtils = __esm({
    "node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs"() {
      init_const5();
      QuadraticUtils = class {
        static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
          const ax = fromX - 2 * cpX + toX, ay = fromY - 2 * cpY + toY, bx = 2 * cpX - 2 * fromX, by = 2 * cpY - 2 * fromY, a2 = 4 * (ax * ax + ay * ay), b2 = 4 * (ax * bx + ay * by), c2 = bx * bx + by * by, s2 = 2 * Math.sqrt(a2 + b2 + c2), a22 = Math.sqrt(a2), a32 = 2 * a2 * a22, c22 = 2 * Math.sqrt(c2), ba = b2 / a22;
          return (a32 * s2 + a22 * b2 * (s2 - c22) + (4 * c2 * a2 - b2 * b2) * Math.log((2 * a22 + ba + s2) / (ba + c22))) / (4 * a32);
        }
        static curveTo(cpX, cpY, toX, toY, points) {
          const fromX = points[points.length - 2], fromY = points[points.length - 1], n2 = curves._segmentsCount(
            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)
          );
          let xa = 0, ya = 0;
          for (let i2 = 1; i2 <= n2; ++i2) {
            const j2 = i2 / n2;
            xa = fromX + (cpX - fromX) * j2, ya = fromY + (cpY - fromY) * j2, points.push(
              xa + (cpX + (toX - cpX) * j2 - xa) * j2,
              ya + (cpY + (toY - cpY) * j2 - ya) * j2
            );
          }
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/utils/index.mjs
  var FILL_COMMANDS, BATCH_POOL, DRAW_CALL_POOL;
  var init_utils4 = __esm({
    "node_modules/@pixi/graphics/lib/utils/index.mjs"() {
      init_lib9();
      init_buildCircle();
      init_buildPoly();
      init_buildRectangle();
      init_buildRoundedRectangle();
      init_ArcUtils();
      init_BatchPart();
      init_BezierUtils();
      init_buildLine();
      init_QuadraticUtils();
      FILL_COMMANDS = {
        [SHAPES.POLY]: buildPoly,
        [SHAPES.CIRC]: buildCircle,
        [SHAPES.ELIP]: buildCircle,
        [SHAPES.RECT]: buildRectangle,
        [SHAPES.RREC]: buildRoundedRectangle
      };
      BATCH_POOL = [];
      DRAW_CALL_POOL = [];
    }
  });

  // node_modules/@pixi/graphics/lib/GraphicsData.mjs
  var GraphicsData;
  var init_GraphicsData = __esm({
    "node_modules/@pixi/graphics/lib/GraphicsData.mjs"() {
      GraphicsData = class {
        constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
          this.points = [], this.holes = [], this.shape = shape, this.lineStyle = lineStyle, this.fillStyle = fillStyle, this.matrix = matrix, this.type = shape.type;
        }
        clone() {
          return new GraphicsData(
            this.shape,
            this.fillStyle,
            this.lineStyle,
            this.matrix
          );
        }
        destroy() {
          this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs
  var tmpPoint, _GraphicsGeometry, GraphicsGeometry;
  var init_GraphicsGeometry = __esm({
    "node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs"() {
      init_lib9();
      init_lib10();
      init_GraphicsData();
      init_utils4();
      init_BatchPart();
      init_buildPoly();
      init_buildLine();
      tmpPoint = new Point();
      _GraphicsGeometry = class _GraphicsGeometry2 extends BatchGeometry {
        constructor() {
          super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = false, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new Bounds(), this.boundsDirty = -1;
        }
        get bounds() {
          return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
        }
        invalidate() {
          this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
          for (let i2 = 0; i2 < this.drawCalls.length; i2++)
            this.drawCalls[i2].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i2]);
          this.drawCalls.length = 0;
          for (let i2 = 0; i2 < this.batches.length; i2++) {
            const batchPart = this.batches[i2];
            batchPart.reset(), BATCH_POOL.push(batchPart);
          }
          this.batches.length = 0;
        }
        clear() {
          return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
        }
        drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
          const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
          return this.graphicsData.push(data), this.dirty++, this;
        }
        drawHole(shape, matrix = null) {
          if (!this.graphicsData.length)
            return null;
          const data = new GraphicsData(shape, null, null, matrix), lastShape = this.graphicsData[this.graphicsData.length - 1];
          return data.lineStyle = lastShape.lineStyle, lastShape.holes.push(data), this.dirty++, this;
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.graphicsData.length; ++i2)
            this.graphicsData[i2].destroy();
          this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
        }
        containsPoint(point) {
          const graphicsData = this.graphicsData;
          for (let i2 = 0; i2 < graphicsData.length; ++i2) {
            const data = graphicsData[i2];
            if (data.fillStyle.visible && data.shape && (data.matrix ? data.matrix.applyInverse(point, tmpPoint) : tmpPoint.copyFrom(point), data.shape.contains(tmpPoint.x, tmpPoint.y))) {
              let hitHole = false;
              if (data.holes) {
                for (let i22 = 0; i22 < data.holes.length; i22++)
                  if (data.holes[i22].shape.contains(tmpPoint.x, tmpPoint.y)) {
                    hitHole = true;
                    break;
                  }
              }
              if (!hitHole)
                return true;
            }
          }
          return false;
        }
        updateBatches() {
          if (!this.graphicsData.length) {
            this.batchable = true;
            return;
          }
          if (!this.validateBatching())
            return;
          this.cacheDirty = this.dirty;
          const uvs = this.uvs, graphicsData = this.graphicsData;
          let batchPart = null, currentStyle = null;
          this.batches.length > 0 && (batchPart = this.batches[this.batches.length - 1], currentStyle = batchPart.style);
          for (let i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
            this.shapeIndex++;
            const data = graphicsData[i2], fillStyle = data.fillStyle, lineStyle = data.lineStyle;
            FILL_COMMANDS[data.type].build(data), data.matrix && this.transformPoints(data.points, data.matrix), (fillStyle.visible || lineStyle.visible) && this.processHoles(data.holes);
            for (let j2 = 0; j2 < 2; j2++) {
              const style = j2 === 0 ? fillStyle : lineStyle;
              if (!style.visible)
                continue;
              const nextTexture = style.texture.baseTexture, index2 = this.indices.length, attribIndex = this.points.length / 2;
              nextTexture.wrapMode = WRAP_MODES.REPEAT, j2 === 0 ? this.processFill(data) : this.processLine(data);
              const size = this.points.length / 2 - attribIndex;
              size !== 0 && (batchPart && !this._compareStyles(currentStyle, style) && (batchPart.end(index2, attribIndex), batchPart = null), batchPart || (batchPart = BATCH_POOL.pop() || new BatchPart(), batchPart.begin(style, index2, attribIndex), this.batches.push(batchPart), currentStyle = style), this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix));
            }
          }
          const index = this.indices.length, attrib = this.points.length / 2;
          if (batchPart && batchPart.end(index, attrib), this.batches.length === 0) {
            this.batchable = true;
            return;
          }
          const need32 = attrib > 65535;
          this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
        }
        _compareStyles(styleA, styleB) {
          return !(!styleA || !styleB || styleA.texture.baseTexture !== styleB.texture.baseTexture || styleA.color + styleA.alpha !== styleB.color + styleB.alpha || !!styleA.native != !!styleB.native);
        }
        validateBatching() {
          if (this.dirty === this.cacheDirty || !this.graphicsData.length)
            return false;
          for (let i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
            const data = this.graphicsData[i2], fill = data.fillStyle, line = data.lineStyle;
            if (fill && !fill.texture.baseTexture.valid || line && !line.texture.baseTexture.valid)
              return false;
          }
          return true;
        }
        packBatches() {
          this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
          const batches = this.batches;
          for (let i2 = 0, l2 = batches.length; i2 < l2; i2++) {
            const batch = batches[i2];
            for (let j2 = 0; j2 < batch.size; j2++) {
              const index = batch.start + j2;
              this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
            }
          }
        }
        isBatchable() {
          if (this.points.length > 65535 * 2)
            return false;
          const batches = this.batches;
          for (let i2 = 0; i2 < batches.length; i2++)
            if (batches[i2].style.native)
              return false;
          return this.points.length < _GraphicsGeometry2.BATCHABLE_SIZE * 2;
        }
        buildDrawCalls() {
          let TICK = ++BaseTexture._globalBatch;
          for (let i2 = 0; i2 < this.drawCalls.length; i2++)
            this.drawCalls[i2].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[i2]);
          this.drawCalls.length = 0;
          const colors = this.colors, textureIds = this.textureIds;
          let currentGroup = DRAW_CALL_POOL.pop();
          currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), currentGroup.texArray.count = 0, currentGroup.start = 0, currentGroup.size = 0, currentGroup.type = DRAW_MODES.TRIANGLES;
          let textureCount = 0, currentTexture = null, textureId = 0, native = false, drawMode = DRAW_MODES.TRIANGLES, index = 0;
          this.drawCalls.push(currentGroup);
          for (let i2 = 0; i2 < this.batches.length; i2++) {
            const data = this.batches[i2], maxTextures2 = 8, style = data.style, nextTexture = style.texture.baseTexture;
            native !== !!style.native && (native = !!style.native, drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = maxTextures2, TICK++), currentTexture !== nextTexture && (currentTexture = nextTexture, nextTexture._batchEnabled !== TICK && (textureCount === maxTextures2 && (TICK++, textureCount = 0, currentGroup.size > 0 && (currentGroup = DRAW_CALL_POOL.pop(), currentGroup || (currentGroup = new BatchDrawCall(), currentGroup.texArray = new BatchTextureArray()), this.drawCalls.push(currentGroup)), currentGroup.start = index, currentGroup.size = 0, currentGroup.texArray.count = 0, currentGroup.type = drawMode), nextTexture.touched = 1, nextTexture._batchEnabled = TICK, nextTexture._batchLocation = textureCount, nextTexture.wrapMode = WRAP_MODES.REPEAT, currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture, textureCount++)), currentGroup.size += data.size, index += data.size, textureId = nextTexture._batchLocation, this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart), this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
          }
          BaseTexture._globalBatch = TICK, this.packAttributes();
        }
        packAttributes() {
          const verts = this.points, uvs = this.uvs, colors = this.colors, textureIds = this.textureIds, glPoints = new ArrayBuffer(verts.length * 3 * 4), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints);
          let p2 = 0;
          for (let i2 = 0; i2 < verts.length / 2; i2++)
            f32[p2++] = verts[i2 * 2], f32[p2++] = verts[i2 * 2 + 1], f32[p2++] = uvs[i2 * 2], f32[p2++] = uvs[i2 * 2 + 1], u32[p2++] = colors[i2], f32[p2++] = textureIds[i2];
          this._buffer.update(glPoints), this._indexBuffer.update(this.indicesUint16);
        }
        processFill(data) {
          data.holes.length ? buildPoly.triangulate(data, this) : FILL_COMMANDS[data.type].triangulate(data, this);
        }
        processLine(data) {
          buildLine(data, this);
          for (let i2 = 0; i2 < data.holes.length; i2++)
            buildLine(data.holes[i2], this);
        }
        processHoles(holes) {
          for (let i2 = 0; i2 < holes.length; i2++) {
            const hole = holes[i2];
            FILL_COMMANDS[hole.type].build(hole), hole.matrix && this.transformPoints(hole.points, hole.matrix);
          }
        }
        calculateBounds() {
          const bounds = this._bounds;
          bounds.clear(), bounds.addVertexData(this.points, 0, this.points.length), bounds.pad(this.boundsPadding, this.boundsPadding);
        }
        transformPoints(points, matrix) {
          for (let i2 = 0; i2 < points.length / 2; i2++) {
            const x2 = points[i2 * 2], y2 = points[i2 * 2 + 1];
            points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx, points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
          }
        }
        addColors(colors, color, alpha, size, offset = 0) {
          const bgr = Color.shared.setValue(color).toLittleEndianNumber(), result = Color.shared.setValue(bgr).toPremultiplied(alpha);
          colors.length = Math.max(colors.length, offset + size);
          for (let i2 = 0; i2 < size; i2++)
            colors[offset + i2] = result;
        }
        addTextureIds(textureIds, id, size, offset = 0) {
          textureIds.length = Math.max(textureIds.length, offset + size);
          for (let i2 = 0; i2 < size; i2++)
            textureIds[offset + i2] = id;
        }
        addUvs(verts, uvs, texture, start, size, matrix = null) {
          let index = 0;
          const uvsStart = uvs.length, frame = texture.frame;
          for (; index < size; ) {
            let x2 = verts[(start + index) * 2], y2 = verts[(start + index) * 2 + 1];
            if (matrix) {
              const nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
              y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty, x2 = nx;
            }
            index++, uvs.push(x2 / frame.width, y2 / frame.height);
          }
          const baseTexture = texture.baseTexture;
          (frame.width < baseTexture.width || frame.height < baseTexture.height) && this.adjustUvs(uvs, texture, uvsStart, size);
        }
        adjustUvs(uvs, texture, start, size) {
          const baseTexture = texture.baseTexture, eps = 1e-6, finish = start + size * 2, frame = texture.frame, scaleX = frame.width / baseTexture.width, scaleY = frame.height / baseTexture.height;
          let offsetX = frame.x / frame.width, offsetY = frame.y / frame.height, minX = Math.floor(uvs[start] + eps), minY = Math.floor(uvs[start + 1] + eps);
          for (let i2 = start + 2; i2 < finish; i2 += 2)
            minX = Math.min(minX, Math.floor(uvs[i2] + eps)), minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
          offsetX -= minX, offsetY -= minY;
          for (let i2 = start; i2 < finish; i2 += 2)
            uvs[i2] = (uvs[i2] + offsetX) * scaleX, uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
        }
      };
      _GraphicsGeometry.BATCHABLE_SIZE = 100;
      GraphicsGeometry = _GraphicsGeometry;
    }
  });

  // node_modules/@pixi/graphics/lib/styles/FillStyle.mjs
  var FillStyle;
  var init_FillStyle = __esm({
    "node_modules/@pixi/graphics/lib/styles/FillStyle.mjs"() {
      init_lib9();
      FillStyle = class {
        constructor() {
          this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = false, this.reset();
        }
        clone() {
          const obj = new FillStyle();
          return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj;
        }
        reset() {
          this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = false;
        }
        destroy() {
          this.texture = null, this.matrix = null;
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/styles/LineStyle.mjs
  var LineStyle;
  var init_LineStyle = __esm({
    "node_modules/@pixi/graphics/lib/styles/LineStyle.mjs"() {
      init_const5();
      init_FillStyle();
      LineStyle = class extends FillStyle {
        constructor() {
          super(...arguments), this.width = 0, this.alignment = 0.5, this.native = false, this.cap = LINE_CAP.BUTT, this.join = LINE_JOIN.MITER, this.miterLimit = 10;
        }
        clone() {
          const obj = new LineStyle();
          return obj.color = this.color, obj.alpha = this.alpha, obj.texture = this.texture, obj.matrix = this.matrix, obj.visible = this.visible, obj.width = this.width, obj.alignment = this.alignment, obj.native = this.native, obj.cap = this.cap, obj.join = this.join, obj.miterLimit = this.miterLimit, obj;
        }
        reset() {
          super.reset(), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = false, this.cap = LINE_CAP.BUTT, this.join = LINE_JOIN.MITER, this.miterLimit = 10;
        }
      };
    }
  });

  // node_modules/@pixi/graphics/lib/Graphics.mjs
  var DEFAULT_SHADERS, _Graphics, Graphics;
  var init_Graphics = __esm({
    "node_modules/@pixi/graphics/lib/Graphics.mjs"() {
      init_lib9();
      init_lib10();
      init_const5();
      init_GraphicsGeometry();
      init_FillStyle();
      init_LineStyle();
      init_utils4();
      init_QuadraticUtils();
      init_BezierUtils();
      init_ArcUtils();
      DEFAULT_SHADERS = {};
      _Graphics = class _Graphics2 extends Container {
        constructor(geometry = null) {
          super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new FillStyle(), this._lineStyle = new LineStyle(), this._matrix = null, this._holeMode = false, this.state = State.for2d(), this._geometry = geometry || new GraphicsGeometry(), this._geometry.refCount++, this._transformID = -1, this._tintColor = new Color(16777215), this.blendMode = BLEND_MODES.NORMAL;
        }
        get geometry() {
          return this._geometry;
        }
        clone() {
          return this.finishPoly(), new _Graphics2(this._geometry);
        }
        set blendMode(value) {
          this.state.blendMode = value;
        }
        get blendMode() {
          return this.state.blendMode;
        }
        get tint() {
          return this._tintColor.value;
        }
        set tint(value) {
          this._tintColor.setValue(value);
        }
        get fill() {
          return this._fillStyle;
        }
        get line() {
          return this._lineStyle;
        }
        lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
          return typeof options == "number" && (options = { width: options, color, alpha, alignment, native }), this.lineTextureStyle(options);
        }
        lineTextureStyle(options) {
          const defaultLineStyleOptions = {
            width: 0,
            texture: Texture.WHITE,
            color: options?.texture ? 16777215 : 0,
            matrix: null,
            alignment: 0.5,
            native: false,
            cap: LINE_CAP.BUTT,
            join: LINE_JOIN.MITER,
            miterLimit: 10
          };
          options = Object.assign(defaultLineStyleOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();
          const visible = options.width > 0 && options.alpha > 0;
          return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._lineStyle, { visible }, options)) : this._lineStyle.reset(), this;
        }
        startPoly() {
          if (this.currentPath) {
            const points = this.currentPath.points, len = this.currentPath.points.length;
            len > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = false, this.currentPath.points.push(points[len - 2], points[len - 1]));
          } else
            this.currentPath = new Polygon(), this.currentPath.closeStroke = false;
        }
        finishPoly() {
          this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
        }
        moveTo(x2, y2) {
          return this.startPoly(), this.currentPath.points[0] = x2, this.currentPath.points[1] = y2, this;
        }
        lineTo(x2, y2) {
          this.currentPath || this.moveTo(0, 0);
          const points = this.currentPath.points, fromX = points[points.length - 2], fromY = points[points.length - 1];
          return (fromX !== x2 || fromY !== y2) && points.push(x2, y2), this;
        }
        _initCurve(x2 = 0, y2 = 0) {
          this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [x2, y2]) : this.moveTo(x2, y2);
        }
        quadraticCurveTo(cpX, cpY, toX, toY) {
          this._initCurve();
          const points = this.currentPath.points;
          return points.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this;
        }
        bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
          return this._initCurve(), BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this;
        }
        arcTo(x1, y1, x2, y2, radius) {
          this._initCurve(x1, y1);
          const points = this.currentPath.points, result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
          if (result) {
            const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
            this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
          }
          return this;
        }
        arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
          if (startAngle === endAngle)
            return this;
          if (!anticlockwise && endAngle <= startAngle ? endAngle += PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += PI_2), endAngle - startAngle === 0)
            return this;
          const startX = cx + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius, eps = this._geometry.closePointEps;
          let points = this.currentPath ? this.currentPath.points : null;
          if (points) {
            const xDiff = Math.abs(points[points.length - 2] - startX), yDiff = Math.abs(points[points.length - 1] - startY);
            xDiff < eps && yDiff < eps || points.push(startX, startY);
          } else
            this.moveTo(startX, startY), points = this.currentPath.points;
          return ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points), this;
        }
        beginFill(color = 0, alpha) {
          return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
        }
        normalizeColor(options) {
          const temp = Color.shared.setValue(options.color ?? 0);
          options.color = temp.toNumber(), options.alpha ?? (options.alpha = temp.alpha);
        }
        beginTextureFill(options) {
          const defaultOptions = {
            texture: Texture.WHITE,
            color: 16777215,
            matrix: null
          };
          options = Object.assign(defaultOptions, options), this.normalizeColor(options), this.currentPath && this.startPoly();
          const visible = options.alpha > 0;
          return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._fillStyle, { visible }, options)) : this._fillStyle.reset(), this;
        }
        endFill() {
          return this.finishPoly(), this._fillStyle.reset(), this;
        }
        drawRect(x2, y2, width, height) {
          return this.drawShape(new Rectangle(x2, y2, width, height));
        }
        drawRoundedRect(x2, y2, width, height, radius) {
          return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));
        }
        drawCircle(x2, y2, radius) {
          return this.drawShape(new Circle(x2, y2, radius));
        }
        drawEllipse(x2, y2, width, height) {
          return this.drawShape(new Ellipse(x2, y2, width, height));
        }
        drawPolygon(...path3) {
          let points, closeStroke = true;
          const poly = path3[0];
          poly.points ? (closeStroke = poly.closeStroke, points = poly.points) : Array.isArray(path3[0]) ? points = path3[0] : points = path3;
          const shape = new Polygon(points);
          return shape.closeStroke = closeStroke, this.drawShape(shape), this;
        }
        drawShape(shape) {
          return this._holeMode ? this._geometry.drawHole(shape, this._matrix) : this._geometry.drawShape(
            shape,
            this._fillStyle.clone(),
            this._lineStyle.clone(),
            this._matrix
          ), this;
        }
        clear() {
          return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = false, this.currentPath = null, this;
        }
        isFastRect() {
          const data = this._geometry.graphicsData;
          return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
        }
        _render(renderer) {
          this.finishPoly();
          const geometry = this._geometry;
          geometry.updateBatches(), geometry.batchable ? (this.batchDirty !== geometry.batchDirty && this._populateBatches(), this._renderBatched(renderer)) : (renderer.batch.flush(), this._renderDirect(renderer));
        }
        _populateBatches() {
          const geometry = this._geometry, blendMode = this.blendMode, len = geometry.batches.length;
          this.batchTint = -1, this._transformID = -1, this.batchDirty = geometry.batchDirty, this.batches.length = len, this.vertexData = new Float32Array(geometry.points);
          for (let i2 = 0; i2 < len; i2++) {
            const gI = geometry.batches[i2], color = gI.style.color, vertexData = new Float32Array(
              this.vertexData.buffer,
              gI.attribStart * 4 * 2,
              gI.attribSize * 2
            ), uvs = new Float32Array(
              geometry.uvsFloat32.buffer,
              gI.attribStart * 4 * 2,
              gI.attribSize * 2
            ), indices2 = new Uint16Array(
              geometry.indicesUint16.buffer,
              gI.start * 2,
              gI.size
            ), batch = {
              vertexData,
              blendMode,
              indices: indices2,
              uvs,
              _batchRGB: Color.shared.setValue(color).toRgbArray(),
              _tintRGB: color,
              _texture: gI.style.texture,
              alpha: gI.style.alpha,
              worldAlpha: 1
            };
            this.batches[i2] = batch;
          }
        }
        _renderBatched(renderer) {
          if (this.batches.length) {
            renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
            for (let i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
              const batch = this.batches[i2];
              batch.worldAlpha = this.worldAlpha * batch.alpha, renderer.plugins[this.pluginName].render(batch);
            }
          }
        }
        _renderDirect(renderer) {
          const shader = this._resolveDirectShader(renderer), geometry = this._geometry, worldAlpha = this.worldAlpha, uniforms = shader.uniforms, drawCalls = geometry.drawCalls;
          uniforms.translationMatrix = this.transform.worldTransform, Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint), renderer.shader.bind(shader), renderer.geometry.bind(geometry, shader), renderer.state.set(this.state);
          for (let i2 = 0, l2 = drawCalls.length; i2 < l2; i2++)
            this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);
        }
        _renderDrawCallDirect(renderer, drawCall) {
          const { texArray, type, size, start } = drawCall, groupTextureCount = texArray.count;
          for (let j2 = 0; j2 < groupTextureCount; j2++)
            renderer.texture.bind(texArray.elements[j2], j2);
          renderer.geometry.draw(type, size, start);
        }
        _resolveDirectShader(renderer) {
          let shader = this.shader;
          const pluginName = this.pluginName;
          if (!shader) {
            if (!DEFAULT_SHADERS[pluginName]) {
              const { maxTextures: maxTextures2 } = renderer.plugins[pluginName], sampleValues = new Int32Array(maxTextures2);
              for (let i2 = 0; i2 < maxTextures2; i2++)
                sampleValues[i2] = i2;
              const uniforms = {
                tint: new Float32Array([1, 1, 1, 1]),
                translationMatrix: new Matrix(),
                default: UniformGroup.from({ uSamplers: sampleValues }, true)
              }, program = renderer.plugins[pluginName]._shader.program;
              DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
            }
            shader = DEFAULT_SHADERS[pluginName];
          }
          return shader;
        }
        _calculateBounds() {
          this.finishPoly();
          const geometry = this._geometry;
          if (!geometry.graphicsData.length)
            return;
          const { minX, minY, maxX, maxY } = geometry.bounds;
          this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
        }
        containsPoint(point) {
          return this.worldTransform.applyInverse(point, _Graphics2._TEMP_POINT), this._geometry.containsPoint(_Graphics2._TEMP_POINT);
        }
        calculateTints() {
          if (this.batchTint !== this.tint) {
            this.batchTint = this._tintColor.toNumber();
            for (let i2 = 0; i2 < this.batches.length; i2++) {
              const batch = this.batches[i2];
              batch._tintRGB = Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
            }
          }
        }
        calculateVertices() {
          const wtID = this.transform._worldID;
          if (this._transformID === wtID)
            return;
          this._transformID = wtID;
          const wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, data = this._geometry.points, vertexData = this.vertexData;
          let count2 = 0;
          for (let i2 = 0; i2 < data.length; i2 += 2) {
            const x2 = data[i2], y2 = data[i2 + 1];
            vertexData[count2++] = a2 * x2 + c2 * y2 + tx, vertexData[count2++] = d2 * y2 + b2 * x2 + ty;
          }
        }
        closePath() {
          const currentPath = this.currentPath;
          return currentPath && (currentPath.closeStroke = true, this.finishPoly()), this;
        }
        setMatrix(matrix) {
          return this._matrix = matrix, this;
        }
        beginHole() {
          return this.finishPoly(), this._holeMode = true, this;
        }
        endHole() {
          return this.finishPoly(), this._holeMode = false, this;
        }
        destroy(options) {
          this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(options);
        }
      };
      _Graphics.curves = curves, _Graphics._TEMP_POINT = new Point();
      Graphics = _Graphics;
    }
  });

  // node_modules/@pixi/graphics/lib/index.mjs
  var init_lib27 = __esm({
    "node_modules/@pixi/graphics/lib/index.mjs"() {
      init_utils4();
      init_const5();
      init_Graphics();
      init_GraphicsData();
      init_GraphicsGeometry();
      init_FillStyle();
      init_LineStyle();
      init_buildPoly();
      init_buildCircle();
      init_buildRectangle();
      init_buildRoundedRectangle();
      init_buildLine();
      init_ArcUtils();
      init_BezierUtils();
      init_QuadraticUtils();
      init_BatchPart();
    }
  });

  // node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs
  var MeshBatchUvs;
  var init_MeshBatchUvs = __esm({
    "node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs"() {
      MeshBatchUvs = class {
        constructor(uvBuffer, uvMatrix) {
          this.uvBuffer = uvBuffer, this.uvMatrix = uvMatrix, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
        }
        update(forceUpdate) {
          if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
            return;
          this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
          const data = this.uvBuffer.data;
          (!this.data || this.data.length !== data.length) && (this.data = new Float32Array(data.length)), this.uvMatrix.multiplyUvs(data, this.data), this._updateID++;
        }
      };
    }
  });

  // node_modules/@pixi/mesh/lib/Mesh.mjs
  var tempPoint2, tempPolygon, _Mesh, Mesh;
  var init_Mesh = __esm({
    "node_modules/@pixi/mesh/lib/Mesh.mjs"() {
      init_lib9();
      init_lib10();
      init_MeshBatchUvs();
      tempPoint2 = new Point();
      tempPolygon = new Polygon();
      _Mesh = class _Mesh2 extends Container {
        constructor(geometry, shader, state, drawMode = DRAW_MODES.TRIANGLES) {
          super(), this.geometry = geometry, this.shader = shader, this.state = state || State.for2d(), this.drawMode = drawMode, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = settings.ROUND_PIXELS, this.batchUvs = null;
        }
        get geometry() {
          return this._geometry;
        }
        set geometry(value) {
          this._geometry !== value && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
        }
        get uvBuffer() {
          return this.geometry.buffers[1];
        }
        get verticesBuffer() {
          return this.geometry.buffers[0];
        }
        set material(value) {
          this.shader = value;
        }
        get material() {
          return this.shader;
        }
        set blendMode(value) {
          this.state.blendMode = value;
        }
        get blendMode() {
          return this.state.blendMode;
        }
        set roundPixels(value) {
          this._roundPixels !== value && (this._transformID = -1), this._roundPixels = value;
        }
        get roundPixels() {
          return this._roundPixels;
        }
        get tint() {
          return "tint" in this.shader ? this.shader.tint : null;
        }
        set tint(value) {
          this.shader.tint = value;
        }
        get tintValue() {
          return this.shader.tintValue;
        }
        get texture() {
          return "texture" in this.shader ? this.shader.texture : null;
        }
        set texture(value) {
          this.shader.texture = value;
        }
        _render(renderer) {
          const vertices = this.geometry.buffers[0].data;
          this.shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh2.BATCHABLE_SIZE * 2 ? this._renderToBatch(renderer) : this._renderDefault(renderer);
        }
        _renderDefault(renderer) {
          const shader = this.shader;
          shader.alpha = this.worldAlpha, shader.update && shader.update(), renderer.batch.flush(), shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true), renderer.shader.bind(shader), renderer.state.set(this.state), renderer.geometry.bind(this.geometry, shader), renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
        }
        _renderToBatch(renderer) {
          const geometry = this.geometry, shader = this.shader;
          shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = geometry.indexBuffer.data, this._tintRGB = shader._tintRGB, this._texture = shader.texture;
          const pluginName = this.material.pluginName;
          renderer.batch.setObjectRenderer(renderer.plugins[pluginName]), renderer.plugins[pluginName].render(this);
        }
        calculateVertices() {
          const verticesBuffer = this.geometry.buffers[0], vertices = verticesBuffer.data, vertexDirtyId = verticesBuffer._updateID;
          if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)
            return;
          this._transformID = this.transform._worldID, this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));
          const wt = this.transform.worldTransform, a2 = wt.a, b2 = wt.b, c2 = wt.c, d2 = wt.d, tx = wt.tx, ty = wt.ty, vertexData = this.vertexData;
          for (let i2 = 0; i2 < vertexData.length / 2; i2++) {
            const x2 = vertices[i2 * 2], y2 = vertices[i2 * 2 + 1];
            vertexData[i2 * 2] = a2 * x2 + c2 * y2 + tx, vertexData[i2 * 2 + 1] = b2 * x2 + d2 * y2 + ty;
          }
          if (this._roundPixels) {
            const resolution = settings.RESOLUTION;
            for (let i2 = 0; i2 < vertexData.length; ++i2)
              vertexData[i2] = Math.round(vertexData[i2] * resolution) / resolution;
          }
          this.vertexDirty = vertexDirtyId;
        }
        calculateUvs() {
          const geomUvs = this.geometry.buffers[1], shader = this.shader;
          shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
        }
        _calculateBounds() {
          this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
        }
        containsPoint(point) {
          if (!this.getBounds().contains(point.x, point.y))
            return false;
          this.worldTransform.applyInverse(point, tempPoint2);
          const vertices = this.geometry.getBuffer("aVertexPosition").data, points = tempPolygon.points, indices2 = this.geometry.getIndex().data, len = indices2.length, step = this.drawMode === 4 ? 3 : 1;
          for (let i2 = 0; i2 + 2 < len; i2 += step) {
            const ind0 = indices2[i2] * 2, ind1 = indices2[i2 + 1] * 2, ind2 = indices2[i2 + 2] * 2;
            if (points[0] = vertices[ind0], points[1] = vertices[ind0 + 1], points[2] = vertices[ind1], points[3] = vertices[ind1 + 1], points[4] = vertices[ind2], points[5] = vertices[ind2 + 1], tempPolygon.contains(tempPoint2.x, tempPoint2.y))
              return true;
          }
          return false;
        }
        destroy(options) {
          super.destroy(options), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
        }
      };
      _Mesh.BATCHABLE_SIZE = 100;
      Mesh = _Mesh;
    }
  });

  // node_modules/@pixi/mesh/lib/MeshGeometry.mjs
  var MeshGeometry;
  var init_MeshGeometry = __esm({
    "node_modules/@pixi/mesh/lib/MeshGeometry.mjs"() {
      init_lib9();
      MeshGeometry = class extends Geometry {
        constructor(vertices, uvs, index) {
          super();
          const verticesBuffer = new Buffer2(vertices), uvsBuffer = new Buffer2(uvs, true), indexBuffer = new Buffer2(index, true, true);
          this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer), this._updateId = -1;
        }
        get vertexDirtyId() {
          return this.buffers[0]._updateID;
        }
      };
    }
  });

  // node_modules/@pixi/mesh/lib/shader/mesh.frag.mjs
  var fragment7;
  var init_mesh_frag = __esm({
    "node_modules/@pixi/mesh/lib/shader/mesh.frag.mjs"() {
      fragment7 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`;
    }
  });

  // node_modules/@pixi/mesh/lib/shader/mesh.vert.mjs
  var vertex4;
  var init_mesh_vert = __esm({
    "node_modules/@pixi/mesh/lib/shader/mesh.vert.mjs"() {
      vertex4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
    }
  });

  // node_modules/@pixi/mesh/lib/MeshMaterial.mjs
  var MeshMaterial;
  var init_MeshMaterial = __esm({
    "node_modules/@pixi/mesh/lib/MeshMaterial.mjs"() {
      init_lib9();
      init_mesh_frag();
      init_mesh_vert();
      MeshMaterial = class extends Shader {
        constructor(uSampler, options) {
          const uniforms = {
            uSampler,
            alpha: 1,
            uTextureMatrix: Matrix.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
          };
          options = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
          }, options), options.uniforms && Object.assign(uniforms, options.uniforms), super(options.program || Program.from(vertex4, fragment7), uniforms), this._colorDirty = false, this.uvMatrix = new TextureMatrix(uSampler), this.batchable = options.program === void 0, this.pluginName = options.pluginName, this._tintColor = new Color(options.tint), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = true, this.alpha = options.alpha;
        }
        get texture() {
          return this.uniforms.uSampler;
        }
        set texture(value) {
          this.uniforms.uSampler !== value && (!this.uniforms.uSampler.baseTexture.alphaMode != !value.baseTexture.alphaMode && (this._colorDirty = true), this.uniforms.uSampler = value, this.uvMatrix.texture = value);
        }
        set alpha(value) {
          value !== this._alpha && (this._alpha = value, this._colorDirty = true);
        }
        get alpha() {
          return this._alpha;
        }
        set tint(value) {
          value !== this.tint && (this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = true);
        }
        get tint() {
          return this._tintColor.value;
        }
        get tintValue() {
          return this._tintColor.toNumber();
        }
        update() {
          if (this._colorDirty) {
            this._colorDirty = false;
            const applyToChannels = this.texture.baseTexture.alphaMode;
            Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
          }
          this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
        }
      };
    }
  });

  // node_modules/@pixi/mesh/lib/index.mjs
  var init_lib28 = __esm({
    "node_modules/@pixi/mesh/lib/index.mjs"() {
      init_Mesh();
      init_MeshBatchUvs();
      init_MeshGeometry();
      init_MeshMaterial();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs
  var init_PlaneGeometry = __esm({
    "node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs"() {
      init_lib28();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs
  var init_RopeGeometry = __esm({
    "node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs"() {
      init_lib28();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs
  var init_SimplePlane = __esm({
    "node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs"() {
      init_lib9();
      init_lib28();
      init_PlaneGeometry();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs
  var init_NineSlicePlane = __esm({
    "node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs"() {
      init_lib9();
      init_SimplePlane();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs
  var init_SimpleMesh = __esm({
    "node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs"() {
      init_lib9();
      init_lib28();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs
  var init_SimpleRope = __esm({
    "node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs"() {
      init_lib9();
      init_lib28();
      init_RopeGeometry();
    }
  });

  // node_modules/@pixi/mesh-extras/lib/index.mjs
  var init_lib29 = __esm({
    "node_modules/@pixi/mesh-extras/lib/index.mjs"() {
      init_PlaneGeometry();
      init_RopeGeometry();
      init_NineSlicePlane();
      init_SimpleMesh();
      init_SimplePlane();
      init_SimpleRope();
    }
  });

  // node_modules/@pixi/particle-container/lib/ParticleContainer.mjs
  var init_ParticleContainer = __esm({
    "node_modules/@pixi/particle-container/lib/ParticleContainer.mjs"() {
      init_lib9();
      init_lib10();
    }
  });

  // node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs
  var ParticleBuffer;
  var init_ParticleBuffer = __esm({
    "node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs"() {
      init_lib9();
      ParticleBuffer = class {
        constructor(properties, dynamicPropertyFlags, size) {
          this.geometry = new Geometry(), this.indexBuffer = null, this.size = size, this.dynamicProperties = [], this.staticProperties = [];
          for (let i2 = 0; i2 < properties.length; ++i2) {
            let property = properties[i2];
            property = {
              attributeName: property.attributeName,
              size: property.size,
              uploadFunction: property.uploadFunction,
              type: property.type || TYPES.FLOAT,
              offset: property.offset
            }, dynamicPropertyFlags[i2] ? this.dynamicProperties.push(property) : this.staticProperties.push(property);
          }
          this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
        }
        initBuffers() {
          const geometry = this.geometry;
          let dynamicOffset = 0;
          this.indexBuffer = new Buffer2(lib_exports.createIndicesForQuads(this.size), true, true), geometry.addIndex(this.indexBuffer), this.dynamicStride = 0;
          for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
            const property = this.dynamicProperties[i2];
            property.offset = dynamicOffset, dynamicOffset += property.size, this.dynamicStride += property.size;
          }
          const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
          this.dynamicData = new Float32Array(dynBuffer), this.dynamicDataUint32 = new Uint32Array(dynBuffer), this.dynamicBuffer = new Buffer2(this.dynamicData, false, false);
          let staticOffset = 0;
          this.staticStride = 0;
          for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
            const property = this.staticProperties[i2];
            property.offset = staticOffset, staticOffset += property.size, this.staticStride += property.size;
          }
          const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
          this.staticData = new Float32Array(statBuffer), this.staticDataUint32 = new Uint32Array(statBuffer), this.staticBuffer = new Buffer2(this.staticData, true, false);
          for (let i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
            const property = this.dynamicProperties[i2];
            geometry.addAttribute(
              property.attributeName,
              this.dynamicBuffer,
              0,
              property.type === TYPES.UNSIGNED_BYTE,
              property.type,
              this.dynamicStride * 4,
              property.offset * 4
            );
          }
          for (let i2 = 0; i2 < this.staticProperties.length; ++i2) {
            const property = this.staticProperties[i2];
            geometry.addAttribute(
              property.attributeName,
              this.staticBuffer,
              0,
              property.type === TYPES.UNSIGNED_BYTE,
              property.type,
              this.staticStride * 4,
              property.offset * 4
            );
          }
        }
        uploadDynamic(children, startIndex, amount) {
          for (let i2 = 0; i2 < this.dynamicProperties.length; i2++) {
            const property = this.dynamicProperties[i2];
            property.uploadFunction(
              children,
              startIndex,
              amount,
              property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,
              this.dynamicStride,
              property.offset
            );
          }
          this.dynamicBuffer._updateID++;
        }
        uploadStatic(children, startIndex, amount) {
          for (let i2 = 0; i2 < this.staticProperties.length; i2++) {
            const property = this.staticProperties[i2];
            property.uploadFunction(
              children,
              startIndex,
              amount,
              property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,
              this.staticStride,
              property.offset
            );
          }
          this.staticBuffer._updateID++;
        }
        destroy() {
          this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
        }
      };
    }
  });

  // node_modules/@pixi/particle-container/lib/particles.frag.mjs
  var fragment8;
  var init_particles_frag = __esm({
    "node_modules/@pixi/particle-container/lib/particles.frag.mjs"() {
      fragment8 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`;
    }
  });

  // node_modules/@pixi/particle-container/lib/particles.vert.mjs
  var vertex5;
  var init_particles_vert = __esm({
    "node_modules/@pixi/particle-container/lib/particles.vert.mjs"() {
      vertex5 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
    }
  });

  // node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs
  var ParticleRenderer;
  var init_ParticleRenderer = __esm({
    "node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs"() {
      init_lib9();
      init_ParticleBuffer();
      init_particles_frag();
      init_particles_vert();
      ParticleRenderer = class extends ObjectRenderer {
        constructor(renderer) {
          super(renderer), this.shader = null, this.properties = null, this.tempMatrix = new Matrix(), this.properties = [
            {
              attributeName: "aVertexPosition",
              size: 2,
              uploadFunction: this.uploadVertices,
              offset: 0
            },
            {
              attributeName: "aPositionCoord",
              size: 2,
              uploadFunction: this.uploadPosition,
              offset: 0
            },
            {
              attributeName: "aRotation",
              size: 1,
              uploadFunction: this.uploadRotation,
              offset: 0
            },
            {
              attributeName: "aTextureCoord",
              size: 2,
              uploadFunction: this.uploadUvs,
              offset: 0
            },
            {
              attributeName: "aColor",
              size: 1,
              type: TYPES.UNSIGNED_BYTE,
              uploadFunction: this.uploadTint,
              offset: 0
            }
          ], this.shader = Shader.from(vertex5, fragment8, {}), this.state = State.for2d();
        }
        render(container) {
          const children = container.children, maxSize = container._maxSize, batchSize = container._batchSize, renderer = this.renderer;
          let totalChildren = children.length;
          if (totalChildren === 0)
            return;
          totalChildren > maxSize && !container.autoResize && (totalChildren = maxSize);
          let buffers = container._buffers;
          buffers || (buffers = container._buffers = this.generateBuffers(container));
          const baseTexture = children[0]._texture.baseTexture, premultiplied = baseTexture.alphaMode > 0;
          this.state.blendMode = lib_exports.correctBlendMode(container.blendMode, premultiplied), renderer.state.set(this.state);
          const gl = renderer.gl, m2 = container.worldTransform.copyTo(this.tempMatrix);
          m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = m2.toArray(true), this.shader.uniforms.uColor = Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor), this.shader.uniforms.uSampler = baseTexture, this.renderer.shader.bind(this.shader);
          let updateStatic = false;
          for (let i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
            let amount = totalChildren - i2;
            amount > batchSize && (amount = batchSize), j2 >= buffers.length && buffers.push(this._generateOneMoreBuffer(container));
            const buffer = buffers[j2];
            buffer.uploadDynamic(children, i2, amount);
            const bid = container._bufferUpdateIDs[j2] || 0;
            updateStatic = updateStatic || buffer._updateID < bid, updateStatic && (buffer._updateID = container._updateID, buffer.uploadStatic(children, i2, amount)), renderer.geometry.bind(buffer.geometry), gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
          }
        }
        generateBuffers(container) {
          const buffers = [], size = container._maxSize, batchSize = container._batchSize, dynamicPropertyFlags = container._properties;
          for (let i2 = 0; i2 < size; i2 += batchSize)
            buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
          return buffers;
        }
        _generateOneMoreBuffer(container) {
          const batchSize = container._batchSize, dynamicPropertyFlags = container._properties;
          return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
        }
        uploadVertices(children, startIndex, amount, array, stride, offset) {
          let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
          for (let i2 = 0; i2 < amount; ++i2) {
            const sprite = children[startIndex + i2], texture = sprite._texture, sx = sprite.scale.x, sy = sprite.scale.y, trim = texture.trim, orig = texture.orig;
            trim ? (w1 = trim.x - sprite.anchor.x * orig.width, w0 = w1 + trim.width, h1 = trim.y - sprite.anchor.y * orig.height, h0 = h1 + trim.height) : (w0 = orig.width * (1 - sprite.anchor.x), w1 = orig.width * -sprite.anchor.x, h0 = orig.height * (1 - sprite.anchor.y), h1 = orig.height * -sprite.anchor.y), array[offset] = w1 * sx, array[offset + 1] = h1 * sy, array[offset + stride] = w0 * sx, array[offset + stride + 1] = h1 * sy, array[offset + stride * 2] = w0 * sx, array[offset + stride * 2 + 1] = h0 * sy, array[offset + stride * 3] = w1 * sx, array[offset + stride * 3 + 1] = h0 * sy, offset += stride * 4;
          }
        }
        uploadPosition(children, startIndex, amount, array, stride, offset) {
          for (let i2 = 0; i2 < amount; i2++) {
            const spritePosition = children[startIndex + i2].position;
            array[offset] = spritePosition.x, array[offset + 1] = spritePosition.y, array[offset + stride] = spritePosition.x, array[offset + stride + 1] = spritePosition.y, array[offset + stride * 2] = spritePosition.x, array[offset + stride * 2 + 1] = spritePosition.y, array[offset + stride * 3] = spritePosition.x, array[offset + stride * 3 + 1] = spritePosition.y, offset += stride * 4;
          }
        }
        uploadRotation(children, startIndex, amount, array, stride, offset) {
          for (let i2 = 0; i2 < amount; i2++) {
            const spriteRotation = children[startIndex + i2].rotation;
            array[offset] = spriteRotation, array[offset + stride] = spriteRotation, array[offset + stride * 2] = spriteRotation, array[offset + stride * 3] = spriteRotation, offset += stride * 4;
          }
        }
        uploadUvs(children, startIndex, amount, array, stride, offset) {
          for (let i2 = 0; i2 < amount; ++i2) {
            const textureUvs = children[startIndex + i2]._texture._uvs;
            textureUvs ? (array[offset] = textureUvs.x0, array[offset + 1] = textureUvs.y0, array[offset + stride] = textureUvs.x1, array[offset + stride + 1] = textureUvs.y1, array[offset + stride * 2] = textureUvs.x2, array[offset + stride * 2 + 1] = textureUvs.y2, array[offset + stride * 3] = textureUvs.x3, array[offset + stride * 3 + 1] = textureUvs.y3, offset += stride * 4) : (array[offset] = 0, array[offset + 1] = 0, array[offset + stride] = 0, array[offset + stride + 1] = 0, array[offset + stride * 2] = 0, array[offset + stride * 2 + 1] = 0, array[offset + stride * 3] = 0, array[offset + stride * 3 + 1] = 0, offset += stride * 4);
          }
        }
        uploadTint(children, startIndex, amount, array, stride, offset) {
          for (let i2 = 0; i2 < amount; ++i2) {
            const sprite = children[startIndex + i2], result = Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
            array[offset] = result, array[offset + stride] = result, array[offset + stride * 2] = result, array[offset + stride * 3] = result, offset += stride * 4;
          }
        }
        destroy() {
          super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
        }
      };
      ParticleRenderer.extension = {
        name: "particle",
        type: ExtensionType.RendererPlugin
      };
      extensions.add(ParticleRenderer);
    }
  });

  // node_modules/@pixi/particle-container/lib/index.mjs
  var init_lib30 = __esm({
    "node_modules/@pixi/particle-container/lib/index.mjs"() {
      init_ParticleContainer();
      init_ParticleRenderer();
    }
  });

  // node_modules/@pixi/text/lib/const.mjs
  var TEXT_GRADIENT;
  var init_const6 = __esm({
    "node_modules/@pixi/text/lib/const.mjs"() {
      TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => (TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", TEXT_GRADIENT2[TEXT_GRADIENT2.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", TEXT_GRADIENT2))(TEXT_GRADIENT || {});
    }
  });

  // node_modules/@pixi/text/lib/TextMetrics.mjs
  var contextSettings, _TextMetrics, TextMetrics;
  var init_TextMetrics = __esm({
    "node_modules/@pixi/text/lib/TextMetrics.mjs"() {
      init_lib9();
      contextSettings = {
        willReadFrequently: true
      };
      _TextMetrics = class _TextMetrics2 {
        static get experimentalLetterSpacingSupported() {
          let result = _TextMetrics2._experimentalLetterSpacingSupported;
          if (result !== void 0) {
            const proto = settings.ADAPTER.getCanvasRenderingContext2D().prototype;
            result = _TextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties;
        }
        static measureText(text, style, wordWrap, canvas = _TextMetrics2._canvas) {
          wordWrap = wordWrap ?? style.wordWrap;
          const font = style.toFontString(), fontProperties = _TextMetrics2.measureFont(font);
          fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);
          const context3 = canvas.getContext("2d", contextSettings);
          context3.font = font;
          const lines = (wordWrap ? _TextMetrics2.wordWrap(text, style, canvas) : text).split(/(?:\r\n|\r|\n)/), lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i2 = 0; i2 < lines.length; i2++) {
            const lineWidth = _TextMetrics2._measureText(lines[i2], style.letterSpacing, context3);
            lineWidths[i2] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          let width = maxLineWidth + style.strokeThickness;
          style.dropShadow && (width += style.dropShadowDistance);
          const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
          let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + style.leading + (lines.length - 1) * (lineHeight + style.leading);
          return style.dropShadow && (height += style.dropShadowDistance), new _TextMetrics2(
            text,
            style,
            width,
            height,
            lines,
            lineWidths,
            lineHeight + style.leading,
            maxLineWidth,
            fontProperties
          );
        }
        static _measureText(text, letterSpacing, context3) {
          let useExperimentalLetterSpacing = false;
          _TextMetrics2.experimentalLetterSpacingSupported && (_TextMetrics2.experimentalLetterSpacing ? (context3.letterSpacing = `${letterSpacing}px`, context3.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = true) : (context3.letterSpacing = "0px", context3.textLetterSpacing = "0px"));
          let width = context3.measureText(text).width;
          return width > 0 && (useExperimentalLetterSpacing ? width -= letterSpacing : width += (_TextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing), width;
        }
        static wordWrap(text, style, canvas = _TextMetrics2._canvas) {
          const context3 = canvas.getContext("2d", contextSettings);
          let width = 0, line = "", lines = "";
          const cache = /* @__PURE__ */ Object.create(null), { letterSpacing, whiteSpace } = style, collapseSpaces = _TextMetrics2.collapseSpaces(whiteSpace), collapseNewlines = _TextMetrics2.collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = _TextMetrics2.tokenize(text);
          for (let i2 = 0; i2 < tokens.length; i2++) {
            let token = tokens[i2];
            if (_TextMetrics2.isNewline(token)) {
              if (!collapseNewlines) {
                lines += _TextMetrics2.addLine(line), canPrependSpaces = !collapseSpaces, line = "", width = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _TextMetrics2.isBreakingSpace(token), lastIsBreakingSpace = _TextMetrics2.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace)
                continue;
            }
            const tokenWidth = _TextMetrics2.getFromCache(token, letterSpacing, cache, context3);
            if (tokenWidth > wordWrapWidth)
              if (line !== "" && (lines += _TextMetrics2.addLine(line), line = "", width = 0), _TextMetrics2.canBreakWords(token, style.breakWords)) {
                const characters = _TextMetrics2.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char = characters[j2], lastChar = char, k2 = 1;
                  for (; characters[j2 + k2]; ) {
                    const nextChar = characters[j2 + k2];
                    if (!_TextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords))
                      char += nextChar;
                    else
                      break;
                    lastChar = nextChar, k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _TextMetrics2.getFromCache(char, letterSpacing, cache, context3);
                  characterWidth + width > wordWrapWidth && (lines += _TextMetrics2.addLine(line), canPrependSpaces = false, line = "", width = 0), line += char, width += characterWidth;
                }
              } else {
                line.length > 0 && (lines += _TextMetrics2.addLine(line), line = "", width = 0);
                const isLastToken = i2 === tokens.length - 1;
                lines += _TextMetrics2.addLine(token, !isLastToken), canPrependSpaces = false, line = "", width = 0;
              }
            else
              tokenWidth + width > wordWrapWidth && (canPrependSpaces = false, lines += _TextMetrics2.addLine(line), line = "", width = 0), (line.length > 0 || !_TextMetrics2.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += tokenWidth);
          }
          return lines += _TextMetrics2.addLine(line, false), lines;
        }
        static addLine(line, newLine = true) {
          return line = _TextMetrics2.trimRight(line), line = newLine ? `${line}
` : line, line;
        }
        static getFromCache(key, letterSpacing, cache, context3) {
          let width = cache[key];
          return typeof width != "number" && (width = _TextMetrics2._measureText(key, letterSpacing, context3) + letterSpacing, cache[key] = width), width;
        }
        static collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        static collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        static trimRight(text) {
          if (typeof text != "string")
            return "";
          for (let i2 = text.length - 1; i2 >= 0; i2--) {
            const char = text[i2];
            if (!_TextMetrics2.isBreakingSpace(char))
              break;
            text = text.slice(0, -1);
          }
          return text;
        }
        static isNewline(char) {
          return typeof char != "string" ? false : _TextMetrics2._newlines.includes(char.charCodeAt(0));
        }
        static isBreakingSpace(char, _nextChar) {
          return typeof char != "string" ? false : _TextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
        }
        static tokenize(text) {
          const tokens = [];
          let token = "";
          if (typeof text != "string")
            return tokens;
          for (let i2 = 0; i2 < text.length; i2++) {
            const char = text[i2], nextChar = text[i2 + 1];
            if (_TextMetrics2.isBreakingSpace(char, nextChar) || _TextMetrics2.isNewline(char)) {
              token !== "" && (tokens.push(token), token = ""), tokens.push(char);
              continue;
            }
            token += char;
          }
          return token !== "" && tokens.push(token), tokens;
        }
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        static wordWrapSplit(token) {
          return _TextMetrics2.graphemeSegmenter(token);
        }
        static measureFont(font) {
          if (_TextMetrics2._fonts[font])
            return _TextMetrics2._fonts[font];
          const properties = {
            ascent: 0,
            descent: 0,
            fontSize: 0
          }, canvas = _TextMetrics2._canvas, context3 = _TextMetrics2._context;
          context3.font = font;
          const metricsString = _TextMetrics2.METRICS_STRING + _TextMetrics2.BASELINE_SYMBOL, width = Math.ceil(context3.measureText(metricsString).width);
          let baseline = Math.ceil(context3.measureText(_TextMetrics2.BASELINE_SYMBOL).width);
          const height = Math.ceil(_TextMetrics2.HEIGHT_MULTIPLIER * baseline);
          if (baseline = baseline * _TextMetrics2.BASELINE_MULTIPLIER | 0, width === 0 || height === 0)
            return _TextMetrics2._fonts[font] = properties, properties;
          canvas.width = width, canvas.height = height, context3.fillStyle = "#f00", context3.fillRect(0, 0, width, height), context3.font = font, context3.textBaseline = "alphabetic", context3.fillStyle = "#000", context3.fillText(metricsString, 0, baseline);
          const imagedata = context3.getImageData(0, 0, width, height).data, pixels = imagedata.length, line = width * 4;
          let i2 = 0, idx = 0, stop = false;
          for (i2 = 0; i2 < baseline; ++i2) {
            for (let j2 = 0; j2 < line; j2 += 4)
              if (imagedata[idx + j2] !== 255) {
                stop = true;
                break;
              }
            if (!stop)
              idx += line;
            else
              break;
          }
          for (properties.ascent = baseline - i2, idx = pixels - line, stop = false, i2 = height; i2 > baseline; --i2) {
            for (let j2 = 0; j2 < line; j2 += 4)
              if (imagedata[idx + j2] !== 255) {
                stop = true;
                break;
              }
            if (!stop)
              idx -= line;
            else
              break;
          }
          return properties.descent = i2 - baseline, properties.fontSize = properties.ascent + properties.descent, _TextMetrics2._fonts[font] = properties, properties;
        }
        static clearMetrics(font = "") {
          font ? delete _TextMetrics2._fonts[font] : _TextMetrics2._fonts = {};
        }
        static get _canvas() {
          if (!_TextMetrics2.__canvas) {
            let canvas;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              if (c2.getContext("2d", contextSettings)?.measureText)
                return _TextMetrics2.__canvas = c2, c2;
              canvas = settings.ADAPTER.createCanvas();
            } catch {
              canvas = settings.ADAPTER.createCanvas();
            }
            canvas.width = canvas.height = 10, _TextMetrics2.__canvas = canvas;
          }
          return _TextMetrics2.__canvas;
        }
        static get _context() {
          return _TextMetrics2.__context || (_TextMetrics2.__context = _TextMetrics2._canvas.getContext("2d", contextSettings)), _TextMetrics2.__context;
        }
      };
      _TextMetrics.METRICS_STRING = "|\xC9q\xC5", _TextMetrics.BASELINE_SYMBOL = "M", _TextMetrics.BASELINE_MULTIPLIER = 1.4, _TextMetrics.HEIGHT_MULTIPLIER = 2, _TextMetrics.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter == "function") {
          const segmenter = new Intl.Segmenter();
          return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
        }
        return (s2) => [...s2];
      })(), _TextMetrics.experimentalLetterSpacing = false, _TextMetrics._fonts = {}, _TextMetrics._newlines = [
        10,
        13
      ], _TextMetrics._breakingSpaces = [
        9,
        32,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8200,
        8201,
        8202,
        8287,
        12288
      ];
      TextMetrics = _TextMetrics;
    }
  });

  // node_modules/@pixi/text/lib/TextStyle.mjs
  function getColor(color) {
    const temp = Color.shared, format2 = (color2) => {
      const res = temp.setValue(color2);
      return res.alpha === 1 ? res.toHex() : res.toRgbaString();
    };
    return Array.isArray(color) ? color.map(format2) : format2(color);
  }
  function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length)
      return false;
    for (let i2 = 0; i2 < array1.length; ++i2)
      if (array1[i2] !== array2[i2])
        return false;
    return true;
  }
  function deepCopyProperties(target, source2, propertyObj) {
    for (const prop in propertyObj)
      Array.isArray(source2[prop]) ? target[prop] = source2[prop].slice() : target[prop] = source2[prop];
  }
  var genericFontFamilies, _TextStyle, TextStyle;
  var init_TextStyle = __esm({
    "node_modules/@pixi/text/lib/TextStyle.mjs"() {
      init_const6();
      init_lib9();
      genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
      _TextStyle = class _TextStyle2 {
        constructor(style) {
          this.styleID = 0, this.reset(), deepCopyProperties(this, style, style);
        }
        clone() {
          const clonedProperties = {};
          return deepCopyProperties(clonedProperties, this, _TextStyle2.defaultStyle), new _TextStyle2(clonedProperties);
        }
        reset() {
          deepCopyProperties(this, _TextStyle2.defaultStyle, _TextStyle2.defaultStyle);
        }
        get align() {
          return this._align;
        }
        set align(align) {
          this._align !== align && (this._align = align, this.styleID++);
        }
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(breakWords) {
          this._breakWords !== breakWords && (this._breakWords = breakWords, this.styleID++);
        }
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(dropShadow) {
          this._dropShadow !== dropShadow && (this._dropShadow = dropShadow, this.styleID++);
        }
        get dropShadowAlpha() {
          return this._dropShadowAlpha;
        }
        set dropShadowAlpha(dropShadowAlpha) {
          this._dropShadowAlpha !== dropShadowAlpha && (this._dropShadowAlpha = dropShadowAlpha, this.styleID++);
        }
        get dropShadowAngle() {
          return this._dropShadowAngle;
        }
        set dropShadowAngle(dropShadowAngle) {
          this._dropShadowAngle !== dropShadowAngle && (this._dropShadowAngle = dropShadowAngle, this.styleID++);
        }
        get dropShadowBlur() {
          return this._dropShadowBlur;
        }
        set dropShadowBlur(dropShadowBlur) {
          this._dropShadowBlur !== dropShadowBlur && (this._dropShadowBlur = dropShadowBlur, this.styleID++);
        }
        get dropShadowColor() {
          return this._dropShadowColor;
        }
        set dropShadowColor(dropShadowColor) {
          const outputColor = getColor(dropShadowColor);
          this._dropShadowColor !== outputColor && (this._dropShadowColor = outputColor, this.styleID++);
        }
        get dropShadowDistance() {
          return this._dropShadowDistance;
        }
        set dropShadowDistance(dropShadowDistance) {
          this._dropShadowDistance !== dropShadowDistance && (this._dropShadowDistance = dropShadowDistance, this.styleID++);
        }
        get fill() {
          return this._fill;
        }
        set fill(fill) {
          const outputColor = getColor(fill);
          this._fill !== outputColor && (this._fill = outputColor, this.styleID++);
        }
        get fillGradientType() {
          return this._fillGradientType;
        }
        set fillGradientType(fillGradientType) {
          this._fillGradientType !== fillGradientType && (this._fillGradientType = fillGradientType, this.styleID++);
        }
        get fillGradientStops() {
          return this._fillGradientStops;
        }
        set fillGradientStops(fillGradientStops) {
          areArraysEqual(this._fillGradientStops, fillGradientStops) || (this._fillGradientStops = fillGradientStops, this.styleID++);
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(fontFamily) {
          this.fontFamily !== fontFamily && (this._fontFamily = fontFamily, this.styleID++);
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(fontSize) {
          this._fontSize !== fontSize && (this._fontSize = fontSize, this.styleID++);
        }
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(fontStyle) {
          this._fontStyle !== fontStyle && (this._fontStyle = fontStyle, this.styleID++);
        }
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(fontVariant) {
          this._fontVariant !== fontVariant && (this._fontVariant = fontVariant, this.styleID++);
        }
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(fontWeight) {
          this._fontWeight !== fontWeight && (this._fontWeight = fontWeight, this.styleID++);
        }
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(letterSpacing) {
          this._letterSpacing !== letterSpacing && (this._letterSpacing = letterSpacing, this.styleID++);
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(lineHeight) {
          this._lineHeight !== lineHeight && (this._lineHeight = lineHeight, this.styleID++);
        }
        get leading() {
          return this._leading;
        }
        set leading(leading) {
          this._leading !== leading && (this._leading = leading, this.styleID++);
        }
        get lineJoin() {
          return this._lineJoin;
        }
        set lineJoin(lineJoin) {
          this._lineJoin !== lineJoin && (this._lineJoin = lineJoin, this.styleID++);
        }
        get miterLimit() {
          return this._miterLimit;
        }
        set miterLimit(miterLimit) {
          this._miterLimit !== miterLimit && (this._miterLimit = miterLimit, this.styleID++);
        }
        get padding() {
          return this._padding;
        }
        set padding(padding) {
          this._padding !== padding && (this._padding = padding, this.styleID++);
        }
        get stroke() {
          return this._stroke;
        }
        set stroke(stroke) {
          const outputColor = getColor(stroke);
          this._stroke !== outputColor && (this._stroke = outputColor, this.styleID++);
        }
        get strokeThickness() {
          return this._strokeThickness;
        }
        set strokeThickness(strokeThickness) {
          this._strokeThickness !== strokeThickness && (this._strokeThickness = strokeThickness, this.styleID++);
        }
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(textBaseline) {
          this._textBaseline !== textBaseline && (this._textBaseline = textBaseline, this.styleID++);
        }
        get trim() {
          return this._trim;
        }
        set trim(trim) {
          this._trim !== trim && (this._trim = trim, this.styleID++);
        }
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(whiteSpace) {
          this._whiteSpace !== whiteSpace && (this._whiteSpace = whiteSpace, this.styleID++);
        }
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(wordWrap) {
          this._wordWrap !== wordWrap && (this._wordWrap = wordWrap, this.styleID++);
        }
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(wordWrapWidth) {
          this._wordWrapWidth !== wordWrapWidth && (this._wordWrapWidth = wordWrapWidth, this.styleID++);
        }
        toFontString() {
          const fontSizeString = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
          let fontFamilies = this.fontFamily;
          Array.isArray(this.fontFamily) || (fontFamilies = this.fontFamily.split(","));
          for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
            let fontFamily = fontFamilies[i2].trim();
            !/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily) && (fontFamily = `"${fontFamily}"`), fontFamilies[i2] = fontFamily;
          }
          return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
        }
      };
      _TextStyle.defaultStyle = {
        align: "left",
        breakWords: false,
        dropShadow: false,
        dropShadowAlpha: 1,
        dropShadowAngle: Math.PI / 6,
        dropShadowBlur: 0,
        dropShadowColor: "black",
        dropShadowDistance: 5,
        fill: "black",
        fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
        fillGradientStops: [],
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        lineJoin: "miter",
        miterLimit: 10,
        padding: 0,
        stroke: "black",
        strokeThickness: 0,
        textBaseline: "alphabetic",
        trim: false,
        whiteSpace: "pre",
        wordWrap: false,
        wordWrapWidth: 100
      };
      TextStyle = _TextStyle;
    }
  });

  // node_modules/@pixi/text/lib/Text.mjs
  var defaultDestroyOptions, _Text, Text;
  var init_Text = __esm({
    "node_modules/@pixi/text/lib/Text.mjs"() {
      init_lib9();
      init_lib11();
      init_const6();
      init_TextMetrics();
      init_TextStyle();
      defaultDestroyOptions = {
        texture: true,
        children: false,
        baseTexture: true
      };
      _Text = class _Text2 extends Sprite {
        constructor(text, style, canvas) {
          let ownCanvas = false;
          canvas || (canvas = settings.ADAPTER.createCanvas(), ownCanvas = true), canvas.width = 3, canvas.height = 3;
          const texture = Texture.from(canvas);
          texture.orig = new Rectangle(), texture.trim = new Rectangle(), super(texture), this._ownCanvas = ownCanvas, this.canvas = canvas, this.context = canvas.getContext("2d", {
            willReadFrequently: true
          }), this._resolution = _Text2.defaultResolution ?? settings.RESOLUTION, this._autoResolution = _Text2.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = text, this.style = style, this.localStyleID = -1;
        }
        static get experimentalLetterSpacing() {
          return TextMetrics.experimentalLetterSpacing;
        }
        static set experimentalLetterSpacing(value) {
          lib_exports.deprecation(
            "7.1.0",
            "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"
          ), TextMetrics.experimentalLetterSpacing = value;
        }
        updateText(respectDirty) {
          const style = this._style;
          if (this.localStyleID !== style.styleID && (this.dirty = true, this.localStyleID = style.styleID), !this.dirty && respectDirty)
            return;
          this._font = this._style.toFontString();
          const context3 = this.context, measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), width = measured.width, height = measured.height, lines = measured.lines, lineHeight = measured.lineHeight, lineWidths = measured.lineWidths, maxLineWidth = measured.maxLineWidth, fontProperties = measured.fontProperties;
          this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution), context3.scale(this._resolution, this._resolution), context3.clearRect(0, 0, this.canvas.width, this.canvas.height), context3.font = this._font, context3.lineWidth = style.strokeThickness, context3.textBaseline = style.textBaseline, context3.lineJoin = style.lineJoin, context3.miterLimit = style.miterLimit;
          let linePositionX, linePositionY;
          const passesCount = style.dropShadow ? 2 : 1;
          for (let i2 = 0; i2 < passesCount; ++i2) {
            const isShadowPass = style.dropShadow && i2 === 0, dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0, dsOffsetShadow = dsOffsetText * this._resolution;
            if (isShadowPass) {
              context3.fillStyle = "black", context3.strokeStyle = "black";
              const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * this._resolution, dropShadowDistance = style.dropShadowDistance * this._resolution;
              context3.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context3.shadowBlur = dropShadowBlur, context3.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context3.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
            } else
              context3.fillStyle = this._generateFillStyle(style, lines, measured), context3.strokeStyle = style.stroke, context3.shadowColor = "black", context3.shadowBlur = 0, context3.shadowOffsetX = 0, context3.shadowOffsetY = 0;
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            lineHeight - fontProperties.fontSize < 0 && (linePositionYShift = 0);
            for (let i22 = 0; i22 < lines.length; i22++)
              linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift, style.align === "right" ? linePositionX += maxLineWidth - lineWidths[i22] : style.align === "center" && (linePositionX += (maxLineWidth - lineWidths[i22]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(
                lines[i22],
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText,
                true
              ), style.fill && this.drawLetterSpacing(
                lines[i22],
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText
              );
          }
          this.updateTexture();
        }
        drawLetterSpacing(text, x2, y2, isStroke = false) {
          const letterSpacing = this._style.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = true) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), letterSpacing === 0 || useExperimentalLetterSpacing) {
            isStroke ? this.context.strokeText(text, x2, y2) : this.context.fillText(text, x2, y2);
            return;
          }
          let currentPosition = x2;
          const stringArray = TextMetrics.graphemeSegmenter(text);
          let previousWidth = this.context.measureText(text).width, currentWidth = 0;
          for (let i2 = 0; i2 < stringArray.length; ++i2) {
            const currentChar = stringArray[i2];
            isStroke ? this.context.strokeText(currentChar, currentPosition, y2) : this.context.fillText(currentChar, currentPosition, y2);
            let textStr = "";
            for (let j2 = i2 + 1; j2 < stringArray.length; ++j2)
              textStr += stringArray[j2];
            currentWidth = this.context.measureText(textStr).width, currentPosition += previousWidth - currentWidth + letterSpacing, previousWidth = currentWidth;
          }
        }
        updateTexture() {
          const canvas = this.canvas;
          if (this._style.trim) {
            const trimmed = lib_exports.trimCanvas(canvas);
            trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));
          }
          const texture = this._texture, style = this._style, padding = style.trim ? 0 : style.padding, baseTexture = texture.baseTexture;
          texture.trim.width = texture._frame.width = canvas.width / this._resolution, texture.trim.height = texture._frame.height = canvas.height / this._resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(canvas.width, canvas.height, this._resolution), texture.updateUvs(), this.dirty = false;
        }
        _render(renderer) {
          this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true), this.updateText(true), super._render(renderer);
        }
        updateTransform() {
          this.updateText(true), super.updateTransform();
        }
        getBounds(skipUpdate, rect) {
          return this.updateText(true), this._textureID === -1 && (skipUpdate = false), super.getBounds(skipUpdate, rect);
        }
        getLocalBounds(rect) {
          return this.updateText(true), super.getLocalBounds.call(this, rect);
        }
        _calculateBounds() {
          this.calculateVertices(), this._bounds.addQuad(this.vertexData);
        }
        _generateFillStyle(style, lines, metrics) {
          const fillStyle = style.fill;
          if (Array.isArray(fillStyle)) {
            if (fillStyle.length === 1)
              return fillStyle[0];
          } else
            return fillStyle;
          let gradient;
          const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2, height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();
          if (!fillGradientStops.length) {
            const lengthPlus1 = fill.length + 1;
            for (let i2 = 1; i2 < lengthPlus1; ++i2)
              fillGradientStops.push(i2 / lengthPlus1);
          }
          if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
            gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
            const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
            for (let i2 = 0; i2 < lines.length; i2++) {
              const lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight, thisLineTop = metrics.lineHeight * i2;
              let thisLineGradientStart = thisLineTop;
              i2 > 0 && lastLineBottom > thisLineTop && (thisLineGradientStart = (thisLineTop + lastLineBottom) / 2);
              const thisLineBottom = thisLineTop + textHeight, nextLineTop = metrics.lineHeight * (i2 + 1);
              let thisLineGradientEnd = thisLineBottom;
              i2 + 1 < lines.length && nextLineTop < thisLineBottom && (thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2);
              const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
              for (let j2 = 0; j2 < fill.length; j2++) {
                let lineStop = 0;
                typeof fillGradientStops[j2] == "number" ? lineStop = fillGradientStops[j2] : lineStop = j2 / fill.length;
                let globalStop = Math.min(1, Math.max(
                  0,
                  thisLineGradientStart / height + lineStop * gradStopLineHeight
                ));
                globalStop = Number(globalStop.toFixed(5)), gradient.addColorStop(globalStop, fill[j2]);
              }
            }
          } else {
            gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
            const totalIterations = fill.length + 1;
            let currentIteration = 1;
            for (let i2 = 0; i2 < fill.length; i2++) {
              let stop;
              typeof fillGradientStops[i2] == "number" ? stop = fillGradientStops[i2] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i2]), currentIteration++;
            }
          }
          return gradient;
        }
        destroy(options) {
          typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, defaultDestroyOptions, options), super.destroy(options), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
        }
        get width() {
          return this.updateText(true), Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value) {
          this.updateText(true);
          const s2 = lib_exports.sign(this.scale.x) || 1;
          this.scale.x = s2 * value / this._texture.orig.width, this._width = value;
        }
        get height() {
          return this.updateText(true), Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value) {
          this.updateText(true);
          const s2 = lib_exports.sign(this.scale.y) || 1;
          this.scale.y = s2 * value / this._texture.orig.height, this._height = value;
        }
        get style() {
          return this._style;
        }
        set style(style) {
          style = style || {}, style instanceof TextStyle ? this._style = style : this._style = new TextStyle(style), this.localStyleID = -1, this.dirty = true;
        }
        get text() {
          return this._text;
        }
        set text(text) {
          text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = true);
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(value) {
          this._autoResolution = false, this._resolution !== value && (this._resolution = value, this.dirty = true);
        }
      };
      _Text.defaultAutoResolution = true;
      Text = _Text;
    }
  });

  // node_modules/@pixi/text/lib/index.mjs
  var init_lib31 = __esm({
    "node_modules/@pixi/text/lib/index.mjs"() {
      init_const6();
      init_Text();
      init_TextMetrics();
      init_TextStyle();
    }
  });

  // node_modules/@pixi/prepare/lib/CountLimiter.mjs
  var CountLimiter;
  var init_CountLimiter = __esm({
    "node_modules/@pixi/prepare/lib/CountLimiter.mjs"() {
      CountLimiter = class {
        constructor(maxItemsPerFrame) {
          this.maxItemsPerFrame = maxItemsPerFrame, this.itemsLeft = 0;
        }
        beginFrame() {
          this.itemsLeft = this.maxItemsPerFrame;
        }
        allowedToUpload() {
          return this.itemsLeft-- > 0;
        }
      };
    }
  });

  // node_modules/@pixi/prepare/lib/BasePrepare.mjs
  function findMultipleBaseTextures(item, queue) {
    let result = false;
    if (item?._textures?.length) {
      for (let i2 = 0; i2 < item._textures.length; i2++)
        if (item._textures[i2] instanceof Texture) {
          const baseTexture = item._textures[i2].baseTexture;
          queue.includes(baseTexture) || (queue.push(baseTexture), result = true);
        }
    }
    return result;
  }
  function findBaseTexture(item, queue) {
    if (item.baseTexture instanceof BaseTexture) {
      const texture = item.baseTexture;
      return queue.includes(texture) || queue.push(texture), true;
    }
    return false;
  }
  function findTexture(item, queue) {
    if (item._texture && item._texture instanceof Texture) {
      const texture = item._texture.baseTexture;
      return queue.includes(texture) || queue.push(texture), true;
    }
    return false;
  }
  function drawText(_helper, item) {
    return item instanceof Text ? (item.updateText(true), true) : false;
  }
  function calculateTextStyle(_helper, item) {
    if (item instanceof TextStyle) {
      const font = item.toFontString();
      return TextMetrics.measureFont(font), true;
    }
    return false;
  }
  function findText(item, queue) {
    if (item instanceof Text) {
      queue.includes(item.style) || queue.push(item.style), queue.includes(item) || queue.push(item);
      const texture = item._texture.baseTexture;
      return queue.includes(texture) || queue.push(texture), true;
    }
    return false;
  }
  function findTextStyle(item, queue) {
    return item instanceof TextStyle ? (queue.includes(item) || queue.push(item), true) : false;
  }
  var _BasePrepare, BasePrepare;
  var init_BasePrepare = __esm({
    "node_modules/@pixi/prepare/lib/BasePrepare.mjs"() {
      init_lib9();
      init_lib10();
      init_lib31();
      init_CountLimiter();
      _BasePrepare = class _BasePrepare2 {
        constructor(renderer) {
          this.limiter = new CountLimiter(_BasePrepare2.uploadsPerFrame), this.renderer = renderer, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = false, this.delayedTick = () => {
            this.queue && this.prepareItems();
          }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
        }
        upload(item) {
          return new Promise((resolve2) => {
            item && this.add(item), this.queue.length ? (this.completes.push(resolve2), this.ticking || (this.ticking = true, Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY))) : resolve2();
          });
        }
        tick() {
          setTimeout(this.delayedTick, 0);
        }
        prepareItems() {
          for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
            const item = this.queue[0];
            let uploaded = false;
            if (item && !item._destroyed) {
              for (let i2 = 0, len = this.uploadHooks.length; i2 < len; i2++)
                if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
                  this.queue.shift(), uploaded = true;
                  break;
                }
            }
            uploaded || this.queue.shift();
          }
          if (this.queue.length)
            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
          else {
            this.ticking = false;
            const completes = this.completes.slice(0);
            this.completes.length = 0;
            for (let i2 = 0, len = completes.length; i2 < len; i2++)
              completes[i2]();
          }
        }
        registerFindHook(addHook) {
          return addHook && this.addHooks.push(addHook), this;
        }
        registerUploadHook(uploadHook) {
          return uploadHook && this.uploadHooks.push(uploadHook), this;
        }
        add(item) {
          for (let i2 = 0, len = this.addHooks.length; i2 < len && !this.addHooks[i2](item, this.queue); i2++)
            ;
          if (item instanceof Container)
            for (let i2 = item.children.length - 1; i2 >= 0; i2--)
              this.add(item.children[i2]);
          return this;
        }
        destroy() {
          this.ticking && Ticker.system.remove(this.tick, this), this.ticking = false, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
        }
      };
      _BasePrepare.uploadsPerFrame = 4;
      BasePrepare = _BasePrepare;
    }
  });

  // node_modules/@pixi/prepare/lib/settings.mjs
  var init_settings6 = __esm({
    "node_modules/@pixi/prepare/lib/settings.mjs"() {
      init_lib9();
      init_lib9();
      init_BasePrepare();
      Object.defineProperties(settings, {
        UPLOADS_PER_FRAME: {
          get() {
            return BasePrepare.uploadsPerFrame;
          },
          set(value) {
            lib_exports.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), BasePrepare.uploadsPerFrame = value;
          }
        }
      });
    }
  });

  // node_modules/@pixi/prepare/lib/Prepare.mjs
  function uploadBaseTextures(renderer, item) {
    return item instanceof BaseTexture ? (item._glTextures[renderer.CONTEXT_UID] || renderer.texture.bind(item), true) : false;
  }
  function uploadGraphics(renderer, item) {
    if (!(item instanceof Graphics))
      return false;
    const { geometry } = item;
    item.finishPoly(), geometry.updateBatches();
    const { batches } = geometry;
    for (let i2 = 0; i2 < batches.length; i2++) {
      const { texture } = batches[i2].style;
      texture && uploadBaseTextures(renderer, texture.baseTexture);
    }
    return geometry.batchable || renderer.geometry.bind(geometry, item._resolveDirectShader(renderer)), true;
  }
  function findGraphics(item, queue) {
    return item instanceof Graphics ? (queue.push(item), true) : false;
  }
  var Prepare;
  var init_Prepare = __esm({
    "node_modules/@pixi/prepare/lib/Prepare.mjs"() {
      init_lib9();
      init_lib27();
      init_BasePrepare();
      Prepare = class extends BasePrepare {
        constructor(renderer) {
          super(renderer), this.uploadHookHelper = this.renderer, this.registerFindHook(findGraphics), this.registerUploadHook(uploadBaseTextures), this.registerUploadHook(uploadGraphics);
        }
      };
      Prepare.extension = {
        name: "prepare",
        type: ExtensionType.RendererSystem
      };
      extensions.add(Prepare);
    }
  });

  // node_modules/@pixi/prepare/lib/TimeLimiter.mjs
  var init_TimeLimiter = __esm({
    "node_modules/@pixi/prepare/lib/TimeLimiter.mjs"() {
    }
  });

  // node_modules/@pixi/prepare/lib/index.mjs
  var init_lib32 = __esm({
    "node_modules/@pixi/prepare/lib/index.mjs"() {
      init_settings6();
      init_BasePrepare();
      init_CountLimiter();
      init_Prepare();
      init_TimeLimiter();
    }
  });

  // node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs
  var init_AnimatedSprite = __esm({
    "node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs"() {
      init_lib9();
      init_lib11();
    }
  });

  // node_modules/@pixi/sprite-animated/lib/index.mjs
  var init_lib33 = __esm({
    "node_modules/@pixi/sprite-animated/lib/index.mjs"() {
      init_AnimatedSprite();
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs
  var tempPoint3;
  var init_TilingSprite = __esm({
    "node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs"() {
      init_lib9();
      init_lib11();
      tempPoint3 = new Point();
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/sprite-tiling.frag.mjs
  var gl2FragmentSrc;
  var init_sprite_tiling_frag = __esm({
    "node_modules/@pixi/sprite-tiling/lib/sprite-tiling.frag.mjs"() {
      gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`;
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/sprite-tiling.vert.mjs
  var gl2VertexSrc;
  var init_sprite_tiling_vert = __esm({
    "node_modules/@pixi/sprite-tiling/lib/sprite-tiling.vert.mjs"() {
      gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`;
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.frag.mjs
  var gl1FragmentSrc;
  var init_sprite_tiling_fallback_frag = __esm({
    "node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.frag.mjs"() {
      gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`;
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.vert.mjs
  var gl1VertexSrc;
  var init_sprite_tiling_fallback_vert = __esm({
    "node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.vert.mjs"() {
      gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`;
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.frag.mjs
  var fragmentSimpleSrc;
  var init_sprite_tiling_simple_frag = __esm({
    "node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.frag.mjs"() {
      fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs
  var tempMat2, TilingSpriteRenderer;
  var init_TilingSpriteRenderer = __esm({
    "node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs"() {
      init_lib9();
      init_sprite_tiling_frag();
      init_sprite_tiling_vert();
      init_sprite_tiling_fallback_frag();
      init_sprite_tiling_fallback_vert();
      init_sprite_tiling_simple_frag();
      tempMat2 = new Matrix();
      TilingSpriteRenderer = class extends ObjectRenderer {
        constructor(renderer) {
          super(renderer), renderer.runners.contextChange.add(this), this.quad = new QuadUv(), this.state = State.for2d();
        }
        contextChange() {
          const renderer = this.renderer, uniforms = { globals: renderer.globalUniforms };
          this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms), this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
        }
        render(ts) {
          const renderer = this.renderer, quad = this.quad;
          let vertices = quad.vertices;
          vertices[0] = vertices[6] = ts._width * -ts.anchor.x, vertices[1] = vertices[3] = ts._height * -ts.anchor.y, vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x), vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
          const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0, anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
          vertices = quad.uvs, vertices[0] = vertices[6] = -anchorX, vertices[1] = vertices[3] = -anchorY, vertices[2] = vertices[4] = 1 - anchorX, vertices[5] = vertices[7] = 1 - anchorY, quad.invalidate();
          const tex = ts._texture, baseTex = tex.baseTexture, premultiplied = baseTex.alphaMode > 0, lt = ts.tileTransform.localTransform, uv = ts.uvMatrix;
          let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
          isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP : baseTex.wrapMode === WRAP_MODES.CLAMP && (baseTex.wrapMode = WRAP_MODES.REPEAT));
          const shader = isSimple ? this.simpleShader : this.shader, w2 = tex.width, h2 = tex.height, W = ts._width, H2 = ts._height;
          tempMat2.set(
            lt.a * w2 / W,
            lt.b * w2 / H2,
            lt.c * h2 / W,
            lt.d * h2 / H2,
            lt.tx / W,
            lt.ty / H2
          ), tempMat2.invert(), isSimple ? tempMat2.prepend(uv.mapCoord) : (shader.uniforms.uMapCoord = uv.mapCoord.toArray(true), shader.uniforms.uClampFrame = uv.uClampFrame, shader.uniforms.uClampOffset = uv.uClampOffset), shader.uniforms.uTransform = tempMat2.toArray(true), shader.uniforms.uColor = Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor), shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true), shader.uniforms.uSampler = tex, renderer.shader.bind(shader), renderer.geometry.bind(quad), this.state.blendMode = lib_exports.correctBlendMode(ts.blendMode, premultiplied), renderer.state.set(this.state), renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
        }
      };
      TilingSpriteRenderer.extension = {
        name: "tilingSprite",
        type: ExtensionType.RendererPlugin
      };
      extensions.add(TilingSpriteRenderer);
    }
  });

  // node_modules/@pixi/sprite-tiling/lib/index.mjs
  var init_lib34 = __esm({
    "node_modules/@pixi/sprite-tiling/lib/index.mjs"() {
      init_TilingSprite();
      init_TilingSpriteRenderer();
    }
  });

  // node_modules/@pixi/spritesheet/lib/Spritesheet.mjs
  var _Spritesheet, Spritesheet;
  var init_Spritesheet = __esm({
    "node_modules/@pixi/spritesheet/lib/Spritesheet.mjs"() {
      init_lib9();
      _Spritesheet = class _Spritesheet2 {
        constructor(texture, data, resolutionFilename = null) {
          this.linkedSheets = [], this._texture = texture instanceof Texture ? texture : null, this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = data;
          const resource = this.baseTexture.resource;
          this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
        }
        _updateResolution(resolutionFilename = null) {
          const { scale } = this.data.meta;
          let resolution = lib_exports.getResolutionOfUrl(resolutionFilename, null);
          return resolution === null && (resolution = parseFloat(scale ?? "1")), resolution !== 1 && this.baseTexture.setResolution(resolution), resolution;
        }
        parse() {
          return new Promise((resolve2) => {
            this._callback = resolve2, this._batchIndex = 0, this._frameKeys.length <= _Spritesheet2.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
          });
        }
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet2.BATCH_SIZE;
          for (; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length; ) {
            const i2 = this._frameKeys[frameIndex], data = this._frames[i2], rect = data.frame;
            if (rect) {
              let frame = null, trim = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame, orig = new Rectangle(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              data.rotated ? frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              ) : frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              ), data.trimmed !== false && data.spriteSourceSize && (trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              )), this.textures[i2] = new Texture(
                this.baseTexture,
                frame,
                orig,
                trim,
                data.rotated ? 2 : 0,
                data.anchor,
                data.borders
              ), Texture.addToCache(this.textures[i2], i2.toString());
            }
            frameIndex++;
          }
        }
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i2 = 0; i2 < animations[animName].length; i2++) {
              const frameName = animations[animName][i2];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        _parseComplete() {
          const callback = this._callback;
          this._callback = null, this._batchIndex = 0, callback.call(this, this.textures);
        }
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
            this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
          }, 0);
        }
        destroy(destroyBase = false) {
          for (const i2 in this.textures)
            this.textures[i2].destroy();
          this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, destroyBase && (this._texture?.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
        }
      };
      _Spritesheet.BATCH_SIZE = 1e3;
      Spritesheet = _Spritesheet;
    }
  });

  // node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out2 = {};
    if (keys.forEach((key) => {
      out2[key] = asset;
    }), Object.keys(asset.textures).forEach((key) => {
      out2[key] = asset.textures[key];
    }), !ignoreMultiPack) {
      const basePath = lib_exports.path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i2) => {
        const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages, spritesheetAsset;
  var init_spritesheetAsset = __esm({
    "node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs"() {
      init_lib24();
      init_lib9();
      init_Spritesheet();
      validImages = ["jpg", "png", "jpeg", "avif", "webp"];
      spritesheetAsset = {
        extension: ExtensionType.Asset,
        cache: {
          test: (asset) => asset instanceof Spritesheet,
          getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
        },
        resolver: {
          test: (value) => {
            const split = value.split("?")[0].split("."), extension = split.pop(), format2 = split.pop();
            return extension === "json" && validImages.includes(format2);
          },
          parse: (value) => {
            const split = value.split(".");
            return {
              resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
              format: split[split.length - 2],
              src: value
            };
          }
        },
        loader: {
          name: "spritesheetLoader",
          extension: {
            type: ExtensionType.LoadParser,
            priority: LoaderParserPriority.Normal
          },
          async testParse(asset, options) {
            return lib_exports.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
          },
          async parse(asset, options, loader) {
            let basePath = lib_exports.path.dirname(options.src);
            basePath && basePath.lastIndexOf("/") !== basePath.length - 1 && (basePath += "/");
            let imagePath = basePath + asset.meta.image;
            imagePath = copySearchParams(imagePath, options.src);
            const texture = (await loader.load([imagePath]))[imagePath], spritesheet = new Spritesheet(
              texture.baseTexture,
              asset,
              options.src
            );
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
              const promises = [];
              for (const item of multiPacks) {
                if (typeof item != "string")
                  continue;
                let itemUrl = basePath + item;
                options.data?.ignoreMultiPack || (itemUrl = copySearchParams(itemUrl, options.src), promises.push(loader.load({
                  src: itemUrl,
                  data: {
                    ignoreMultiPack: true
                  }
                })));
              }
              const res = await Promise.all(promises);
              spritesheet.linkedSheets = res, res.forEach((item) => {
                item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
              });
            }
            return spritesheet;
          },
          unload(spritesheet) {
            spritesheet.destroy(true);
          }
        }
      };
      extensions.add(spritesheetAsset);
    }
  });

  // node_modules/@pixi/spritesheet/lib/index.mjs
  var init_lib35 = __esm({
    "node_modules/@pixi/spritesheet/lib/index.mjs"() {
      init_Spritesheet();
      init_spritesheetAsset();
    }
  });

  // node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs
  var BitmapFontData;
  var init_BitmapFontData = __esm({
    "node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs"() {
      BitmapFontData = class {
        constructor() {
          this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
        }
      };
    }
  });

  // node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs
  var TextFormat;
  var init_TextFormat = __esm({
    "node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs"() {
      init_BitmapFontData();
      TextFormat = class {
        static test(data) {
          return typeof data == "string" && data.startsWith("info face=");
        }
        static parse(txt) {
          const items = txt.match(/^[a-z]+\s+.+$/gm), rawData = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
          };
          for (const i2 in items) {
            const name = items[i2].match(/^[a-z]+/gm)[0], attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), itemData = {};
            for (const i22 in attributeList) {
              const split = attributeList[i22].split("="), key = split[0], strValue = split[1].replace(/"/gm, ""), floatValue = parseFloat(strValue), value = isNaN(floatValue) ? strValue : floatValue;
              itemData[key] = value;
            }
            rawData[name].push(itemData);
          }
          const font = new BitmapFontData();
          return rawData.info.forEach((info) => font.info.push({
            face: info.face,
            size: parseInt(info.size, 10)
          })), rawData.common.forEach((common) => font.common.push({
            lineHeight: parseInt(common.lineHeight, 10)
          })), rawData.page.forEach((page) => font.page.push({
            id: parseInt(page.id, 10),
            file: page.file
          })), rawData.char.forEach((char) => font.char.push({
            id: parseInt(char.id, 10),
            page: parseInt(char.page, 10),
            x: parseInt(char.x, 10),
            y: parseInt(char.y, 10),
            width: parseInt(char.width, 10),
            height: parseInt(char.height, 10),
            xoffset: parseInt(char.xoffset, 10),
            yoffset: parseInt(char.yoffset, 10),
            xadvance: parseInt(char.xadvance, 10)
          })), rawData.kerning.forEach((kerning) => font.kerning.push({
            first: parseInt(kerning.first, 10),
            second: parseInt(kerning.second, 10),
            amount: parseInt(kerning.amount, 10)
          })), rawData.distanceField.forEach((df) => font.distanceField.push({
            distanceRange: parseInt(df.distanceRange, 10),
            fieldType: df.fieldType
          })), font;
        }
      };
    }
  });

  // node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs
  var XMLFormat;
  var init_XMLFormat = __esm({
    "node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs"() {
      init_BitmapFontData();
      XMLFormat = class {
        static test(data) {
          const xml = data;
          return typeof data != "string" && "getElementsByTagName" in data && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
        }
        static parse(xml) {
          const data = new BitmapFontData(), info = xml.getElementsByTagName("info"), common = xml.getElementsByTagName("common"), page = xml.getElementsByTagName("page"), char = xml.getElementsByTagName("char"), kerning = xml.getElementsByTagName("kerning"), distanceField = xml.getElementsByTagName("distanceField");
          for (let i2 = 0; i2 < info.length; i2++)
            data.info.push({
              face: info[i2].getAttribute("face"),
              size: parseInt(info[i2].getAttribute("size"), 10)
            });
          for (let i2 = 0; i2 < common.length; i2++)
            data.common.push({
              lineHeight: parseInt(common[i2].getAttribute("lineHeight"), 10)
            });
          for (let i2 = 0; i2 < page.length; i2++)
            data.page.push({
              id: parseInt(page[i2].getAttribute("id"), 10) || 0,
              file: page[i2].getAttribute("file")
            });
          for (let i2 = 0; i2 < char.length; i2++) {
            const letter = char[i2];
            data.char.push({
              id: parseInt(letter.getAttribute("id"), 10),
              page: parseInt(letter.getAttribute("page"), 10) || 0,
              x: parseInt(letter.getAttribute("x"), 10),
              y: parseInt(letter.getAttribute("y"), 10),
              width: parseInt(letter.getAttribute("width"), 10),
              height: parseInt(letter.getAttribute("height"), 10),
              xoffset: parseInt(letter.getAttribute("xoffset"), 10),
              yoffset: parseInt(letter.getAttribute("yoffset"), 10),
              xadvance: parseInt(letter.getAttribute("xadvance"), 10)
            });
          }
          for (let i2 = 0; i2 < kerning.length; i2++)
            data.kerning.push({
              first: parseInt(kerning[i2].getAttribute("first"), 10),
              second: parseInt(kerning[i2].getAttribute("second"), 10),
              amount: parseInt(kerning[i2].getAttribute("amount"), 10)
            });
          for (let i2 = 0; i2 < distanceField.length; i2++)
            data.distanceField.push({
              fieldType: distanceField[i2].getAttribute("fieldType"),
              distanceRange: parseInt(distanceField[i2].getAttribute("distanceRange"), 10)
            });
          return data;
        }
      };
    }
  });

  // node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs
  var XMLStringFormat;
  var init_XMLStringFormat = __esm({
    "node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs"() {
      init_lib9();
      init_XMLFormat();
      XMLStringFormat = class {
        static test(data) {
          return typeof data == "string" && data.includes("<font>") ? XMLFormat.test(settings.ADAPTER.parseXML(data)) : false;
        }
        static parse(xmlTxt) {
          return XMLFormat.parse(settings.ADAPTER.parseXML(xmlTxt));
        }
      };
    }
  });

  // node_modules/@pixi/text-bitmap/lib/formats/index.mjs
  function autoDetectFormat(data) {
    for (let i2 = 0; i2 < formats.length; i2++)
      if (formats[i2].test(data))
        return formats[i2];
    return null;
  }
  var formats;
  var init_formats = __esm({
    "node_modules/@pixi/text-bitmap/lib/formats/index.mjs"() {
      init_TextFormat();
      init_XMLFormat();
      init_XMLStringFormat();
      formats = [
        TextFormat,
        XMLFormat,
        XMLStringFormat
      ];
    }
  });

  // node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs
  function generateFillStyle(canvas, context3, style, resolution, lines, metrics) {
    const fillStyle = style.fill;
    if (Array.isArray(fillStyle)) {
      if (fillStyle.length === 1)
        return fillStyle[0];
    } else
      return fillStyle;
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = canvas.width / resolution - dropShadowCorrection - padding * 2, height = canvas.height / resolution - dropShadowCorrection - padding * 2, fill = fillStyle.slice(), fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i2 = 1; i2 < lengthPlus1; ++i2)
        fillGradientStops.push(i2 / lengthPlus1);
    }
    if (fill.unshift(fillStyle[0]), fillGradientStops.unshift(0), fill.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = context3.createLinearGradient(width / 2, padding, width / 2, height + padding);
      let lastIterationStop = 0;
      const gradStopLineHeight = (metrics.fontProperties.fontSize + style.strokeThickness) / height;
      for (let i2 = 0; i2 < lines.length; i2++) {
        const thisLineTop = metrics.lineHeight * i2;
        for (let j2 = 0; j2 < fill.length; j2++) {
          let lineStop = 0;
          typeof fillGradientStops[j2] == "number" ? lineStop = fillGradientStops[j2] : lineStop = j2 / fill.length;
          const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
          let clampedStop = Math.max(lastIterationStop, globalStop);
          clampedStop = Math.min(clampedStop, 1), gradient.addColorStop(clampedStop, fill[j2]), lastIterationStop = clampedStop;
        }
      }
    } else {
      gradient = context3.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i2 = 0; i2 < fill.length; i2++) {
        let stop;
        typeof fillGradientStops[i2] == "number" ? stop = fillGradientStops[i2] : stop = currentIteration / totalIterations, gradient.addColorStop(stop, fill[i2]), currentIteration++;
      }
    }
    return gradient;
  }
  var init_generateFillStyle = __esm({
    "node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs"() {
      init_lib31();
    }
  });

  // node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs
  function drawGlyph(canvas, context3, metrics, x2, y2, resolution, style) {
    const char = metrics.text, fontProperties = metrics.fontProperties;
    context3.translate(x2, y2), context3.scale(resolution, resolution);
    const tx = style.strokeThickness / 2, ty = -(style.strokeThickness / 2);
    if (context3.font = style.toFontString(), context3.lineWidth = style.strokeThickness, context3.textBaseline = style.textBaseline, context3.lineJoin = style.lineJoin, context3.miterLimit = style.miterLimit, context3.fillStyle = generateFillStyle(canvas, context3, style, resolution, [char], metrics), context3.strokeStyle = style.stroke, style.dropShadow) {
      const dropShadowColor = style.dropShadowColor, dropShadowBlur = style.dropShadowBlur * resolution, dropShadowDistance = style.dropShadowDistance * resolution;
      context3.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString(), context3.shadowBlur = dropShadowBlur, context3.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance, context3.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
    } else
      context3.shadowColor = "black", context3.shadowBlur = 0, context3.shadowOffsetX = 0, context3.shadowOffsetY = 0;
    style.stroke && style.strokeThickness && context3.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent), style.fill && context3.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent), context3.setTransform(1, 0, 0, 1, 0, 0), context3.fillStyle = "rgba(0, 0, 0, 0)";
  }
  var init_drawGlyph = __esm({
    "node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs"() {
      init_lib9();
      init_generateFillStyle();
    }
  });

  // node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs
  function extractCharCode(str) {
    return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
  }
  var init_extractCharCode = __esm({
    "node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs"() {
    }
  });

  // node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs
  function splitTextToCharacters(text) {
    return Array.from ? Array.from(text) : text.split("");
  }
  var init_splitTextToCharacters = __esm({
    "node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs"() {
    }
  });

  // node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs
  function resolveCharacters(chars) {
    typeof chars == "string" && (chars = [chars]);
    const result = [];
    for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
      const item = chars[i2];
      if (Array.isArray(item)) {
        if (item.length !== 2)
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        const startCode = item[0].charCodeAt(0), endCode = item[1].charCodeAt(0);
        if (endCode < startCode)
          throw new Error("[BitmapFont]: Invalid character range.");
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++)
          result.push(String.fromCharCode(i22));
      } else
        result.push(...splitTextToCharacters(item));
    }
    if (result.length === 0)
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return result;
  }
  var init_resolveCharacters = __esm({
    "node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs"() {
      init_splitTextToCharacters();
    }
  });

  // node_modules/@pixi/text-bitmap/lib/utils/index.mjs
  var init_utils5 = __esm({
    "node_modules/@pixi/text-bitmap/lib/utils/index.mjs"() {
      init_drawGlyph();
      init_extractCharCode();
      init_generateFillStyle();
      init_resolveCharacters();
      init_splitTextToCharacters();
    }
  });

  // node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs
  var _BitmapFont, BitmapFont;
  var init_BitmapFont = __esm({
    "node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs"() {
      init_lib9();
      init_lib31();
      init_BitmapFontData();
      init_formats();
      init_utils5();
      init_resolveCharacters();
      init_drawGlyph();
      init_extractCharCode();
      _BitmapFont = class _BitmapFont2 {
        constructor(data, textures, ownsTextures) {
          const [info] = data.info, [common] = data.common, [page] = data.page, [distanceField] = data.distanceField, res = lib_exports.getResolutionOfUrl(page.file), pageTextures = {};
          this._ownsTextures = ownsTextures, this.font = info.face, this.size = info.size, this.lineHeight = common.lineHeight / res, this.chars = {}, this.pageTextures = pageTextures;
          for (let i2 = 0; i2 < data.page.length; i2++) {
            const { id, file } = data.page[i2];
            pageTextures[id] = textures instanceof Array ? textures[i2] : textures[file], distanceField?.fieldType && distanceField.fieldType !== "none" && (pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF);
          }
          for (let i2 = 0; i2 < data.char.length; i2++) {
            const { id, page: page2 } = data.char[i2];
            let { x: x2, y: y2, width, height, xoffset, yoffset, xadvance } = data.char[i2];
            x2 /= res, y2 /= res, width /= res, height /= res, xoffset /= res, yoffset /= res, xadvance /= res;
            const rect = new Rectangle(
              x2 + pageTextures[page2].frame.x / res,
              y2 + pageTextures[page2].frame.y / res,
              width,
              height
            );
            this.chars[id] = {
              xOffset: xoffset,
              yOffset: yoffset,
              xAdvance: xadvance,
              kerning: {},
              texture: new Texture(
                pageTextures[page2].baseTexture,
                rect
              ),
              page: page2
            };
          }
          for (let i2 = 0; i2 < data.kerning.length; i2++) {
            let { first, second, amount } = data.kerning[i2];
            first /= res, second /= res, amount /= res, this.chars[second] && (this.chars[second].kerning[first] = amount);
          }
          this.distanceFieldRange = distanceField?.distanceRange, this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
        }
        destroy() {
          for (const id in this.chars)
            this.chars[id].texture.destroy(), this.chars[id].texture = null;
          for (const id in this.pageTextures)
            this._ownsTextures && this.pageTextures[id].destroy(true), this.pageTextures[id] = null;
          this.chars = null, this.pageTextures = null;
        }
        static install(data, textures, ownsTextures) {
          let fontData;
          if (data instanceof BitmapFontData)
            fontData = data;
          else {
            const format2 = autoDetectFormat(data);
            if (!format2)
              throw new Error("Unrecognized data format for font.");
            fontData = format2.parse(data);
          }
          textures instanceof Texture && (textures = [textures]);
          const font = new _BitmapFont2(fontData, textures, ownsTextures);
          return _BitmapFont2.available[font.font] = font, font;
        }
        static uninstall(name) {
          const font = _BitmapFont2.available[name];
          if (!font)
            throw new Error(`No font found named '${name}'`);
          font.destroy(), delete _BitmapFont2.available[name];
        }
        static from(name, textStyle, options) {
          if (!name)
            throw new Error("[BitmapFont] Property `name` is required.");
          const {
            chars,
            padding,
            resolution,
            textureWidth,
            textureHeight,
            ...baseOptions
          } = Object.assign({}, _BitmapFont2.defaultOptions, options), charsList = resolveCharacters(chars), style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle), lineWidth = textureWidth, fontData = new BitmapFontData();
          fontData.info[0] = {
            face: style.fontFamily,
            size: style.fontSize
          }, fontData.common[0] = {
            lineHeight: style.fontSize
          };
          let positionX = 0, positionY = 0, canvas, context3, baseTexture, maxCharHeight = 0;
          const baseTextures = [], textures = [];
          for (let i2 = 0; i2 < charsList.length; i2++) {
            canvas || (canvas = settings.ADAPTER.createCanvas(), canvas.width = textureWidth, canvas.height = textureHeight, context3 = canvas.getContext("2d"), baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions }), baseTextures.push(baseTexture), textures.push(new Texture(baseTexture)), fontData.page.push({
              id: textures.length - 1,
              file: ""
            }));
            const character = charsList[i2], metrics = TextMetrics.measureText(character, style, false, canvas), width = metrics.width, height = Math.ceil(metrics.height), textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
            if (positionY >= textureHeight - height * resolution) {
              if (positionY === 0)
                throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
              --i2, canvas = null, context3 = null, baseTexture = null, positionY = 0, positionX = 0, maxCharHeight = 0;
              continue;
            }
            if (maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight), textureGlyphWidth * resolution + positionX >= lineWidth) {
              if (positionX === 0)
                throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
              --i2, positionY += maxCharHeight * resolution, positionY = Math.ceil(positionY), positionX = 0, maxCharHeight = 0;
              continue;
            }
            drawGlyph(canvas, context3, metrics, positionX, positionY, resolution, style);
            const id = extractCharCode(metrics.text);
            fontData.char.push({
              id,
              page: textures.length - 1,
              x: positionX / resolution,
              y: positionY / resolution,
              width: textureGlyphWidth,
              height,
              xoffset: 0,
              yoffset: 0,
              xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
            }), positionX += (textureGlyphWidth + 2 * padding) * resolution, positionX = Math.ceil(positionX);
          }
          if (!options?.skipKerning)
            for (let i2 = 0, len = charsList.length; i2 < len; i2++) {
              const first = charsList[i2];
              for (let j2 = 0; j2 < len; j2++) {
                const second = charsList[j2], c1 = context3.measureText(first).width, c2 = context3.measureText(second).width, amount = context3.measureText(first + second).width - (c1 + c2);
                amount && fontData.kerning.push({
                  first: extractCharCode(first),
                  second: extractCharCode(second),
                  amount
                });
              }
            }
          const font = new _BitmapFont2(fontData, textures, true);
          return _BitmapFont2.available[name] !== void 0 && _BitmapFont2.uninstall(name), _BitmapFont2.available[name] = font, font;
        }
      };
      _BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "], _BitmapFont.NUMERIC = [["0", "9"]], _BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], _BitmapFont.ASCII = [[" ", "~"]], _BitmapFont.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: _BitmapFont.ALPHANUMERIC
      }, _BitmapFont.available = {};
      BitmapFont = _BitmapFont;
    }
  });

  // node_modules/@pixi/text-bitmap/lib/shader/msdf.frag.mjs
  var msdfFrag;
  var init_msdf_frag = __esm({
    "node_modules/@pixi/text-bitmap/lib/shader/msdf.frag.mjs"() {
      msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`;
    }
  });

  // node_modules/@pixi/text-bitmap/lib/shader/msdf.vert.mjs
  var msdfVert;
  var init_msdf_vert = __esm({
    "node_modules/@pixi/text-bitmap/lib/shader/msdf.vert.mjs"() {
      msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
    }
  });

  // node_modules/@pixi/text-bitmap/lib/BitmapText.mjs
  var pageMeshDataDefaultPageMeshData, pageMeshDataMSDFPageMeshData, charRenderDataPool, _BitmapText;
  var init_BitmapText = __esm({
    "node_modules/@pixi/text-bitmap/lib/BitmapText.mjs"() {
      init_lib9();
      init_lib10();
      init_lib28();
      init_BitmapFont();
      init_msdf_frag();
      init_msdf_vert();
      init_utils5();
      init_splitTextToCharacters();
      init_extractCharCode();
      pageMeshDataDefaultPageMeshData = [];
      pageMeshDataMSDFPageMeshData = [];
      charRenderDataPool = [];
      _BitmapText = class _BitmapText2 extends Container {
        constructor(text, style = {}) {
          super();
          const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(
            {},
            _BitmapText2.styleDefaults,
            style
          );
          if (!BitmapFont.available[fontName])
            throw new Error(`Missing BitmapFont "${fontName}"`);
          this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = align, this._tintColor = new Color(tint), this._font = void 0, this._fontName = fontName, this._fontSize = fontSize, this.text = text, this._maxWidth = maxWidth, this._maxLineHeight = 0, this._letterSpacing = letterSpacing, this._anchor = new ObservablePoint(() => {
            this.dirty = true;
          }, this, 0, 0), this._roundPixels = settings.ROUND_PIXELS, this.dirty = true, this._resolution = settings.RESOLUTION, this._autoResolution = true, this._textureCache = {};
        }
        updateText() {
          const data = BitmapFont.available[this._fontName], fontSize = this.fontSize, scale = fontSize / data.size, pos = new Point(), chars = [], lineWidths = [], lineSpaces = [], text = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", charsInput = splitTextToCharacters(text), maxWidth = this._maxWidth * data.size / fontSize, pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
          let prevCharCode = null, lastLineWidth = 0, maxLineWidth = 0, line = 0, lastBreakPos = -1, lastBreakWidth = 0, spacesRemoved = 0, maxLineHeight = 0, spaceCount = 0;
          for (let i2 = 0; i2 < charsInput.length; i2++) {
            const char = charsInput[i2], charCode = extractCharCode(char);
            if (/(?:\s)/.test(char) && (lastBreakPos = i2, lastBreakWidth = lastLineWidth, spaceCount++), char === "\r" || char === `
`) {
              lineWidths.push(lastLineWidth), lineSpaces.push(-1), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), ++line, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0;
              continue;
            }
            const charData = data.chars[charCode];
            if (!charData)
              continue;
            prevCharCode && charData.kerning[prevCharCode] && (pos.x += charData.kerning[prevCharCode]);
            const charRenderData = charRenderDataPool.pop() || {
              texture: Texture.EMPTY,
              line: 0,
              charCode: 0,
              prevSpaces: 0,
              position: new Point()
            };
            charRenderData.texture = charData.texture, charRenderData.line = line, charRenderData.charCode = charCode, charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2), charRenderData.position.y = Math.round(pos.y + charData.yOffset), charRenderData.prevSpaces = spaceCount, chars.push(charRenderData), lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width), pos.x += charData.xAdvance + this._letterSpacing, maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height), prevCharCode = charCode, lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth && (++spacesRemoved, lib_exports.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos), i2 = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0), maxLineWidth = Math.max(maxLineWidth, lastBreakWidth), line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0);
          }
          const lastChar = charsInput[charsInput.length - 1];
          lastChar !== "\r" && lastChar !== `
` && (/(?:\s)/.test(lastChar) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), maxLineWidth = Math.max(maxLineWidth, lastLineWidth), lineSpaces.push(-1));
          const lineAlignOffsets = [];
          for (let i2 = 0; i2 <= line; i2++) {
            let alignOffset = 0;
            this._align === "right" ? alignOffset = maxLineWidth - lineWidths[i2] : this._align === "center" ? alignOffset = (maxLineWidth - lineWidths[i2]) / 2 : this._align === "justify" && (alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2]), lineAlignOffsets.push(alignOffset);
          }
          const lenChars = chars.length, pagesMeshData = {}, newPagesMeshData = [], activePagesMeshData = this._activePagesMeshData;
          pageMeshDataPool.push(...activePagesMeshData);
          for (let i2 = 0; i2 < lenChars; i2++) {
            const texture = chars[i2].texture, baseTextureUid = texture.baseTexture.uid;
            if (!pagesMeshData[baseTextureUid]) {
              let pageMeshData = pageMeshDataPool.pop();
              if (!pageMeshData) {
                const geometry = new MeshGeometry();
                let material, meshBlendMode;
                data.distanceFieldType === "none" ? (material = new MeshMaterial(Texture.EMPTY), meshBlendMode = BLEND_MODES.NORMAL) : (material = new MeshMaterial(
                  Texture.EMPTY,
                  { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }
                ), meshBlendMode = BLEND_MODES.NORMAL_NPM);
                const mesh = new Mesh(geometry, material);
                mesh.blendMode = meshBlendMode, pageMeshData = {
                  index: 0,
                  indexCount: 0,
                  vertexCount: 0,
                  uvsCount: 0,
                  total: 0,
                  mesh,
                  vertices: null,
                  uvs: null,
                  indices: null
                };
              }
              pageMeshData.index = 0, pageMeshData.indexCount = 0, pageMeshData.vertexCount = 0, pageMeshData.uvsCount = 0, pageMeshData.total = 0;
              const { _textureCache } = this;
              _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture), pageMeshData.mesh.texture = _textureCache[baseTextureUid], pageMeshData.mesh.tint = this._tintColor.value, newPagesMeshData.push(pageMeshData), pagesMeshData[baseTextureUid] = pageMeshData;
            }
            pagesMeshData[baseTextureUid].total++;
          }
          for (let i2 = 0; i2 < activePagesMeshData.length; i2++)
            newPagesMeshData.includes(activePagesMeshData[i2]) || this.removeChild(activePagesMeshData[i2].mesh);
          for (let i2 = 0; i2 < newPagesMeshData.length; i2++)
            newPagesMeshData[i2].mesh.parent !== this && this.addChild(newPagesMeshData[i2].mesh);
          this._activePagesMeshData = newPagesMeshData;
          for (const i2 in pagesMeshData) {
            const pageMeshData = pagesMeshData[i2], total = pageMeshData.total;
            if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)
              pageMeshData.vertices = new Float32Array(4 * 2 * total), pageMeshData.uvs = new Float32Array(4 * 2 * total), pageMeshData.indices = new Uint16Array(6 * total);
            else {
              const total2 = pageMeshData.total, vertices = pageMeshData.vertices;
              for (let i22 = total2 * 4 * 2; i22 < vertices.length; i22++)
                vertices[i22] = 0;
            }
            pageMeshData.mesh.size = 6 * total;
          }
          for (let i2 = 0; i2 < lenChars; i2++) {
            const char = chars[i2];
            let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
            this._roundPixels && (offset = Math.round(offset));
            const xPos = offset * scale, yPos = char.position.y * scale, texture = char.texture, pageMesh = pagesMeshData[texture.baseTexture.uid], textureFrame = texture.frame, textureUvs = texture._uvs, index = pageMesh.index++;
            pageMesh.indices[index * 6 + 0] = 0 + index * 4, pageMesh.indices[index * 6 + 1] = 1 + index * 4, pageMesh.indices[index * 6 + 2] = 2 + index * 4, pageMesh.indices[index * 6 + 3] = 0 + index * 4, pageMesh.indices[index * 6 + 4] = 2 + index * 4, pageMesh.indices[index * 6 + 5] = 3 + index * 4, pageMesh.vertices[index * 8 + 0] = xPos, pageMesh.vertices[index * 8 + 1] = yPos, pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 3] = yPos, pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale, pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale, pageMesh.vertices[index * 8 + 6] = xPos, pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale, pageMesh.uvs[index * 8 + 0] = textureUvs.x0, pageMesh.uvs[index * 8 + 1] = textureUvs.y0, pageMesh.uvs[index * 8 + 2] = textureUvs.x1, pageMesh.uvs[index * 8 + 3] = textureUvs.y1, pageMesh.uvs[index * 8 + 4] = textureUvs.x2, pageMesh.uvs[index * 8 + 5] = textureUvs.y2, pageMesh.uvs[index * 8 + 6] = textureUvs.x3, pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
          }
          this._textWidth = maxLineWidth * scale, this._textHeight = (pos.y + data.lineHeight) * scale;
          for (const i2 in pagesMeshData) {
            const pageMeshData = pagesMeshData[i2];
            if (this.anchor.x !== 0 || this.anchor.y !== 0) {
              let vertexCount = 0;
              const anchorOffsetX = this._textWidth * this.anchor.x, anchorOffsetY = this._textHeight * this.anchor.y;
              for (let i22 = 0; i22 < pageMeshData.total; i22++)
                pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY, pageMeshData.vertices[vertexCount++] -= anchorOffsetX, pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            }
            this._maxLineHeight = maxLineHeight * scale;
            const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition"), textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord"), indexBuffer = pageMeshData.mesh.geometry.getIndex();
            vertexBuffer.data = pageMeshData.vertices, textureBuffer.data = pageMeshData.uvs, indexBuffer.data = pageMeshData.indices, vertexBuffer.update(), textureBuffer.update(), indexBuffer.update();
          }
          for (let i2 = 0; i2 < chars.length; i2++)
            charRenderDataPool.push(chars[i2]);
          this._font = data, this.dirty = false;
        }
        updateTransform() {
          this.validate(), this.containerUpdateTransform();
        }
        _render(renderer) {
          this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true);
          const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];
          if (distanceFieldType !== "none") {
            const { a: a2, b: b2, c: c2, d: d2 } = this.worldTransform, dx = Math.sqrt(a2 * a2 + b2 * b2), dy = Math.sqrt(c2 * c2 + d2 * d2), worldScale = (Math.abs(dx) + Math.abs(dy)) / 2, fontScale = this.fontSize / size, resolution = renderer._view.resolution;
            for (const mesh of this._activePagesMeshData)
              mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
          }
          super._render(renderer);
        }
        getLocalBounds() {
          return this.validate(), super.getLocalBounds();
        }
        validate() {
          const font = BitmapFont.available[this._fontName];
          if (!font)
            throw new Error(`Missing BitmapFont "${this._fontName}"`);
          this._font !== font && (this.dirty = true), this.dirty && this.updateText();
        }
        get tint() {
          return this._tintColor.value;
        }
        set tint(value) {
          if (this.tint !== value) {
            this._tintColor.setValue(value);
            for (let i2 = 0; i2 < this._activePagesMeshData.length; i2++)
              this._activePagesMeshData[i2].mesh.tint = value;
          }
        }
        get align() {
          return this._align;
        }
        set align(value) {
          this._align !== value && (this._align = value, this.dirty = true);
        }
        get fontName() {
          return this._fontName;
        }
        set fontName(value) {
          if (!BitmapFont.available[value])
            throw new Error(`Missing BitmapFont "${value}"`);
          this._fontName !== value && (this._fontName = value, this.dirty = true);
        }
        get fontSize() {
          return this._fontSize ?? BitmapFont.available[this._fontName].size;
        }
        set fontSize(value) {
          this._fontSize !== value && (this._fontSize = value, this.dirty = true);
        }
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value == "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        get text() {
          return this._text;
        }
        set text(text) {
          text = String(text ?? ""), this._text !== text && (this._text = text, this.dirty = true);
        }
        get maxWidth() {
          return this._maxWidth;
        }
        set maxWidth(value) {
          this._maxWidth !== value && (this._maxWidth = value, this.dirty = true);
        }
        get maxLineHeight() {
          return this.validate(), this._maxLineHeight;
        }
        get textWidth() {
          return this.validate(), this._textWidth;
        }
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value) {
          this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = true);
        }
        get roundPixels() {
          return this._roundPixels;
        }
        set roundPixels(value) {
          value !== this._roundPixels && (this._roundPixels = value, this.dirty = true);
        }
        get textHeight() {
          return this.validate(), this._textHeight;
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(value) {
          this._autoResolution = false, this._resolution !== value && (this._resolution = value, this.dirty = true);
        }
        destroy(options) {
          const { _textureCache } = this, pageMeshDataPool = BitmapFont.available[this._fontName].distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
          pageMeshDataPool.push(...this._activePagesMeshData);
          for (const pageMeshData of this._activePagesMeshData)
            this.removeChild(pageMeshData.mesh);
          this._activePagesMeshData = [], pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
            page.mesh.texture = Texture.EMPTY;
          });
          for (const id in _textureCache)
            _textureCache[id].destroy(), delete _textureCache[id];
          this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(options);
        }
      };
      _BitmapText.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0
      };
    }
  });

  // node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs
  var validExtensions, loadBitmapFont;
  var init_loadBitmapFont = __esm({
    "node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs"() {
      init_lib24();
      init_lib9();
      init_BitmapFont();
      init_formats();
      init_TextFormat();
      init_XMLStringFormat();
      validExtensions = [".xml", ".fnt"];
      loadBitmapFont = {
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal
        },
        name: "loadBitmapFont",
        test(url2) {
          return validExtensions.includes(lib_exports.path.extname(url2).toLowerCase());
        },
        async testParse(data) {
          return TextFormat.test(data) || XMLStringFormat.test(data);
        },
        async parse(asset, data, loader) {
          const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset), { src } = data, { page: pages } = fontData, textureUrls = [];
          for (let i2 = 0; i2 < pages.length; ++i2) {
            const pageFile = pages[i2].file;
            let imagePath = lib_exports.path.join(lib_exports.path.dirname(src), pageFile);
            imagePath = copySearchParams(imagePath, src), textureUrls.push(imagePath);
          }
          const loadedTextures = await loader.load(textureUrls), textures = textureUrls.map((url2) => loadedTextures[url2]);
          return BitmapFont.install(fontData, textures, true);
        },
        async load(url2, _options) {
          return (await settings.ADAPTER.fetch(url2)).text();
        },
        unload(bitmapFont) {
          bitmapFont.destroy();
        }
      };
      extensions.add(loadBitmapFont);
    }
  });

  // node_modules/@pixi/text-bitmap/lib/index.mjs
  var init_lib36 = __esm({
    "node_modules/@pixi/text-bitmap/lib/index.mjs"() {
      init_BitmapFont();
      init_BitmapFontData();
      init_BitmapText();
      init_formats();
      init_loadBitmapFont();
      init_TextFormat();
      init_XMLFormat();
      init_XMLStringFormat();
    }
  });

  // node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs
  var _HTMLTextStyle, HTMLTextStyle;
  var init_HTMLTextStyle = __esm({
    "node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs"() {
      init_lib9();
      init_lib31();
      _HTMLTextStyle = class _HTMLTextStyle2 extends TextStyle {
        constructor() {
          super(...arguments), this._fonts = [], this._overrides = [], this._stylesheet = "", this.fontsDirty = false;
        }
        static from(originalStyle) {
          return new _HTMLTextStyle2(
            Object.keys(_HTMLTextStyle2.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {})
          );
        }
        cleanFonts() {
          this._fonts.length > 0 && (this._fonts.forEach((font) => {
            URL.revokeObjectURL(font.src), font.refs--, font.refs === 0 && (font.fontFace && document.fonts.delete(font.fontFace), delete _HTMLTextStyle2.availableFonts[font.originalUrl]);
          }), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = true);
        }
        loadFont(url2, options = {}) {
          const { availableFonts } = _HTMLTextStyle2;
          if (availableFonts[url2]) {
            const font = availableFonts[url2];
            return this._fonts.push(font), font.refs++, this.styleID++, this.fontsDirty = true, Promise.resolve();
          }
          return settings.ADAPTER.fetch(url2).then((response) => response.blob()).then(async (blob) => new Promise((resolve2, reject) => {
            const src = URL.createObjectURL(blob), reader = new FileReader();
            reader.onload = () => resolve2([src, reader.result]), reader.onerror = reject, reader.readAsDataURL(blob);
          })).then(async ([src, dataSrc]) => {
            const font = Object.assign({
              family: lib_exports.path.basename(url2, lib_exports.path.extname(url2)),
              weight: "normal",
              style: "normal",
              display: "auto",
              src,
              dataSrc,
              refs: 1,
              originalUrl: url2,
              fontFace: null
            }, options);
            availableFonts[url2] = font, this._fonts.push(font), this.styleID++;
            const fontFace = new FontFace(font.family, `url(${font.src})`, {
              weight: font.weight,
              style: font.style,
              display: font.display
            });
            font.fontFace = fontFace, await fontFace.load(), document.fonts.add(fontFace), await document.fonts.ready, this.styleID++, this.fontsDirty = true;
          });
        }
        addOverride(...value) {
          const toAdd = value.filter((v2) => !this._overrides.includes(v2));
          toAdd.length > 0 && (this._overrides.push(...toAdd), this.styleID++);
        }
        removeOverride(...value) {
          const toRemove = value.filter((v2) => this._overrides.includes(v2));
          toRemove.length > 0 && (this._overrides = this._overrides.filter((v2) => !toRemove.includes(v2)), this.styleID++);
        }
        toCSS(scale) {
          return [
            `transform: scale(${scale})`,
            "transform-origin: top left",
            "display: inline-block",
            `color: ${this.normalizeColor(this.fill)}`,
            `font-size: ${this.fontSize}px`,
            `font-family: ${this.fontFamily}`,
            `font-weight: ${this.fontWeight}`,
            `font-style: ${this.fontStyle}`,
            `font-variant: ${this.fontVariant}`,
            `letter-spacing: ${this.letterSpacing}px`,
            `text-align: ${this.align}`,
            `padding: ${this.padding}px`,
            `white-space: ${this.whiteSpace}`,
            ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
            ...this.wordWrap ? [
              `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
              `max-width: ${this.wordWrapWidth}px`
            ] : [],
            ...this.strokeThickness ? [
              `-webkit-text-stroke-width: ${this.strokeThickness}px`,
              `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
              `text-stroke-width: ${this.strokeThickness}px`,
              `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
              "paint-order: stroke"
            ] : [],
            ...this.dropShadow ? [this.dropShadowToCSS()] : [],
            ...this._overrides
          ].join(";");
        }
        toGlobalCSS() {
          return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style};
                font-display: ${font.display};
            }`, this._stylesheet);
        }
        get stylesheet() {
          return this._stylesheet;
        }
        set stylesheet(value) {
          this._stylesheet !== value && (this._stylesheet = value, this.styleID++);
        }
        normalizeColor(color) {
          return Array.isArray(color) && (color = lib_exports.rgb2hex(color)), typeof color == "number" ? lib_exports.hex2string(color) : color;
        }
        dropShadowToCSS() {
          let color = this.normalizeColor(this.dropShadowColor);
          const alpha = this.dropShadowAlpha, x2 = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance), y2 = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
          color.startsWith("#") && alpha < 1 && (color += (alpha * 255 | 0).toString(16).padStart(2, "0"));
          const position = `${x2}px ${y2}px`;
          return this.dropShadowBlur > 0 ? `text-shadow: ${position} ${this.dropShadowBlur}px ${color}` : `text-shadow: ${position} ${color}`;
        }
        reset() {
          Object.assign(this, _HTMLTextStyle2.defaultOptions);
        }
        onBeforeDraw() {
          const { fontsDirty: prevFontsDirty } = this;
          return this.fontsDirty = false, this.isSafari && this._fonts.length > 0 && prevFontsDirty ? new Promise((resolve2) => setTimeout(resolve2, 100)) : Promise.resolve();
        }
        get isSafari() {
          const { userAgent } = settings.ADAPTER.getNavigator();
          return /^((?!chrome|android).)*safari/i.test(userAgent);
        }
        set fillGradientStops(_value) {
          console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
        }
        get fillGradientStops() {
          return super.fillGradientStops;
        }
        set fillGradientType(_value) {
          console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
        }
        get fillGradientType() {
          return super.fillGradientType;
        }
        set miterLimit(_value) {
          console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
        }
        get miterLimit() {
          return super.miterLimit;
        }
        set trim(_value) {
          console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
        }
        get trim() {
          return super.trim;
        }
        set textBaseline(_value) {
          console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
        }
        get textBaseline() {
          return super.textBaseline;
        }
        set leading(_value) {
          console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
        }
        get leading() {
          return super.leading;
        }
        set lineJoin(_value) {
          console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
        }
        get lineJoin() {
          return super.lineJoin;
        }
      };
      _HTMLTextStyle.availableFonts = {}, _HTMLTextStyle.defaultOptions = {
        align: "left",
        breakWords: false,
        dropShadow: false,
        dropShadowAlpha: 1,
        dropShadowAngle: Math.PI / 6,
        dropShadowBlur: 0,
        dropShadowColor: "black",
        dropShadowDistance: 5,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: "black",
        strokeThickness: 0,
        whiteSpace: "normal",
        wordWrap: false,
        wordWrapWidth: 100
      };
      HTMLTextStyle = _HTMLTextStyle;
    }
  });

  // node_modules/@pixi/text-html/lib/HTMLText.mjs
  var _HTMLText;
  var init_HTMLText = __esm({
    "node_modules/@pixi/text-html/lib/HTMLText.mjs"() {
      init_lib9();
      init_lib11();
      init_lib31();
      init_HTMLTextStyle();
      _HTMLText = class _HTMLText2 extends Sprite {
        constructor(text = "", style = {}) {
          super(Texture.EMPTY), this._text = null, this._style = null, this._autoResolution = true, this.localStyleID = -1, this.dirty = false, this._updateID = 0, this.ownsStyle = false;
          const image = new Image(), texture = Texture.from(image, {
            scaleMode: settings.SCALE_MODE,
            resourceOptions: {
              autoLoad: false
            }
          });
          texture.orig = new Rectangle(), texture.trim = new Rectangle(), this.texture = texture;
          const nssvg2 = "http://www.w3.org/2000/svg", nsxhtml2 = "http://www.w3.org/1999/xhtml", svgRoot = document.createElementNS(nssvg2, "svg"), foreignObject = document.createElementNS(nssvg2, "foreignObject"), domElement = document.createElementNS(nsxhtml2, "div"), styleElement = document.createElementNS(nsxhtml2, "style");
          foreignObject.setAttribute("width", "10000"), foreignObject.setAttribute("height", "10000"), foreignObject.style.overflow = "hidden", svgRoot.appendChild(foreignObject), this.maxWidth = _HTMLText2.defaultMaxWidth, this.maxHeight = _HTMLText2.defaultMaxHeight, this._domElement = domElement, this._styleElement = styleElement, this._svgRoot = svgRoot, this._foreignObject = foreignObject, this._foreignObject.appendChild(styleElement), this._foreignObject.appendChild(domElement), this._image = image, this._loadImage = new Image(), this._autoResolution = _HTMLText2.defaultAutoResolution, this._resolution = _HTMLText2.defaultResolution ?? settings.RESOLUTION, this.text = text, this.style = style;
        }
        measureText(overrides) {
          const { text, style, resolution } = Object.assign({
            text: this._text,
            style: this._style,
            resolution: this._resolution
          }, overrides);
          Object.assign(this._domElement, {
            innerHTML: text,
            style: style.toCSS(resolution)
          }), this._styleElement.textContent = style.toGlobalCSS(), document.body.appendChild(this._svgRoot);
          const contentBounds = this._domElement.getBoundingClientRect();
          this._svgRoot.remove();
          const { width, height } = contentBounds;
          (width > this.maxWidth || height > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
          const contentWidth = Math.min(this.maxWidth, Math.ceil(width)), contentHeight = Math.min(this.maxHeight, Math.ceil(height));
          return this._svgRoot.setAttribute("width", contentWidth.toString()), this._svgRoot.setAttribute("height", contentHeight.toString()), text !== this._text && (this._domElement.innerHTML = this._text), style !== this._style && (Object.assign(this._domElement, { style: this._style?.toCSS(resolution) }), this._styleElement.textContent = this._style?.toGlobalCSS()), {
            width: contentWidth + style.padding * 2,
            height: contentHeight + style.padding * 2
          };
        }
        async updateText(respectDirty = true) {
          const { style, _image: image, _loadImage: loadImage } = this;
          if (this.localStyleID !== style.styleID && (this.dirty = true, this.localStyleID = style.styleID), !this.dirty && respectDirty)
            return;
          const { width, height } = this.measureText();
          image.width = loadImage.width = Math.ceil(Math.max(1, width)), image.height = loadImage.height = Math.ceil(Math.max(1, height)), this._updateID++;
          const updateID = this._updateID;
          await new Promise((resolve2) => {
            loadImage.onload = async () => {
              if (updateID < this._updateID) {
                resolve2();
                return;
              }
              await style.onBeforeDraw(), image.src = loadImage.src, loadImage.onload = null, loadImage.src = "", this.updateTexture(), resolve2();
            };
            const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
            loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
          });
        }
        get source() {
          return this._image;
        }
        updateTexture() {
          const { style, texture, _image: image, resolution } = this, { padding } = style, { baseTexture } = texture;
          texture.trim.width = texture._frame.width = image.width / resolution, texture.trim.height = texture._frame.height = image.height / resolution, texture.trim.x = -padding, texture.trim.y = -padding, texture.orig.width = texture._frame.width - padding * 2, texture.orig.height = texture._frame.height - padding * 2, this._onTextureUpdate(), baseTexture.setRealSize(image.width, image.height, resolution), this.dirty = false;
        }
        _render(renderer) {
          this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true), this.updateText(true), super._render(renderer);
        }
        _renderCanvas(renderer) {
          this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = true), this.updateText(true), super._renderCanvas(renderer);
        }
        getLocalBounds(rect) {
          return this.updateText(true), super.getLocalBounds(rect);
        }
        _calculateBounds() {
          this.updateText(true), this.calculateVertices(), this._bounds.addQuad(this.vertexData);
        }
        _onStyleChange() {
          this.dirty = true;
        }
        destroy(options) {
          typeof options == "boolean" && (options = { children: options }), options = Object.assign({}, _HTMLText2.defaultDestroyOptions, options), super.destroy(options);
          const forceClear = null;
          this.ownsStyle && this._style?.cleanFonts(), this._style = forceClear, this._svgRoot?.remove(), this._svgRoot = forceClear, this._domElement?.remove(), this._domElement = forceClear, this._foreignObject?.remove(), this._foreignObject = forceClear, this._styleElement?.remove(), this._styleElement = forceClear, this._loadImage.src = "", this._loadImage.onload = null, this._loadImage = forceClear, this._image.src = "", this._image = forceClear;
        }
        get width() {
          return this.updateText(true), Math.abs(this.scale.x) * this._image.width / this.resolution;
        }
        set width(value) {
          this.updateText(true);
          const s2 = lib_exports.sign(this.scale.x) || 1;
          this.scale.x = s2 * value / this._image.width / this.resolution, this._width = value;
        }
        get height() {
          return this.updateText(true), Math.abs(this.scale.y) * this._image.height / this.resolution;
        }
        set height(value) {
          this.updateText(true);
          const s2 = lib_exports.sign(this.scale.y) || 1;
          this.scale.y = s2 * value / this._image.height / this.resolution, this._height = value;
        }
        get style() {
          return this._style;
        }
        set style(style) {
          this._style !== style && (style = style || {}, style instanceof HTMLTextStyle ? (this.ownsStyle = false, this._style = style) : style instanceof TextStyle ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = true, this._style = HTMLTextStyle.from(style)) : (this.ownsStyle = true, this._style = new HTMLTextStyle(style)), this.localStyleID = -1, this.dirty = true);
        }
        get text() {
          return this._text;
        }
        set text(text) {
          text = String(text === "" || text === null || text === void 0 ? " " : text), text = this.sanitiseText(text), this._text !== text && (this._text = text, this.dirty = true);
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(value) {
          this._autoResolution = false, this._resolution !== value && (this._resolution = value, this.dirty = true);
        }
        sanitiseText(text) {
          return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
        }
      };
      _HTMLText.defaultDestroyOptions = {
        texture: true,
        children: false,
        baseTexture: true
      }, _HTMLText.defaultMaxWidth = 2024, _HTMLText.defaultMaxHeight = 2024, _HTMLText.defaultAutoResolution = true;
    }
  });

  // node_modules/@pixi/text-html/lib/index.mjs
  var init_lib37 = __esm({
    "node_modules/@pixi/text-html/lib/index.mjs"() {
      init_HTMLText();
      init_HTMLTextStyle();
    }
  });

  // node_modules/pixi-v7/lib/index.mjs
  var init_lib38 = __esm({
    "node_modules/pixi-v7/lib/index.mjs"() {
      init_lib12();
      init_lib13();
      init_lib14();
      init_filters();
      init_lib22();
      init_lib23();
      init_lib24();
      init_lib25();
      init_lib9();
      init_lib10();
      init_lib21();
      init_lib26();
      init_lib15();
      init_lib16();
      init_lib17();
      init_lib18();
      init_lib19();
      init_lib20();
      init_lib27();
      init_lib28();
      init_lib29();
      init_lib30();
      init_lib32();
      init_lib11();
      init_lib33();
      init_lib34();
      init_lib35();
      init_lib31();
      init_lib36();
      init_lib37();
    }
  });

  // src/bunny-mark/v7/Bunny-v7.ts
  var BunnyV7;
  var init_Bunny_v7 = __esm({
    "src/bunny-mark/v7/Bunny-v7.ts"() {
      init_lib38();
      BunnyV7 = class {
        constructor(texture, bounds) {
          this.gravity = 0.75;
          this.speedX = Math.random() * 10;
          this.speedY = Math.random() * 10 - 5;
          this.positionX = 0;
          this.positionY = 0;
          this.view = new Sprite(texture);
          this.view.anchor.set(0.5, 1);
          this.bounds = bounds;
        }
        update() {
          let pX = this.positionX;
          let pY = this.positionY;
          pX += this.speedX;
          pY += this.speedY;
          this.speedY += this.gravity;
          if (pX > this.bounds.right) {
            this.speedX *= -1;
            pX = this.bounds.right;
          } else if (pX < this.bounds.left) {
            this.speedX *= -1;
            pX = this.bounds.left;
          }
          if (pY > this.bounds.bottom) {
            this.speedY *= -0.85;
            pY = this.bounds.bottom;
            if (Math.random() > 0.5) {
              this.speedY -= Math.random() * 6;
            }
          } else if (pY < this.bounds.top) {
            this.speedY = 0;
            pY = this.bounds.top;
          }
          this.view.position.x = this.positionX = pX;
          this.view.position.y = this.positionY = pY;
        }
      };
    }
  });

  // src/bunny-mark/v7/bunny-mark-v7.ts
  var bunny_mark_v7_exports = {};
  __export(bunny_mark_v7_exports, {
    bunnyMarkV7: () => bunnyMarkV7
  });
  async function bunnyMarkV7({ totalBunnies }) {
    const renderer = new Renderer({
      clearBeforeRender: true,
      backgroundAlpha: 1,
      backgroundColor: 16777215,
      width: 800,
      height: 600,
      resolution: 1,
      antialias: false
    });
    document.body.appendChild(renderer.view);
    const stage = new Container();
    const textures = Object.values(await Assets.load([
      "./assets/bunnies/rabbitv3_ash.png",
      "./assets/bunnies/rabbitv3_batman.png",
      "./assets/bunnies/rabbitv3_bb8.png",
      "./assets/bunnies/rabbitv3_frankenstein.png",
      "./assets/bunnies/rabbitv3_neo.png",
      "./assets/bunnies/rabbitv3_sonic.png",
      "./assets/bunnies/rabbitv3_spidey.png",
      "./assets/bunnies/rabbitv3_stormtrooper.png",
      "./assets/bunnies/rabbitv3_superman.png",
      "./assets/bunnies/rabbitv3_tron.png",
      "./assets/bunnies/rabbitv3_wolverine.png",
      "./assets/bunnies/rabbitv3.png"
    ]));
    const bounds = new Rectangle(0, 0, 800, 600);
    const bunnies = [];
    function addBunny() {
      const bunny = new BunnyV7(textures[bunnies.length % textures.length], bounds);
      stage.addChild(bunny.view);
      bunnies.push(bunny);
    }
    for (let i2 = 0; i2 < totalBunnies; i2++) {
      addBunny();
    }
    let pause = false;
    renderer.view.addEventListener("mousedown", () => {
      pause = !pause;
      addBunny();
    });
    function renderUpdate() {
      if (!pause) {
        for (let i2 = 0; i2 < bunnies.length; i2++) {
          bunnies[i2].update();
        }
      }
      renderer.render(stage);
      requestAnimationFrame(renderUpdate);
    }
    renderUpdate();
  }
  var init_bunny_mark_v7 = __esm({
    "src/bunny-mark/v7/bunny-mark-v7.ts"() {
      init_lib38();
      init_Bunny_v7();
      EventSystem.defaultEventFeatures.move = false;
      EventSystem.defaultEventFeatures.globalMove = false;
      BaseTexture.defaultOptions.scaleMode = SCALE_MODES.NEAREST;
    }
  });

  // node_modules/pixi-v8/lib/extensions/Extensions.mjs
  var ExtensionType2, normalizeExtension2, normalizeExtensionPriority, extensions3;
  var init_Extensions = __esm({
    "node_modules/pixi-v8/lib/extensions/Extensions.mjs"() {
      "use strict";
      ExtensionType2 = /* @__PURE__ */ ((ExtensionType22) => {
        ExtensionType22["Application"] = "application";
        ExtensionType22["WebGLPipes"] = "webgl-pipes";
        ExtensionType22["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
        ExtensionType22["WebGLSystem"] = "webgl-system";
        ExtensionType22["WebGPUPipes"] = "webgpu-pipes";
        ExtensionType22["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
        ExtensionType22["WebGPUSystem"] = "webgpu-system";
        ExtensionType22["CanvasSystem"] = "canvas-system";
        ExtensionType22["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
        ExtensionType22["CanvasPipes"] = "canvas-pipes";
        ExtensionType22["Asset"] = "asset";
        ExtensionType22["LoadParser"] = "load-parser";
        ExtensionType22["ResolveParser"] = "resolve-parser";
        ExtensionType22["CacheParser"] = "cache-parser";
        ExtensionType22["DetectionParser"] = "detection-parser";
        ExtensionType22["MaskEffect"] = "mask-effect";
        ExtensionType22["BlendMode"] = "blend-mode";
        ExtensionType22["TextureSource"] = "texture-source";
        ExtensionType22["Environment"] = "environment";
        ExtensionType22["ShapeBuilder"] = "shape-builder";
        ExtensionType22["Batcher"] = "batcher";
        return ExtensionType22;
      })(ExtensionType2 || {});
      normalizeExtension2 = (ext) => {
        if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
          if (!ext.extension) {
            throw new Error("Extension class must have an extension object");
          }
          const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
          ext = { ...metadata, ref: ext };
        }
        if (typeof ext === "object") {
          ext = { ...ext };
        } else {
          throw new Error("Invalid extension type");
        }
        if (typeof ext.type === "string") {
          ext.type = [ext.type];
        }
        return ext;
      };
      normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension2(ext).priority ?? defaultPriority;
      extensions3 = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...extensions22) {
          extensions22.map(normalizeExtension2).forEach((ext) => {
            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
          });
          return this;
        },
        add(...extensions22) {
          extensions22.map(normalizeExtension2).forEach((ext) => {
            ext.type.forEach((type) => {
              const handlers = this._addHandlers;
              const queue = this._queue;
              if (!handlers[type]) {
                queue[type] = queue[type] || [];
                queue[type]?.push(ext);
              } else {
                handlers[type]?.(ext);
              }
            });
          });
          return this;
        },
        handle(type, onAdd, onRemove) {
          const addHandlers = this._addHandlers;
          const removeHandlers = this._removeHandlers;
          if (addHandlers[type] || removeHandlers[type]) {
            throw new Error(`Extension type ${type} already has a handler`);
          }
          addHandlers[type] = onAdd;
          removeHandlers[type] = onRemove;
          const queue = this._queue;
          if (queue[type]) {
            queue[type]?.forEach((ext) => onAdd(ext));
            delete queue[type];
          }
          return this;
        },
        handleByMap(type, map4) {
          return this.handle(
            type,
            (extension) => {
              if (extension.name) {
                map4[extension.name] = extension.ref;
              }
            },
            (extension) => {
              if (extension.name) {
                delete map4[extension.name];
              }
            }
          );
        },
        handleByNamedList(type, map4, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              const index = map4.findIndex((item) => item.name === extension.name);
              if (index >= 0)
                return;
              map4.push({ name: extension.name, value: extension.ref });
              map4.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
            },
            (extension) => {
              const index = map4.findIndex((item) => item.name === extension.name);
              if (index !== -1) {
                map4.splice(index, 1);
              }
            }
          );
        },
        handleByList(type, list, defaultPriority = -1) {
          return this.handle(
            type,
            (extension) => {
              if (list.includes(extension.ref)) {
                return;
              }
              list.push(extension.ref);
              list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
            },
            (extension) => {
              const index = list.indexOf(extension.ref);
              if (index !== -1) {
                list.splice(index, 1);
              }
            }
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/node_modules/eventemitter3/index.js
  var require_eventemitter32 = __commonJS({
    "node_modules/pixi-v8/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context3, once) {
        this.fn = fn;
        this.context = context3;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context3, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context3 || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context3) {
        return addListener(this, event, fn, context3, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context3) {
        return addListener(this, event, fn, context3, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context3, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context3 || listeners.context === context3)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context3 && listeners[i2].context !== context3) {
              events.push(listeners[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/pixi-v8/node_modules/eventemitter3/index.mjs
  var import_index2, eventemitter3_default;
  var init_eventemitter3 = __esm({
    "node_modules/pixi-v8/node_modules/eventemitter3/index.mjs"() {
      import_index2 = __toESM(require_eventemitter32(), 1);
      eventemitter3_default = import_index2.default;
    }
  });

  // node_modules/pixi-v8/lib/color/Color.mjs
  var _Color3, Color2;
  var init_Color2 = __esm({
    "node_modules/pixi-v8/lib/color/Color.mjs"() {
      init_colord();
      init_names();
      k([names_default]);
      _Color3 = class _Color4 {
        constructor(value = 16777215) {
          this._value = null;
          this._components = new Float32Array(4);
          this._components.fill(1);
          this._int = 16777215;
          this.value = value;
        }
        get red() {
          return this._components[0];
        }
        get green() {
          return this._components[1];
        }
        get blue() {
          return this._components[2];
        }
        get alpha() {
          return this._components[3];
        }
        setValue(value) {
          this.value = value;
          return this;
        }
        set value(value) {
          if (value instanceof _Color4) {
            this._value = this._cloneSource(value._value);
            this._int = value._int;
            this._components.set(value._components);
          } else if (value === null) {
            throw new Error("Cannot set Color#value to null");
          } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
            this._value = this._cloneSource(value);
            this._normalize(this._value);
          }
        }
        get value() {
          return this._value;
        }
        _cloneSource(value) {
          if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
            return value;
          } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
            return value.slice(0);
          } else if (typeof value === "object" && value !== null) {
            return { ...value };
          }
          return value;
        }
        _isSourceEqual(value1, value2) {
          const type1 = typeof value1;
          const type2 = typeof value2;
          if (type1 !== type2) {
            return false;
          } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
            return value1 === value2;
          } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
            if (value1.length !== value2.length) {
              return false;
            }
            return value1.every((v2, i2) => v2 === value2[i2]);
          } else if (value1 !== null && value2 !== null) {
            const keys1 = Object.keys(value1);
            const keys2 = Object.keys(value2);
            if (keys1.length !== keys2.length) {
              return false;
            }
            return keys1.every((key) => value1[key] === value2[key]);
          }
          return value1 === value2;
        }
        toRgba() {
          const [r2, g2, b2, a2] = this._components;
          return { r: r2, g: g2, b: b2, a: a2 };
        }
        toRgb() {
          const [r2, g2, b2] = this._components;
          return { r: r2, g: g2, b: b2 };
        }
        toRgbaString() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return `rgba(${r2},${g2},${b2},${this.alpha})`;
        }
        toUint8RgbArray(out2) {
          const [r2, g2, b2] = this._components;
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          out2[0] = Math.round(r2 * 255);
          out2[1] = Math.round(g2 * 255);
          out2[2] = Math.round(b2 * 255);
          return out2;
        }
        toArray(out2) {
          if (!this._arrayRgba) {
            this._arrayRgba = [];
          }
          out2 = out2 || this._arrayRgba;
          const [r2, g2, b2, a2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          out2[3] = a2;
          return out2;
        }
        toRgbArray(out2) {
          if (!this._arrayRgb) {
            this._arrayRgb = [];
          }
          out2 = out2 || this._arrayRgb;
          const [r2, g2, b2] = this._components;
          out2[0] = r2;
          out2[1] = g2;
          out2[2] = b2;
          return out2;
        }
        toNumber() {
          return this._int;
        }
        toBgrNumber() {
          const [r2, g2, b2] = this.toUint8RgbArray();
          return (b2 << 16) + (g2 << 8) + r2;
        }
        toLittleEndianNumber() {
          const value = this._int;
          return (value >> 16) + (value & 65280) + ((value & 255) << 16);
        }
        multiply(value) {
          const [r2, g2, b2, a2] = _Color4._temp.setValue(value)._components;
          this._components[0] *= r2;
          this._components[1] *= g2;
          this._components[2] *= b2;
          this._components[3] *= a2;
          this._refreshInt();
          this._value = null;
          return this;
        }
        premultiply(alpha, applyToRGB = true) {
          if (applyToRGB) {
            this._components[0] *= alpha;
            this._components[1] *= alpha;
            this._components[2] *= alpha;
          }
          this._components[3] = alpha;
          this._refreshInt();
          this._value = null;
          return this;
        }
        toPremultiplied(alpha, applyToRGB = true) {
          if (alpha === 1) {
            return (255 << 24) + this._int;
          }
          if (alpha === 0) {
            return applyToRGB ? 0 : this._int;
          }
          let r2 = this._int >> 16 & 255;
          let g2 = this._int >> 8 & 255;
          let b2 = this._int & 255;
          if (applyToRGB) {
            r2 = r2 * alpha + 0.5 | 0;
            g2 = g2 * alpha + 0.5 | 0;
            b2 = b2 * alpha + 0.5 | 0;
          }
          return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
        }
        toHex() {
          const hexString = this._int.toString(16);
          return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
        }
        toHexa() {
          const alphaValue = Math.round(this._components[3] * 255);
          const alphaString = alphaValue.toString(16);
          return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
        }
        setAlpha(alpha) {
          this._components[3] = this._clamp(alpha);
          return this;
        }
        _normalize(value) {
          let r2;
          let g2;
          let b2;
          let a2;
          if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
            const int = value;
            r2 = (int >> 16 & 255) / 255;
            g2 = (int >> 8 & 255) / 255;
            b2 = (int & 255) / 255;
            a2 = 1;
          } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value);
            [r2, g2, b2, a2 = 1] = value;
          } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
            value = this._clamp(value, 0, 255);
            [r2, g2, b2, a2 = 255] = value;
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
            a2 /= 255;
          } else if (typeof value === "string" || typeof value === "object") {
            if (typeof value === "string") {
              const match = _Color4.HEX_PATTERN.exec(value);
              if (match) {
                value = `#${match[2]}`;
              }
            }
            const color = w(value);
            if (color.isValid()) {
              ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
              r2 /= 255;
              g2 /= 255;
              b2 /= 255;
            }
          }
          if (r2 !== void 0) {
            this._components[0] = r2;
            this._components[1] = g2;
            this._components[2] = b2;
            this._components[3] = a2;
            this._refreshInt();
          } else {
            throw new Error(`Unable to convert color ${value}`);
          }
        }
        _refreshInt() {
          this._clamp(this._components);
          const [r2, g2, b2] = this._components;
          this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
        }
        _clamp(value, min = 0, max = 1) {
          if (typeof value === "number") {
            return Math.min(Math.max(value, min), max);
          }
          value.forEach((v2, i2) => {
            value[i2] = Math.min(Math.max(v2, min), max);
          });
          return value;
        }
        static isColorLike(value) {
          return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color4 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
        }
      };
      _Color3.shared = new _Color3();
      _Color3._temp = new _Color3();
      _Color3.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
      Color2 = _Color3;
    }
  });

  // node_modules/pixi-v8/lib/culling/cullingMixin.mjs
  var cullingMixin;
  var init_cullingMixin = __esm({
    "node_modules/pixi-v8/lib/culling/cullingMixin.mjs"() {
      "use strict";
      cullingMixin = {
        cullArea: null,
        cullable: false,
        cullableChildren: true
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/misc/const.mjs
  var PI_22, RAD_TO_DEG2, DEG_TO_RAD2;
  var init_const7 = __esm({
    "node_modules/pixi-v8/lib/maths/misc/const.mjs"() {
      "use strict";
      PI_22 = Math.PI * 2;
      RAD_TO_DEG2 = 180 / Math.PI;
      DEG_TO_RAD2 = Math.PI / 180;
    }
  });

  // node_modules/pixi-v8/lib/maths/point/Point.mjs
  var Point2, tempPoint4;
  var init_Point2 = __esm({
    "node_modules/pixi-v8/lib/maths/point/Point.mjs"() {
      "use strict";
      Point2 = class {
        constructor(x2 = 0, y2 = 0) {
          this.x = 0;
          this.y = 0;
          this.x = x2;
          this.y = y2;
        }
        clone() {
          return new Point2(this.x, this.y);
        }
        copyFrom(p2) {
          this.set(p2.x, p2.y);
          return this;
        }
        copyTo(p2) {
          p2.set(this.x, this.y);
          return p2;
        }
        equals(p2) {
          return p2.x === this.x && p2.y === this.y;
        }
        set(x2 = 0, y2 = x2) {
          this.x = x2;
          this.y = y2;
          return this;
        }
        toString() {
          return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
        }
        static get shared() {
          tempPoint4.x = 0;
          tempPoint4.y = 0;
          return tempPoint4;
        }
      };
      tempPoint4 = new Point2();
    }
  });

  // node_modules/pixi-v8/lib/maths/matrix/Matrix.mjs
  var Matrix2, tempMatrix4, identityMatrix;
  var init_Matrix2 = __esm({
    "node_modules/pixi-v8/lib/maths/matrix/Matrix.mjs"() {
      init_const7();
      init_Point2();
      Matrix2 = class {
        constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
          this.array = null;
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
        }
        fromArray(array) {
          this.a = array[0];
          this.b = array[1];
          this.c = array[3];
          this.d = array[4];
          this.tx = array[2];
          this.ty = array[5];
        }
        set(a2, b2, c2, d2, tx, ty) {
          this.a = a2;
          this.b = b2;
          this.c = c2;
          this.d = d2;
          this.tx = tx;
          this.ty = ty;
          return this;
        }
        toArray(transpose, out2) {
          if (!this.array) {
            this.array = new Float32Array(9);
          }
          const array = out2 || this.array;
          if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
          } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
          }
          return array;
        }
        apply(pos, newPos) {
          newPos = newPos || new Point2();
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = this.a * x2 + this.c * y2 + this.tx;
          newPos.y = this.b * x2 + this.d * y2 + this.ty;
          return newPos;
        }
        applyInverse(pos, newPos) {
          newPos = newPos || new Point2();
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const tx = this.tx;
          const ty = this.ty;
          const id = 1 / (a2 * d2 + c2 * -b2);
          const x2 = pos.x;
          const y2 = pos.y;
          newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
          newPos.y = a2 * id * y2 + -b2 * id * x2 + (-ty * a2 + tx * b2) * id;
          return newPos;
        }
        translate(x2, y2) {
          this.tx += x2;
          this.ty += y2;
          return this;
        }
        scale(x2, y2) {
          this.a *= x2;
          this.d *= y2;
          this.c *= x2;
          this.b *= y2;
          this.tx *= x2;
          this.ty *= y2;
          return this;
        }
        rotate(angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const a1 = this.a;
          const c1 = this.c;
          const tx1 = this.tx;
          this.a = a1 * cos - this.b * sin;
          this.b = a1 * sin + this.b * cos;
          this.c = c1 * cos - this.d * sin;
          this.d = c1 * sin + this.d * cos;
          this.tx = tx1 * cos - this.ty * sin;
          this.ty = tx1 * sin + this.ty * cos;
          return this;
        }
        append(matrix) {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          this.a = matrix.a * a1 + matrix.b * c1;
          this.b = matrix.a * b1 + matrix.b * d1;
          this.c = matrix.c * a1 + matrix.d * c1;
          this.d = matrix.c * b1 + matrix.d * d1;
          this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
          this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
          return this;
        }
        appendFrom(a2, b2) {
          const a1 = a2.a;
          const b1 = a2.b;
          const c1 = a2.c;
          const d1 = a2.d;
          const tx = a2.tx;
          const ty = a2.ty;
          const a22 = b2.a;
          const b22 = b2.b;
          const c2 = b2.c;
          const d2 = b2.d;
          this.a = a1 * a22 + b1 * c2;
          this.b = a1 * b22 + b1 * d2;
          this.c = c1 * a22 + d1 * c2;
          this.d = c1 * b22 + d1 * d2;
          this.tx = tx * a22 + ty * c2 + b2.tx;
          this.ty = tx * b22 + ty * d2 + b2.ty;
          return this;
        }
        setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
          this.a = Math.cos(rotation + skewY) * scaleX;
          this.b = Math.sin(rotation + skewY) * scaleX;
          this.c = -Math.sin(rotation - skewX) * scaleY;
          this.d = Math.cos(rotation - skewX) * scaleY;
          this.tx = x2 - (pivotX * this.a + pivotY * this.c);
          this.ty = y2 - (pivotX * this.b + pivotY * this.d);
          return this;
        }
        prepend(matrix) {
          const tx1 = this.tx;
          if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = a1 * matrix.a + this.b * matrix.c;
            this.b = a1 * matrix.b + this.b * matrix.d;
            this.c = c1 * matrix.a + this.d * matrix.c;
            this.d = c1 * matrix.b + this.d * matrix.d;
          }
          this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
          this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
          return this;
        }
        decompose(transform2) {
          const a2 = this.a;
          const b2 = this.b;
          const c2 = this.c;
          const d2 = this.d;
          const pivot = transform2.pivot;
          const skewX = -Math.atan2(-c2, d2);
          const skewY = Math.atan2(b2, a2);
          const delta = Math.abs(skewX + skewY);
          if (delta < 1e-5 || Math.abs(PI_22 - delta) < 1e-5) {
            transform2.rotation = skewY;
            transform2.skew.x = transform2.skew.y = 0;
          } else {
            transform2.rotation = 0;
            transform2.skew.x = skewX;
            transform2.skew.y = skewY;
          }
          transform2.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
          transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
          transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
          transform2.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
          return transform2;
        }
        invert() {
          const a1 = this.a;
          const b1 = this.b;
          const c1 = this.c;
          const d1 = this.d;
          const tx1 = this.tx;
          const n2 = a1 * d1 - b1 * c1;
          this.a = d1 / n2;
          this.b = -b1 / n2;
          this.c = -c1 / n2;
          this.d = a1 / n2;
          this.tx = (c1 * this.ty - d1 * tx1) / n2;
          this.ty = -(a1 * this.ty - b1 * tx1) / n2;
          return this;
        }
        isIdentity() {
          return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
        }
        identity() {
          this.a = 1;
          this.b = 0;
          this.c = 0;
          this.d = 1;
          this.tx = 0;
          this.ty = 0;
          return this;
        }
        clone() {
          const matrix = new Matrix2();
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        copyTo(matrix) {
          matrix.a = this.a;
          matrix.b = this.b;
          matrix.c = this.c;
          matrix.d = this.d;
          matrix.tx = this.tx;
          matrix.ty = this.ty;
          return matrix;
        }
        copyFrom(matrix) {
          this.a = matrix.a;
          this.b = matrix.b;
          this.c = matrix.c;
          this.d = matrix.d;
          this.tx = matrix.tx;
          this.ty = matrix.ty;
          return this;
        }
        equals(matrix) {
          return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
        }
        toString() {
          return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
        }
        static get IDENTITY() {
          return identityMatrix.identity();
        }
        static get shared() {
          return tempMatrix4.identity();
        }
      };
      tempMatrix4 = new Matrix2();
      identityMatrix = new Matrix2();
    }
  });

  // node_modules/pixi-v8/lib/maths/point/ObservablePoint.mjs
  var ObservablePoint2;
  var init_ObservablePoint2 = __esm({
    "node_modules/pixi-v8/lib/maths/point/ObservablePoint.mjs"() {
      "use strict";
      ObservablePoint2 = class {
        constructor(observer, x2, y2) {
          this._x = x2 || 0;
          this._y = y2 || 0;
          this._observer = observer;
        }
        clone(observer) {
          return new ObservablePoint2(observer ?? this._observer, this._x, this._y);
        }
        set(x2 = 0, y2 = x2) {
          if (this._x !== x2 || this._y !== y2) {
            this._x = x2;
            this._y = y2;
            this._observer._onUpdate(this);
          }
          return this;
        }
        copyFrom(p2) {
          if (this._x !== p2.x || this._y !== p2.y) {
            this._x = p2.x;
            this._y = p2.y;
            this._observer._onUpdate(this);
          }
          return this;
        }
        copyTo(p2) {
          p2.set(this._x, this._y);
          return p2;
        }
        equals(p2) {
          return p2.x === this._x && p2.y === this._y;
        }
        toString() {
          return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
        }
        get x() {
          return this._x;
        }
        set x(value) {
          if (this._x !== value) {
            this._x = value;
            this._observer._onUpdate(this);
          }
        }
        get y() {
          return this._y;
        }
        set y(value) {
          if (this._y !== value) {
            this._y = value;
            this._observer._onUpdate(this);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/data/uid.mjs
  function uid2(name = "default") {
    if (uidCache[name] === void 0) {
      uidCache[name] = -1;
    }
    return ++uidCache[name];
  }
  var uidCache;
  var init_uid2 = __esm({
    "node_modules/pixi-v8/lib/utils/data/uid.mjs"() {
      "use strict";
      uidCache = {
        default: -1
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/logging/deprecation.mjs
  function deprecation2(version, message, ignoreDepth = 3) {
    if (warnings2[message]) {
      return;
    }
    let stack = new Error().stack;
    if (typeof stack === "undefined") {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
    } else {
      stack = stack.split("\n").splice(ignoreDepth).join("\n");
      if (console.groupCollapsed) {
        console.groupCollapsed(
          "%cPixiJS Deprecation Warning: %c%s",
          "color:#614108;background:#fffbe6",
          "font-weight:normal;color:#614108;background:#fffbe6",
          `${message}
Deprecated since v${version}`
        );
        console.warn(stack);
        console.groupEnd();
      } else {
        console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
        console.warn(stack);
      }
    }
    warnings2[message] = true;
  }
  var warnings2, v8_0_0, v8_3_4;
  var init_deprecation2 = __esm({
    "node_modules/pixi-v8/lib/utils/logging/deprecation.mjs"() {
      "use strict";
      warnings2 = {};
      v8_0_0 = "8.0.0";
      v8_3_4 = "8.3.4";
    }
  });

  // node_modules/pixi-v8/lib/utils/pool/Pool.mjs
  var Pool;
  var init_Pool = __esm({
    "node_modules/pixi-v8/lib/utils/pool/Pool.mjs"() {
      "use strict";
      Pool = class {
        constructor(ClassType, initialSize) {
          this._pool = [];
          this._count = 0;
          this._index = 0;
          this._classType = ClassType;
          if (initialSize) {
            this.prepopulate(initialSize);
          }
        }
        prepopulate(total) {
          for (let i2 = 0; i2 < total; i2++) {
            this._pool[this._index++] = new this._classType();
          }
          this._count += total;
        }
        get(data) {
          let item;
          if (this._index > 0) {
            item = this._pool[--this._index];
          } else {
            item = new this._classType();
          }
          item.init?.(data);
          return item;
        }
        return(item) {
          item.reset?.();
          this._pool[this._index++] = item;
        }
        get totalSize() {
          return this._count;
        }
        get totalFree() {
          return this._index;
        }
        get totalUsed() {
          return this._count - this._index;
        }
        clear() {
          this._pool.length = 0;
          this._index = 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/pool/PoolGroup.mjs
  var PoolGroupClass, BigPool;
  var init_PoolGroup = __esm({
    "node_modules/pixi-v8/lib/utils/pool/PoolGroup.mjs"() {
      init_Pool();
      PoolGroupClass = class {
        constructor() {
          this._poolsByClass = /* @__PURE__ */ new Map();
        }
        prepopulate(Class, total) {
          const classPool = this.getPool(Class);
          classPool.prepopulate(total);
        }
        get(Class, data) {
          const pool = this.getPool(Class);
          return pool.get(data);
        }
        return(item) {
          const pool = this.getPool(item.constructor);
          pool.return(item);
        }
        getPool(ClassType) {
          if (!this._poolsByClass.has(ClassType)) {
            this._poolsByClass.set(ClassType, new Pool(ClassType));
          }
          return this._poolsByClass.get(ClassType);
        }
        stats() {
          const stats = {};
          this._poolsByClass.forEach((pool) => {
            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
            stats[name] = {
              free: pool.totalFree,
              used: pool.totalUsed,
              size: pool.totalSize
            };
          });
          return stats;
        }
      };
      BigPool = new PoolGroupClass();
    }
  });

  // node_modules/pixi-v8/lib/utils/data/removeItems.mjs
  function removeItems2(arr, startIdx, removeCount) {
    const length = arr.length;
    let i2;
    if (startIdx >= length || removeCount === 0) {
      return;
    }
    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    const len = length - removeCount;
    for (i2 = startIdx; i2 < len; ++i2) {
      arr[i2] = arr[i2 + removeCount];
    }
    arr.length = len;
  }
  var init_removeItems2 = __esm({
    "node_modules/pixi-v8/lib/utils/data/removeItems.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/childrenHelperMixin.mjs
  var childrenHelperMixin;
  var init_childrenHelperMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
      init_removeItems2();
      init_deprecation2();
      childrenHelperMixin = {
        allowChildren: true,
        removeChildren(beginIndex = 0, endIndex) {
          const end = endIndex ?? this.children.length;
          const range = end - beginIndex;
          const removed = [];
          if (range > 0 && range <= end) {
            for (let i2 = end - 1; i2 >= beginIndex; i2--) {
              const child = this.children[i2];
              if (!child)
                continue;
              removed.push(child);
              child.parent = null;
            }
            removeItems2(this.children, beginIndex, end);
            const renderGroup = this.renderGroup || this.parentRenderGroup;
            if (renderGroup) {
              renderGroup.removeChildren(removed);
            }
            for (let i2 = 0; i2 < removed.length; ++i2) {
              this.emit("childRemoved", removed[i2], this, i2);
              removed[i2].emit("removed", this);
            }
            return removed;
          } else if (range === 0 && this.children.length === 0) {
            return removed;
          }
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        },
        removeChildAt(index) {
          const child = this.getChildAt(index);
          return this.removeChild(child);
        },
        getChildAt(index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`getChildAt: Index (${index}) does not exist.`);
          }
          return this.children[index];
        },
        setChildIndex(child, index) {
          if (index < 0 || index >= this.children.length) {
            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
          }
          this.getChildIndex(child);
          this.addChildAt(child, index);
        },
        getChildIndex(child) {
          const index = this.children.indexOf(child);
          if (index === -1) {
            throw new Error("The supplied Container must be a child of the caller");
          }
          return index;
        },
        addChildAt(child, index) {
          if (!this.allowChildren) {
            deprecation2(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
          }
          const { children } = this;
          if (index < 0 || index > children.length) {
            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
          }
          if (child.parent) {
            const currentIndex = child.parent.children.indexOf(child);
            if (child.parent === this && currentIndex === index) {
              return child;
            }
            if (currentIndex !== -1) {
              child.parent.children.splice(currentIndex, 1);
            }
          }
          if (index === children.length) {
            children.push(child);
          } else {
            children.splice(index, 0, child);
          }
          child.parent = this;
          child.didChange = true;
          child.didViewUpdate = false;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          if (this.sortableChildren)
            this.sortDirty = true;
          this.emit("childAdded", child, this, index);
          child.emit("added", this);
          return child;
        },
        swapChildren(child, child2) {
          if (child === child2) {
            return;
          }
          const index1 = this.getChildIndex(child);
          const index2 = this.getChildIndex(child2);
          this.children[index1] = child2;
          this.children[index2] = child;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._didContainerChangeTick++;
        },
        removeFromParent() {
          this.parent?.removeChild(this);
        },
        reparentChild(...child) {
          if (child.length === 1) {
            return this.reparentChildAt(child[0], this.children.length);
          }
          child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
          return child[0];
        },
        reparentChildAt(child, index) {
          if (child.parent === this) {
            this.setChildIndex(child, index);
            return child;
          }
          const childMat = child.worldTransform.clone();
          child.removeFromParent();
          this.addChildAt(child, index);
          const newMatrix = this.worldTransform.clone();
          newMatrix.invert();
          childMat.prepend(newMatrix);
          child.setFromMatrix(childMat);
          return child;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/FilterEffect.mjs
  var FilterEffect;
  var init_FilterEffect = __esm({
    "node_modules/pixi-v8/lib/filters/FilterEffect.mjs"() {
      "use strict";
      FilterEffect = class {
        constructor() {
          this.pipe = "filter";
          this.priority = 1;
        }
        destroy() {
          for (let i2 = 0; i2 < this.filters.length; i2++) {
            this.filters[i2].destroy();
          }
          this.filters = null;
          this.filterArea = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/MaskEffectManager.mjs
  var MaskEffectManagerClass, MaskEffectManager;
  var init_MaskEffectManager = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/MaskEffectManager.mjs"() {
      init_Extensions();
      init_PoolGroup();
      MaskEffectManagerClass = class {
        constructor() {
          this._effectClasses = [];
          this._tests = [];
          this._initialized = false;
        }
        init() {
          if (this._initialized)
            return;
          this._initialized = true;
          this._effectClasses.forEach((test) => {
            this.add({
              test: test.test,
              maskClass: test
            });
          });
        }
        add(test) {
          this._tests.push(test);
        }
        getMaskEffect(item) {
          if (!this._initialized)
            this.init();
          for (let i2 = 0; i2 < this._tests.length; i2++) {
            const test = this._tests[i2];
            if (test.test(item)) {
              return BigPool.get(test.maskClass, item);
            }
          }
          return item;
        }
        returnMaskEffect(effect) {
          BigPool.return(effect);
        }
      };
      MaskEffectManager = new MaskEffectManagerClass();
      extensions3.handleByList(ExtensionType2.MaskEffect, MaskEffectManager._effectClasses);
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/effectsMixin.mjs
  var effectsMixin;
  var init_effectsMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/effectsMixin.mjs"() {
      init_FilterEffect();
      init_MaskEffectManager();
      effectsMixin = {
        _maskEffect: null,
        _filterEffect: null,
        effects: [],
        addEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index !== -1)
            return;
          this.effects.push(effect);
          this.effects.sort((a2, b2) => a2.priority - b2.priority);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        removeEffect(effect) {
          const index = this.effects.indexOf(effect);
          if (index === -1)
            return;
          this.effects.splice(index, 1);
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateIsSimple();
        },
        set mask(value) {
          const effect = this._maskEffect;
          if (effect?.mask === value)
            return;
          if (effect) {
            this.removeEffect(effect);
            MaskEffectManager.returnMaskEffect(effect);
            this._maskEffect = null;
          }
          if (value === null || value === void 0)
            return;
          this._maskEffect = MaskEffectManager.getMaskEffect(value);
          this.addEffect(this._maskEffect);
        },
        get mask() {
          return this._maskEffect?.mask;
        },
        set filters(value) {
          if (!Array.isArray(value) && value)
            value = [value];
          const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
          value = value;
          const hasFilters = value?.length > 0;
          const hadFilters = effect.filters?.length > 0;
          const didChange = hasFilters !== hadFilters;
          value = Array.isArray(value) ? value.slice(0) : value;
          effect.filters = Object.freeze(value);
          if (didChange) {
            if (hasFilters) {
              this.addEffect(effect);
            } else {
              this.removeEffect(effect);
              effect.filters = value ?? null;
            }
          }
        },
        get filters() {
          return this._filterEffect?.filters;
        },
        set filterArea(value) {
          this._filterEffect || (this._filterEffect = new FilterEffect());
          this._filterEffect.filterArea = value;
        },
        get filterArea() {
          return this._filterEffect?.filterArea;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/findMixin.mjs
  var findMixin;
  var init_findMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/findMixin.mjs"() {
      init_deprecation2();
      findMixin = {
        label: null,
        get name() {
          deprecation2(v8_0_0, "Container.name property has been removed, use Container.label instead");
          return this.label;
        },
        set name(value) {
          deprecation2(v8_0_0, "Container.name property has been removed, use Container.label instead");
          this.label = value;
        },
        getChildByName(name, deep = false) {
          return this.getChildByLabel(name, deep);
        },
        getChildByLabel(label, deep = false) {
          const children = this.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.label === label || label instanceof RegExp && label.test(child.label))
              return child;
          }
          if (deep) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              const found = child.getChildByLabel(label, true);
              if (found) {
                return found;
              }
            }
          }
          return null;
        },
        getChildrenByLabel(label, deep = false, out2 = []) {
          const children = this.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.label === label || label instanceof RegExp && label.test(child.label)) {
              out2.push(child);
            }
          }
          if (deep) {
            for (let i2 = 0; i2 < children.length; i2++) {
              children[i2].getChildrenByLabel(label, true, out2);
            }
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Rectangle.mjs
  var tempPoints3, Rectangle2;
  var init_Rectangle2 = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Rectangle.mjs"() {
      init_Point2();
      tempPoints3 = [new Point2(), new Point2(), new Point2(), new Point2()];
      Rectangle2 = class {
        constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
          this.type = "rectangle";
          this.x = Number(x2);
          this.y = Number(y2);
          this.width = Number(width);
          this.height = Number(height);
        }
        get left() {
          return this.x;
        }
        get right() {
          return this.x + this.width;
        }
        get top() {
          return this.y;
        }
        get bottom() {
          return this.y + this.height;
        }
        isEmpty() {
          return this.left === this.right || this.top === this.bottom;
        }
        static get EMPTY() {
          return new Rectangle2(0, 0, 0, 0);
        }
        clone() {
          return new Rectangle2(this.x, this.y, this.width, this.height);
        }
        copyFromBounds(bounds) {
          this.x = bounds.minX;
          this.y = bounds.minY;
          this.width = bounds.maxX - bounds.minX;
          this.height = bounds.maxY - bounds.minY;
          return this;
        }
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 < this.x + this.width) {
            if (y2 >= this.y && y2 < this.y + this.height) {
              return true;
            }
          }
          return false;
        }
        strokeContains(x2, y2, strokeWidth) {
          const { width, height } = this;
          if (width <= 0 || height <= 0)
            return false;
          const _x = this.x;
          const _y = this.y;
          const outerLeft = _x - strokeWidth / 2;
          const outerRight = _x + width + strokeWidth / 2;
          const outerTop = _y - strokeWidth / 2;
          const outerBottom = _y + height + strokeWidth / 2;
          const innerLeft = _x + strokeWidth / 2;
          const innerRight = _x + width - strokeWidth / 2;
          const innerTop = _y + strokeWidth / 2;
          const innerBottom = _y + height - strokeWidth / 2;
          return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
        }
        intersects(other, transform2) {
          if (!transform2) {
            const x02 = this.x < other.x ? other.x : this.x;
            const x12 = this.right > other.right ? other.right : this.right;
            if (x12 <= x02) {
              return false;
            }
            const y02 = this.y < other.y ? other.y : this.y;
            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
            return y12 > y02;
          }
          const x0 = this.left;
          const x1 = this.right;
          const y0 = this.top;
          const y1 = this.bottom;
          if (x1 <= x0 || y1 <= y0) {
            return false;
          }
          const lt = tempPoints3[0].set(other.left, other.top);
          const lb = tempPoints3[1].set(other.left, other.bottom);
          const rt = tempPoints3[2].set(other.right, other.top);
          const rb = tempPoints3[3].set(other.right, other.bottom);
          if (rt.x <= lt.x || lb.y <= lt.y) {
            return false;
          }
          const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
          if (s2 === 0) {
            return false;
          }
          transform2.apply(lt, lt);
          transform2.apply(lb, lb);
          transform2.apply(rt, rt);
          transform2.apply(rb, rb);
          if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
            return false;
          }
          const nx = s2 * (lb.y - lt.y);
          const ny = s2 * (lt.x - lb.x);
          const n00 = nx * x0 + ny * y0;
          const n10 = nx * x1 + ny * y0;
          const n01 = nx * x0 + ny * y1;
          const n11 = nx * x1 + ny * y1;
          if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
            return false;
          }
          const mx = s2 * (lt.y - rt.y);
          const my = s2 * (rt.x - lt.x);
          const m00 = mx * x0 + my * y0;
          const m10 = mx * x1 + my * y0;
          const m01 = mx * x0 + my * y1;
          const m11 = mx * x1 + my * y1;
          if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
            return false;
          }
          return true;
        }
        pad(paddingX = 0, paddingY = paddingX) {
          this.x -= paddingX;
          this.y -= paddingY;
          this.width += paddingX * 2;
          this.height += paddingY * 2;
          return this;
        }
        fit(rectangle) {
          const x1 = Math.max(this.x, rectangle.x);
          const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.max(this.y, rectangle.y);
          const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = Math.max(x2 - x1, 0);
          this.y = y1;
          this.height = Math.max(y2 - y1, 0);
          return this;
        }
        ceil(resolution = 1, eps = 1e-3) {
          const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
          const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
          this.x = Math.floor((this.x + eps) * resolution) / resolution;
          this.y = Math.floor((this.y + eps) * resolution) / resolution;
          this.width = x2 - this.x;
          this.height = y2 - this.y;
          return this;
        }
        enlarge(rectangle) {
          const x1 = Math.min(this.x, rectangle.x);
          const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
          const y1 = Math.min(this.y, rectangle.y);
          const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
          this.x = x1;
          this.width = x2 - x1;
          this.y = y1;
          this.height = y2 - y1;
          return this;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle2();
          out2.copyFrom(this);
          return out2;
        }
        toString() {
          return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/Bounds.mjs
  var defaultMatrix, Bounds2;
  var init_Bounds2 = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/Bounds.mjs"() {
      init_Matrix2();
      init_Rectangle2();
      defaultMatrix = new Matrix2();
      Bounds2 = class {
        constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        isEmpty() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }
        get rectangle() {
          if (!this._rectangle) {
            this._rectangle = new Rectangle2();
          }
          const rectangle = this._rectangle;
          if (this.minX > this.maxX || this.minY > this.maxY) {
            rectangle.x = 0;
            rectangle.y = 0;
            rectangle.width = 0;
            rectangle.height = 0;
          } else {
            rectangle.copyFromBounds(this);
          }
          return rectangle;
        }
        clear() {
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;
          this.matrix = defaultMatrix;
          return this;
        }
        set(x0, y0, x1, y1) {
          this.minX = x0;
          this.minY = y0;
          this.maxX = x1;
          this.maxY = y1;
        }
        addFrame(x0, y0, x1, y1, matrix) {
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          let x2 = a2 * x0 + c2 * y0 + tx;
          let y2 = b2 * x0 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y0 + tx;
          y2 = b2 * x1 + d2 * y0 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x0 + c2 * y1 + tx;
          y2 = b2 * x0 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          x2 = a2 * x1 + c2 * y1 + tx;
          y2 = b2 * x1 + d2 * y1 + ty;
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        addRect(rect, matrix) {
          this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
        }
        addBounds(bounds, matrix) {
          this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
        }
        addBoundsMask(mask) {
          this.minX = this.minX > mask.minX ? this.minX : mask.minX;
          this.minY = this.minY > mask.minY ? this.minY : mask.minY;
          this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
          this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
        }
        applyMatrix(matrix) {
          const minX = this.minX;
          const minY = this.minY;
          const maxX = this.maxX;
          const maxY = this.maxY;
          const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
          let x2 = a2 * minX + c2 * minY + tx;
          let y2 = b2 * minX + d2 * minY + ty;
          this.minX = x2;
          this.minY = y2;
          this.maxX = x2;
          this.maxY = y2;
          x2 = a2 * maxX + c2 * minY + tx;
          y2 = b2 * maxX + d2 * minY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * minX + c2 * maxY + tx;
          y2 = b2 * minX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
          x2 = a2 * maxX + c2 * maxY + tx;
          y2 = b2 * maxX + d2 * maxY + ty;
          this.minX = x2 < this.minX ? x2 : this.minX;
          this.minY = y2 < this.minY ? y2 : this.minY;
          this.maxX = x2 > this.maxX ? x2 : this.maxX;
          this.maxY = y2 > this.maxY ? y2 : this.maxY;
        }
        fit(rect) {
          if (this.minX < rect.left)
            this.minX = rect.left;
          if (this.maxX > rect.right)
            this.maxX = rect.right;
          if (this.minY < rect.top)
            this.minY = rect.top;
          if (this.maxY > rect.bottom)
            this.maxY = rect.bottom;
          return this;
        }
        fitBounds(left, right, top, bottom) {
          if (this.minX < left)
            this.minX = left;
          if (this.maxX > right)
            this.maxX = right;
          if (this.minY < top)
            this.minY = top;
          if (this.maxY > bottom)
            this.maxY = bottom;
          return this;
        }
        pad(paddingX, paddingY = paddingX) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
          return this;
        }
        ceil() {
          this.minX = Math.floor(this.minX);
          this.minY = Math.floor(this.minY);
          this.maxX = Math.ceil(this.maxX);
          this.maxY = Math.ceil(this.maxY);
          return this;
        }
        clone() {
          return new Bounds2(this.minX, this.minY, this.maxX, this.maxY);
        }
        scale(x2, y2 = x2) {
          this.minX *= x2;
          this.minY *= y2;
          this.maxX *= x2;
          this.maxY *= y2;
          return this;
        }
        get x() {
          return this.minX;
        }
        set x(value) {
          const width = this.maxX - this.minX;
          this.minX = value;
          this.maxX = value + width;
        }
        get y() {
          return this.minY;
        }
        set y(value) {
          const height = this.maxY - this.minY;
          this.minY = value;
          this.maxY = value + height;
        }
        get width() {
          return this.maxX - this.minX;
        }
        set width(value) {
          this.maxX = this.minX + value;
        }
        get height() {
          return this.maxY - this.minY;
        }
        set height(value) {
          this.maxY = this.minY + value;
        }
        get left() {
          return this.minX;
        }
        get right() {
          return this.maxX;
        }
        get top() {
          return this.minY;
        }
        get bottom() {
          return this.maxY;
        }
        get isPositive() {
          return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
        }
        get isValid() {
          return this.minX + this.minY !== Infinity;
        }
        addVertexData(vertexData, beginOffset, endOffset, matrix) {
          let minX = this.minX;
          let minY = this.minY;
          let maxX = this.maxX;
          let maxY = this.maxY;
          matrix || (matrix = this.matrix);
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
            const localX = vertexData[i2];
            const localY = vertexData[i2 + 1];
            const x2 = a2 * localX + c2 * localY + tx;
            const y2 = b2 * localX + d2 * localY + ty;
            minX = x2 < minX ? x2 : minX;
            minY = y2 < minY ? y2 : minY;
            maxX = x2 > maxX ? x2 : maxX;
            maxY = y2 > maxY ? y2 : maxY;
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        }
        containsPoint(x2, y2) {
          if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
            return true;
          }
          return false;
        }
        toString() {
          return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
  var matrixPool, boundsPool;
  var init_matrixAndBoundsPool = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
      init_Matrix2();
      init_Pool();
      init_Bounds2();
      matrixPool = new Pool(Matrix2);
      boundsPool = new Pool(Bounds2);
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getGlobalBounds.mjs
  function getGlobalBounds(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform;
    let pooledMatrix;
    if (target.parent) {
      if (!skipUpdateTransform) {
        pooledMatrix = matrixPool.get().identity();
        parentTransform = updateTransformBackwards(target, pooledMatrix);
      } else {
        parentTransform = target.parent.worldTransform;
      }
    } else {
      parentTransform = Matrix2.IDENTITY;
    }
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    if (pooledMatrix) {
      matrixPool.return(pooledMatrix);
    }
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (!target.visible || !target.measurable)
      return;
    let worldTransform;
    if (!skipUpdateTransform) {
      target.updateLocalTransform();
      worldTransform = matrixPool.get();
      worldTransform.appendFrom(target.localTransform, parentTransform);
    } else {
      worldTransform = target.worldTransform;
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, worldTransform);
    } else {
      if (target.addBounds) {
        bounds.matrix = worldTransform;
        target.addBounds(bounds);
      }
      for (let i2 = 0; i2 < target.children.length; i2++) {
        _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addBounds?.(bounds);
      }
      parentBounds.addBounds(bounds, Matrix2.IDENTITY);
      boundsPool.return(bounds);
    }
    if (!skipUpdateTransform) {
      matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    const parent = target.parent;
    if (parent) {
      updateTransformBackwards(parent, parentTransform);
      parent.updateLocalTransform();
      parentTransform.append(parent.localTransform);
    }
    return parentTransform;
  }
  var init_getGlobalBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getGlobalBounds.mjs"() {
      init_Matrix2();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/pixi-v8/lib/utils/logging/warn.mjs
  function warn(...args) {
    if (warnCount === maxWarnings)
      return;
    warnCount++;
    if (warnCount === maxWarnings) {
      console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
    } else {
      console.warn("PixiJS Warning: ", ...args);
    }
  }
  var warnCount, maxWarnings;
  var init_warn = __esm({
    "node_modules/pixi-v8/lib/utils/logging/warn.mjs"() {
      "use strict";
      warnCount = 0;
      maxWarnings = 500;
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getLocalBounds.mjs
  function getLocalBounds(target, bounds, relativeMatrix) {
    bounds.clear();
    relativeMatrix || (relativeMatrix = Matrix2.IDENTITY);
    _getLocalBounds(target, bounds, relativeMatrix, target, true);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    return bounds;
  }
  function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
    let relativeTransform;
    if (!isRoot) {
      if (!target.visible || !target.measurable)
        return;
      target.updateLocalTransform();
      const localTransform = target.localTransform;
      relativeTransform = matrixPool.get();
      relativeTransform.appendFrom(localTransform, parentTransform);
    } else {
      relativeTransform = matrixPool.get();
      relativeTransform = parentTransform.copyTo(relativeTransform);
    }
    const parentBounds = bounds;
    const preserveBounds = !!target.effects.length;
    if (preserveBounds) {
      bounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, relativeTransform);
    } else {
      if (target.renderPipeId) {
        bounds.matrix = relativeTransform;
        target.addBounds(bounds);
      }
      const children = target.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        _getLocalBounds(children[i2], bounds, relativeTransform, rootContainer, false);
      }
    }
    if (preserveBounds) {
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        target.effects[i2].addLocalBounds?.(bounds, rootContainer);
      }
      parentBounds.addBounds(bounds, Matrix2.IDENTITY);
      boundsPool.return(bounds);
    }
    matrixPool.return(relativeTransform);
  }
  var init_getLocalBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getLocalBounds.mjs"() {
      init_Matrix2();
      init_matrixAndBoundsPool();
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/checkChildrenDidChange.mjs
  function checkChildrenDidChange(container, previousData) {
    const children = container.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      const uid4 = child.uid;
      const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
      const index = previousData.index;
      if (previousData.data[index] !== uid4 || previousData.data[index + 1] !== didChange) {
        previousData.data[previousData.index] = uid4;
        previousData.data[previousData.index + 1] = didChange;
        previousData.didChange = true;
      }
      previousData.index = index + 2;
      if (child.children.length) {
        checkChildrenDidChange(child, previousData);
      }
    }
    return previousData.didChange;
  }
  var init_checkChildrenDidChange = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/measureMixin.mjs
  var tempMatrix5, measureMixin;
  var init_measureMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/measureMixin.mjs"() {
      init_Matrix2();
      init_Bounds2();
      init_getGlobalBounds();
      init_getLocalBounds();
      init_checkChildrenDidChange();
      tempMatrix5 = new Matrix2();
      measureMixin = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(value, localWidth) {
          const sign2 = Math.sign(this.scale.x) || 1;
          if (localWidth !== 0) {
            this.scale.x = value / localWidth * sign2;
          } else {
            this.scale.x = sign2;
          }
        },
        _setHeight(value, localHeight) {
          const sign2 = Math.sign(this.scale.y) || 1;
          if (localHeight !== 0) {
            this.scale.y = value / localHeight * sign2;
          } else {
            this.scale.y = sign2;
          }
        },
        getLocalBounds() {
          if (!this._localBoundsCacheData) {
            this._localBoundsCacheData = {
              data: [],
              index: 1,
              didChange: false,
              localBounds: new Bounds2()
            };
          }
          const localBoundsCacheData = this._localBoundsCacheData;
          localBoundsCacheData.index = 1;
          localBoundsCacheData.didChange = false;
          if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
            localBoundsCacheData.didChange = true;
            localBoundsCacheData.data[0] = this._didViewChangeTick;
          }
          checkChildrenDidChange(this, localBoundsCacheData);
          if (localBoundsCacheData.didChange) {
            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix5);
          }
          return localBoundsCacheData.localBounds;
        },
        getBounds(skipUpdate, bounds) {
          return getGlobalBounds(this, skipUpdate, bounds || new Bounds2());
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/onRenderMixin.mjs
  var onRenderMixin;
  var init_onRenderMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
      "use strict";
      onRenderMixin = {
        _onRender: null,
        set onRender(func) {
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (!func) {
            if (this._onRender) {
              renderGroup?.removeOnRender(this);
            }
            this._onRender = null;
            return;
          }
          if (!this._onRender) {
            renderGroup?.addOnRender(this);
          }
          this._onRender = func;
        },
        get onRender() {
          return this._onRender;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/sortMixin.mjs
  function sortChildren2(a2, b2) {
    return a2._zIndex - b2._zIndex;
  }
  var sortMixin;
  var init_sortMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/sortMixin.mjs"() {
      "use strict";
      sortMixin = {
        _zIndex: 0,
        sortDirty: false,
        sortableChildren: false,
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(value) {
          if (this._zIndex === value)
            return;
          this._zIndex = value;
          this.depthOfChildModified();
        },
        depthOfChildModified() {
          if (this.parent) {
            this.parent.sortableChildren = true;
            this.parent.sortDirty = true;
          }
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
        },
        sortChildren() {
          if (!this.sortDirty)
            return;
          this.sortDirty = false;
          this.children.sort(sortChildren2);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
  var toLocalGlobalMixin;
  var init_toLocalGlobalMixin = __esm({
    "node_modules/pixi-v8/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
      init_Matrix2();
      init_Point2();
      init_getGlobalBounds();
      toLocalGlobalMixin = {
        getGlobalPosition(point = new Point2(), skipUpdate = false) {
          if (this.parent) {
            this.parent.toGlobal(this._position, point, skipUpdate);
          } else {
            point.x = this._position.x;
            point.y = this._position.y;
          }
          return point;
        },
        toGlobal(position, point, skipUpdate = false) {
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix2());
            globalMatrix.append(this.localTransform);
            return globalMatrix.apply(position, point);
          }
          return this.worldTransform.apply(position, point);
        },
        toLocal(position, from, point, skipUpdate) {
          if (from) {
            position = from.toGlobal(position, point, skipUpdate);
          }
          if (!skipUpdate) {
            this.updateLocalTransform();
            const globalMatrix = updateTransformBackwards(this, new Matrix2());
            globalMatrix.append(this.localTransform);
            return globalMatrix.applyInverse(position, point);
          }
          return this.worldTransform.applyInverse(position, point);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
  var _tick, InstructionSet;
  var init_InstructionSet = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
      init_uid2();
      _tick = 0;
      InstructionSet = class {
        constructor() {
          this.uid = uid2("instructionSet");
          this.instructions = [];
          this.instructionSize = 0;
          this.renderables = [];
          this.tick = 0;
        }
        reset() {
          this.instructionSize = 0;
          this.tick = _tick++;
        }
        add(instruction) {
          this.instructions[this.instructionSize++] = instruction;
        }
        log() {
          this.instructions.length = this.instructionSize;
          console.table(this.instructions, ["type", "action"]);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/RenderGroup.mjs
  var RenderGroup;
  var init_RenderGroup = __esm({
    "node_modules/pixi-v8/lib/scene/container/RenderGroup.mjs"() {
      init_Matrix2();
      init_InstructionSet();
      RenderGroup = class {
        constructor() {
          this.renderPipeId = "renderGroup";
          this.root = null;
          this.canBundle = false;
          this.renderGroupParent = null;
          this.renderGroupChildren = [];
          this.worldTransform = new Matrix2();
          this.worldColorAlpha = 4294967295;
          this.worldColor = 16777215;
          this.worldAlpha = 1;
          this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
          this.updateTick = 0;
          this.childrenRenderablesToUpdate = { list: [], index: 0 };
          this.structureDidChange = true;
          this.instructionSet = new InstructionSet();
          this._onRenderContainers = [];
        }
        init(root) {
          this.root = root;
          if (root._onRender)
            this.addOnRender(root);
          root.didChange = true;
          const children = root.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
        }
        reset() {
          this.renderGroupChildren.length = 0;
          for (const i2 in this.childrenToUpdate) {
            const childrenAtDepth = this.childrenToUpdate[i2];
            childrenAtDepth.list.fill(null);
            childrenAtDepth.index = 0;
          }
          this.childrenRenderablesToUpdate.index = 0;
          this.childrenRenderablesToUpdate.list.fill(null);
          this.root = null;
          this.updateTick = 0;
          this.structureDidChange = true;
          this._onRenderContainers.length = 0;
          this.renderGroupParent = null;
        }
        get localTransform() {
          return this.root.localTransform;
        }
        addRenderGroupChild(renderGroupChild) {
          if (renderGroupChild.renderGroupParent) {
            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
          }
          renderGroupChild.renderGroupParent = this;
          this.renderGroupChildren.push(renderGroupChild);
        }
        _removeRenderGroupChild(renderGroupChild) {
          const index = this.renderGroupChildren.indexOf(renderGroupChild);
          if (index > -1) {
            this.renderGroupChildren.splice(index, 1);
          }
          renderGroupChild.renderGroupParent = null;
        }
        addChild(child) {
          this.structureDidChange = true;
          child.parentRenderGroup = this;
          child.updateTick = -1;
          if (child.parent === this.root) {
            child.relativeRenderGroupDepth = 1;
          } else {
            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
          }
          child.didChange = true;
          this.onChildUpdate(child);
          if (child.renderGroup) {
            this.addRenderGroupChild(child.renderGroup);
            return;
          }
          if (child._onRender)
            this.addOnRender(child);
          const children = child.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
        }
        removeChild(child) {
          this.structureDidChange = true;
          if (child._onRender) {
            if (!child.renderGroup) {
              this.removeOnRender(child);
            }
          }
          child.parentRenderGroup = null;
          if (child.renderGroup) {
            this._removeRenderGroupChild(child.renderGroup);
            return;
          }
          const children = child.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
        }
        removeChildren(children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
        }
        onChildUpdate(child) {
          let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
          if (!childrenToUpdate) {
            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
              index: 0,
              list: []
            };
          }
          childrenToUpdate.list[childrenToUpdate.index++] = child;
        }
        updateRenderable(container) {
          if (container.globalDisplayStatus < 7)
            return;
          container.didViewUpdate = false;
          this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);
        }
        onChildViewUpdate(child) {
          this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
        }
        get isRenderable() {
          return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
        }
        addOnRender(container) {
          this._onRenderContainers.push(container);
        }
        removeOnRender(container) {
          this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
        }
        runOnRender() {
          for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
            this._onRenderContainers[i2]._onRender();
          }
        }
        destroy() {
          this.renderGroupParent = null;
          this.root = null;
          this.childrenRenderablesToUpdate = null;
          this.childrenToUpdate = null;
          this.renderGroupChildren = null;
          this._onRenderContainers = null;
          this.instructionSet = null;
        }
        getChildren(out2 = []) {
          const children = this.root.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            this._getChildren(children[i2], out2);
          }
          return out2;
        }
        _getChildren(container, out2 = []) {
          out2.push(container);
          if (container.renderGroup)
            return out2;
          const children = container.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            this._getChildren(children[i2], out2);
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/assignWithIgnore.mjs
  function assignWithIgnore(target, options, ignore = {}) {
    for (const key in options) {
      if (!ignore[key] && options[key] !== void 0) {
        target[key] = options[key];
      }
    }
  }
  var init_assignWithIgnore = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/assignWithIgnore.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/Container.mjs
  var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container2;
  var init_Container2 = __esm({
    "node_modules/pixi-v8/lib/scene/container/Container.mjs"() {
      init_eventemitter3();
      init_Color2();
      init_cullingMixin();
      init_Matrix2();
      init_const7();
      init_ObservablePoint2();
      init_uid2();
      init_deprecation2();
      init_PoolGroup();
      init_childrenHelperMixin();
      init_effectsMixin();
      init_findMixin();
      init_measureMixin();
      init_onRenderMixin();
      init_sortMixin();
      init_toLocalGlobalMixin();
      init_RenderGroup();
      init_assignWithIgnore();
      defaultSkew = new ObservablePoint2(null);
      defaultPivot = new ObservablePoint2(null);
      defaultScale = new ObservablePoint2(null, 1, 1);
      UPDATE_COLOR = 1;
      UPDATE_BLEND = 2;
      UPDATE_VISIBLE = 4;
      Container2 = class extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.uid = uid2("renderable");
          this._updateFlags = 15;
          this.renderGroup = null;
          this.parentRenderGroup = null;
          this.parentRenderGroupIndex = 0;
          this.didChange = false;
          this.didViewUpdate = false;
          this.relativeRenderGroupDepth = 0;
          this.children = [];
          this.parent = null;
          this.includeInBuild = true;
          this.measurable = true;
          this.isSimple = true;
          this.updateTick = -1;
          this.localTransform = new Matrix2();
          this.relativeGroupTransform = new Matrix2();
          this.groupTransform = this.relativeGroupTransform;
          this.destroyed = false;
          this._position = new ObservablePoint2(this, 0, 0);
          this._scale = defaultScale;
          this._pivot = defaultPivot;
          this._skew = defaultSkew;
          this._cx = 1;
          this._sx = 0;
          this._cy = 0;
          this._sy = 1;
          this._rotation = 0;
          this.localColor = 16777215;
          this.localAlpha = 1;
          this.groupAlpha = 1;
          this.groupColor = 16777215;
          this.groupColorAlpha = 4294967295;
          this.localBlendMode = "inherit";
          this.groupBlendMode = "normal";
          this.localDisplayStatus = 7;
          this.globalDisplayStatus = 7;
          this._didContainerChangeTick = 0;
          this._didViewChangeTick = 0;
          this._didLocalTransformChangeId = -1;
          this.effects = [];
          assignWithIgnore(this, options, {
            children: true,
            parent: true,
            effects: true
          });
          options.children?.forEach((child) => this.addChild(child));
          options.parent?.addChild(this);
        }
        static mixin(source2) {
          Object.defineProperties(Container2.prototype, Object.getOwnPropertyDescriptors(source2));
        }
        set _didChangeId(value) {
          this._didViewChangeTick = value >> 12 & 4095;
          this._didContainerChangeTick = value & 4095;
        }
        get _didChangeId() {
          return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
        }
        addChild(...children) {
          if (!this.allowChildren) {
            deprecation2(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
          }
          if (children.length > 1) {
            for (let i2 = 0; i2 < children.length; i2++) {
              this.addChild(children[i2]);
            }
            return children[0];
          }
          const child = children[0];
          if (child.parent === this) {
            this.children.splice(this.children.indexOf(child), 1);
            this.children.push(child);
            if (this.parentRenderGroup) {
              this.parentRenderGroup.structureDidChange = true;
            }
            return child;
          }
          if (child.parent) {
            child.parent.removeChild(child);
          }
          this.children.push(child);
          if (this.sortableChildren)
            this.sortDirty = true;
          child.parent = this;
          child.didChange = true;
          child.didViewUpdate = false;
          child._updateFlags = 15;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.addChild(child);
          }
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
          this._didViewChangeTick++;
          if (child._zIndex !== 0) {
            child.depthOfChildModified();
          }
          return child;
        }
        removeChild(...children) {
          if (children.length > 1) {
            for (let i2 = 0; i2 < children.length; i2++) {
              this.removeChild(children[i2]);
            }
            return children[0];
          }
          const child = children[0];
          const index = this.children.indexOf(child);
          if (index > -1) {
            this._didViewChangeTick++;
            this.children.splice(index, 1);
            if (this.renderGroup) {
              this.renderGroup.removeChild(child);
            } else if (this.parentRenderGroup) {
              this.parentRenderGroup.removeChild(child);
            }
            child.parent = null;
            this.emit("childRemoved", child, this, index);
            child.emit("removed", this);
          }
          return child;
        }
        _onUpdate(point) {
          if (point) {
            if (point === this._skew) {
              this._updateSkew();
            }
          }
          this._didContainerChangeTick++;
          if (this.didChange)
            return;
          this.didChange = true;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.onChildUpdate(this);
          }
        }
        set isRenderGroup(value) {
          if (!!this.renderGroup === value)
            return;
          if (value) {
            this.enableRenderGroup();
          } else {
            this.disableRenderGroup();
          }
        }
        get isRenderGroup() {
          return !!this.renderGroup;
        }
        enableRenderGroup() {
          if (this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup?.removeChild(this);
          this.renderGroup = BigPool.get(RenderGroup, this);
          this.groupTransform = Matrix2.IDENTITY;
          parentRenderGroup?.addChild(this);
          this._updateIsSimple();
        }
        disableRenderGroup() {
          if (!this.renderGroup)
            return;
          const parentRenderGroup = this.parentRenderGroup;
          parentRenderGroup?.removeChild(this);
          BigPool.return(this.renderGroup);
          this.renderGroup = null;
          this.groupTransform = this.relativeGroupTransform;
          parentRenderGroup?.addChild(this);
          this._updateIsSimple();
        }
        _updateIsSimple() {
          this.isSimple = !this.renderGroup && this.effects.length === 0;
        }
        get worldTransform() {
          this._worldTransform || (this._worldTransform = new Matrix2());
          if (this.renderGroup) {
            this._worldTransform.copyFrom(this.renderGroup.worldTransform);
          } else if (this.parentRenderGroup) {
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
          }
          return this._worldTransform;
        }
        get x() {
          return this._position.x;
        }
        set x(value) {
          this._position.x = value;
        }
        get y() {
          return this._position.y;
        }
        set y(value) {
          this._position.y = value;
        }
        get position() {
          return this._position;
        }
        set position(value) {
          this._position.copyFrom(value);
        }
        get rotation() {
          return this._rotation;
        }
        set rotation(value) {
          if (this._rotation !== value) {
            this._rotation = value;
            this._onUpdate(this._skew);
          }
        }
        get angle() {
          return this.rotation * RAD_TO_DEG2;
        }
        set angle(value) {
          this.rotation = value * DEG_TO_RAD2;
        }
        get pivot() {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint2(this, 0, 0);
          }
          return this._pivot;
        }
        set pivot(value) {
          if (this._pivot === defaultPivot) {
            this._pivot = new ObservablePoint2(this, 0, 0);
          }
          typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
        }
        get skew() {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint2(this, 0, 0);
          }
          return this._skew;
        }
        set skew(value) {
          if (this._skew === defaultSkew) {
            this._skew = new ObservablePoint2(this, 0, 0);
          }
          this._skew.copyFrom(value);
        }
        get scale() {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint2(this, 1, 1);
          }
          return this._scale;
        }
        set scale(value) {
          if (this._scale === defaultScale) {
            this._scale = new ObservablePoint2(this, 0, 0);
          }
          typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
        }
        get width() {
          return Math.abs(this.scale.x * this.getLocalBounds().width);
        }
        set width(value) {
          const localWidth = this.getLocalBounds().width;
          this._setWidth(value, localWidth);
        }
        get height() {
          return Math.abs(this.scale.y * this.getLocalBounds().height);
        }
        set height(value) {
          const localHeight = this.getLocalBounds().height;
          this._setHeight(value, localHeight);
        }
        getSize(out2) {
          if (!out2) {
            out2 = {};
          }
          const bounds = this.getLocalBounds();
          out2.width = Math.abs(this.scale.x * bounds.width);
          out2.height = Math.abs(this.scale.y * bounds.height);
          return out2;
        }
        setSize(value, height) {
          const size = this.getLocalBounds();
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          } else {
            height ?? (height = value);
          }
          value !== void 0 && this._setWidth(value, size.width);
          height !== void 0 && this._setHeight(height, size.height);
        }
        _updateSkew() {
          const rotation = this._rotation;
          const skew = this._skew;
          this._cx = Math.cos(rotation + skew._y);
          this._sx = Math.sin(rotation + skew._y);
          this._cy = -Math.sin(rotation - skew._x);
          this._sy = Math.cos(rotation - skew._x);
        }
        updateTransform(opts) {
          this.position.set(
            typeof opts.x === "number" ? opts.x : this.position.x,
            typeof opts.y === "number" ? opts.y : this.position.y
          );
          this.scale.set(
            typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
            typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
          );
          this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
          this.skew.set(
            typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
            typeof opts.skewY === "number" ? opts.skewY : this.skew.y
          );
          this.pivot.set(
            typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
            typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
          );
          return this;
        }
        setFromMatrix(matrix) {
          matrix.decompose(this);
        }
        updateLocalTransform() {
          const localTransformChangeId = this._didContainerChangeTick;
          if (this._didLocalTransformChangeId === localTransformChangeId)
            return;
          this._didLocalTransformChangeId = localTransformChangeId;
          const lt = this.localTransform;
          const scale = this._scale;
          const pivot = this._pivot;
          const position = this._position;
          const sx = scale._x;
          const sy = scale._y;
          const px = pivot._x;
          const py = pivot._y;
          lt.a = this._cx * sx;
          lt.b = this._sx * sx;
          lt.c = this._cy * sy;
          lt.d = this._sy * sy;
          lt.tx = position._x - (px * lt.a + py * lt.c);
          lt.ty = position._y - (px * lt.b + py * lt.d);
        }
        set alpha(value) {
          if (value === this.localAlpha)
            return;
          this.localAlpha = value;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        get alpha() {
          return this.localAlpha;
        }
        set tint(value) {
          const tempColor = Color2.shared.setValue(value ?? 16777215);
          const bgr = tempColor.toBgrNumber();
          if (bgr === this.localColor)
            return;
          this.localColor = bgr;
          this._updateFlags |= UPDATE_COLOR;
          this._onUpdate();
        }
        get tint() {
          const bgr = this.localColor;
          return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
        }
        set blendMode(value) {
          if (this.localBlendMode === value)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_BLEND;
          this.localBlendMode = value;
          this._onUpdate();
        }
        get blendMode() {
          return this.localBlendMode;
        }
        get visible() {
          return !!(this.localDisplayStatus & 2);
        }
        set visible(value) {
          const valueNumber = value ? 2 : 0;
          if ((this.localDisplayStatus & 2) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 2;
          this._onUpdate();
        }
        get culled() {
          return !(this.localDisplayStatus & 4);
        }
        set culled(value) {
          const valueNumber = value ? 0 : 4;
          if ((this.localDisplayStatus & 4) === valueNumber)
            return;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 4;
          this._onUpdate();
        }
        get renderable() {
          return !!(this.localDisplayStatus & 1);
        }
        set renderable(value) {
          const valueNumber = value ? 1 : 0;
          if ((this.localDisplayStatus & 1) === valueNumber)
            return;
          this._updateFlags |= UPDATE_VISIBLE;
          this.localDisplayStatus ^= 1;
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          this._onUpdate();
        }
        get isRenderable() {
          return this.localDisplayStatus === 7 && this.groupAlpha > 0;
        }
        destroy(options = false) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          const oldChildren = this.removeChildren(0, this.children.length);
          this.removeFromParent();
          this.parent = null;
          this._maskEffect = null;
          this._filterEffect = null;
          this.effects = null;
          this._position = null;
          this._scale = null;
          this._pivot = null;
          this._skew = null;
          this.emit("destroyed", this);
          this.removeAllListeners();
          const destroyChildren = typeof options === "boolean" ? options : options?.children;
          if (destroyChildren) {
            for (let i2 = 0; i2 < oldChildren.length; ++i2) {
              oldChildren[i2].destroy(options);
            }
          }
          this.renderGroup?.destroy();
          this.renderGroup = null;
        }
      };
      Container2.mixin(childrenHelperMixin);
      Container2.mixin(toLocalGlobalMixin);
      Container2.mixin(onRenderMixin);
      Container2.mixin(measureMixin);
      Container2.mixin(effectsMixin);
      Container2.mixin(findMixin);
      Container2.mixin(sortMixin);
      Container2.mixin(cullingMixin);
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedEvent.mjs
  var FederatedEvent2;
  var init_FederatedEvent2 = __esm({
    "node_modules/pixi-v8/lib/events/FederatedEvent.mjs"() {
      init_Point2();
      FederatedEvent2 = class {
        constructor(manager) {
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.composed = false;
          this.defaultPrevented = false;
          this.eventPhase = FederatedEvent2.prototype.NONE;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point2();
          this.page = new Point2();
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        get layerX() {
          return this.layer.x;
        }
        get layerY() {
          return this.layer.y;
        }
        get pageX() {
          return this.page.x;
        }
        get pageY() {
          return this.page.y;
        }
        get data() {
          return this;
        }
        composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
        initEvent(_type, _bubbles, _cancelable) {
          throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
          throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
        }
        preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
            this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
        }
        stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
        }
        stopPropagation() {
          this.propagationStopped = true;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/isMobile.mjs
  var isMobileCall2, isMobile3;
  var init_isMobile3 = __esm({
    "node_modules/pixi-v8/lib/utils/browser/isMobile.mjs"() {
      init_esm();
      isMobileCall2 = isMobile.default ?? isMobile;
      isMobile3 = isMobileCall2(globalThis.navigator);
    }
  });

  // node_modules/pixi-v8/lib/accessibility/AccessibilitySystem.mjs
  var KEY_CODE_TAB2, DIV_TOUCH_SIZE2, DIV_TOUCH_POS_X2, DIV_TOUCH_POS_Y2, DIV_TOUCH_ZINDEX2, DIV_HOOK_SIZE2, DIV_HOOK_POS_X2, DIV_HOOK_POS_Y2, DIV_HOOK_ZINDEX2, AccessibilitySystem;
  var init_AccessibilitySystem = __esm({
    "node_modules/pixi-v8/lib/accessibility/AccessibilitySystem.mjs"() {
      init_FederatedEvent2();
      init_Extensions();
      init_isMobile3();
      init_removeItems2();
      KEY_CODE_TAB2 = 9;
      DIV_TOUCH_SIZE2 = 100;
      DIV_TOUCH_POS_X2 = 0;
      DIV_TOUCH_POS_Y2 = 0;
      DIV_TOUCH_ZINDEX2 = 2;
      DIV_HOOK_SIZE2 = 1;
      DIV_HOOK_POS_X2 = -1e3;
      DIV_HOOK_POS_Y2 = -1e3;
      DIV_HOOK_ZINDEX2 = 2;
      AccessibilitySystem = class {
        constructor(renderer, _mobileInfo = isMobile3) {
          this._mobileInfo = _mobileInfo;
          this.debug = false;
          this._isActive = false;
          this._isMobileAccessibility = false;
          this._pool = [];
          this._renderId = 0;
          this._children = [];
          this._androidUpdateCount = 0;
          this._androidUpdateFrequency = 500;
          this._hookDiv = null;
          if (_mobileInfo.tablet || _mobileInfo.phone) {
            this._createTouchHook();
          }
          const div = document.createElement("div");
          div.style.width = `${DIV_TOUCH_SIZE2}px`;
          div.style.height = `${DIV_TOUCH_SIZE2}px`;
          div.style.position = "absolute";
          div.style.top = `${DIV_TOUCH_POS_X2}px`;
          div.style.left = `${DIV_TOUCH_POS_Y2}px`;
          div.style.zIndex = DIV_TOUCH_ZINDEX2.toString();
          this._div = div;
          this._renderer = renderer;
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onMouseMove = this._onMouseMove.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        get isActive() {
          return this._isActive;
        }
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        get hookDiv() {
          return this._hookDiv;
        }
        _createTouchHook() {
          const hookDiv = document.createElement("button");
          hookDiv.style.width = `${DIV_HOOK_SIZE2}px`;
          hookDiv.style.height = `${DIV_HOOK_SIZE2}px`;
          hookDiv.style.position = "absolute";
          hookDiv.style.top = `${DIV_HOOK_POS_X2}px`;
          hookDiv.style.left = `${DIV_HOOK_POS_Y2}px`;
          hookDiv.style.zIndex = DIV_HOOK_ZINDEX2.toString();
          hookDiv.style.backgroundColor = "#FF0000";
          hookDiv.title = "select to enable accessibility for this content";
          hookDiv.addEventListener("focus", () => {
            this._isMobileAccessibility = true;
            this._activate();
            this._destroyTouchHook();
          });
          document.body.appendChild(hookDiv);
          this._hookDiv = hookDiv;
        }
        _destroyTouchHook() {
          if (!this._hookDiv) {
            return;
          }
          document.body.removeChild(this._hookDiv);
          this._hookDiv = null;
        }
        _activate() {
          if (this._isActive) {
            return;
          }
          this._isActive = true;
          globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.add(this);
          this._renderer.view.canvas.parentNode?.appendChild(this._div);
        }
        _deactivate() {
          if (!this._isActive || this._isMobileAccessibility) {
            return;
          }
          this._isActive = false;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
          this._renderer.runners.postrender.remove(this);
          this._div.parentNode?.removeChild(this._div);
        }
        _updateAccessibleObjects(container) {
          if (!container.visible || !container.accessibleChildren) {
            return;
          }
          if (container.accessible && container.isInteractive()) {
            if (!container._accessibleActive) {
              this._addChild(container);
            }
            container._renderId = this._renderId;
          }
          const children = container.children;
          if (children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              this._updateAccessibleObjects(children[i2]);
            }
          }
        }
        init(options) {
          this.debug = options?.debug ?? this.debug;
          this._renderer.runners.postrender.remove(this);
        }
        postrender() {
          const now = performance.now();
          if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
            return;
          }
          this._androidUpdateCount = now + this._androidUpdateFrequency;
          if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
            return;
          }
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          }
          const { x: x2, y: y2, width, height } = this._renderer.view.canvas.getBoundingClientRect();
          const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
          const sx = width / viewWidth * resolution;
          const sy = height / viewHeight * resolution;
          let div = this._div;
          div.style.left = `${x2}px`;
          div.style.top = `${y2}px`;
          div.style.width = `${viewWidth}px`;
          div.style.height = `${viewHeight}px`;
          for (let i2 = 0; i2 < this._children.length; i2++) {
            const child = this._children[i2];
            if (child._renderId !== this._renderId) {
              child._accessibleActive = false;
              removeItems2(this._children, i2, 1);
              this._div.removeChild(child._accessibleDiv);
              this._pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
              i2--;
            } else {
              div = child._accessibleDiv;
              let hitArea = child.hitArea;
              const wt = child.worldTransform;
              if (child.hitArea) {
                div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
                div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
                div.style.width = `${hitArea.width * wt.a * sx}px`;
                div.style.height = `${hitArea.height * wt.d * sy}px`;
              } else {
                hitArea = child.getBounds().rectangle;
                this._capHitArea(hitArea);
                div.style.left = `${hitArea.x * sx}px`;
                div.style.top = `${hitArea.y * sy}px`;
                div.style.width = `${hitArea.width * sx}px`;
                div.style.height = `${hitArea.height * sy}px`;
                if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                  div.title = child.accessibleTitle || "";
                }
                if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                  div.setAttribute("aria-label", child.accessibleHint || "");
                }
              }
              if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
                div.title = child.accessibleTitle || "";
                div.tabIndex = child.tabIndex;
                if (this.debug) {
                  this._updateDebugHTML(div);
                }
              }
            }
          }
          this._renderId++;
        }
        _updateDebugHTML(div) {
          div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
        }
        _capHitArea(hitArea) {
          if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
          }
          if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
          }
          const { width: viewWidth, height: viewHeight } = this._renderer;
          if (hitArea.x + hitArea.width > viewWidth) {
            hitArea.width = viewWidth - hitArea.x;
          }
          if (hitArea.y + hitArea.height > viewHeight) {
            hitArea.height = viewHeight - hitArea.y;
          }
        }
        _addChild(container) {
          let div = this._pool.pop();
          if (!div) {
            div = document.createElement("button");
            div.style.width = `${DIV_TOUCH_SIZE2}px`;
            div.style.height = `${DIV_TOUCH_SIZE2}px`;
            div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
            div.style.position = "absolute";
            div.style.zIndex = DIV_TOUCH_ZINDEX2.toString();
            div.style.borderStyle = "none";
            if (navigator.userAgent.toLowerCase().includes("chrome")) {
              div.setAttribute("aria-live", "off");
            } else {
              div.setAttribute("aria-live", "polite");
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
              div.setAttribute("aria-relevant", "additions");
            } else {
              div.setAttribute("aria-relevant", "text");
            }
            div.addEventListener("click", this._onClick.bind(this));
            div.addEventListener("focus", this._onFocus.bind(this));
            div.addEventListener("focusout", this._onFocusOut.bind(this));
          }
          div.style.pointerEvents = container.accessiblePointerEvents;
          div.type = container.accessibleType;
          if (container.accessibleTitle && container.accessibleTitle !== null) {
            div.title = container.accessibleTitle;
          } else if (!container.accessibleHint || container.accessibleHint === null) {
            div.title = `container ${container.tabIndex}`;
          }
          if (container.accessibleHint && container.accessibleHint !== null) {
            div.setAttribute("aria-label", container.accessibleHint);
          }
          if (this.debug) {
            this._updateDebugHTML(div);
          }
          container._accessibleActive = true;
          container._accessibleDiv = div;
          div.container = container;
          this._children.push(container);
          this._div.appendChild(container._accessibleDiv);
          container._accessibleDiv.tabIndex = container.tabIndex;
        }
        _dispatchEvent(e2, type) {
          const { container: target } = e2.target;
          const boundary = this._renderer.events.rootBoundary;
          const event = Object.assign(new FederatedEvent2(boundary), { target });
          boundary.rootTarget = this._renderer.lastObjectRendered;
          type.forEach((type2) => boundary.dispatchEvent(event, type2));
        }
        _onClick(e2) {
          this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
        }
        _onFocus(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "assertive");
          }
          this._dispatchEvent(e2, ["mouseover"]);
        }
        _onFocusOut(e2) {
          if (!e2.target.getAttribute("aria-live")) {
            e2.target.setAttribute("aria-live", "polite");
          }
          this._dispatchEvent(e2, ["mouseout"]);
        }
        _onKeyDown(e2) {
          if (e2.keyCode !== KEY_CODE_TAB2) {
            return;
          }
          this._activate();
        }
        _onMouseMove(e2) {
          if (e2.movementX === 0 && e2.movementY === 0) {
            return;
          }
          this._deactivate();
        }
        destroy() {
          this._destroyTouchHook();
          this._div = null;
          globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
          globalThis.removeEventListener("keydown", this._onKeyDown);
          this._pool = null;
          this._children = null;
          this._renderer = null;
        }
      };
      AccessibilitySystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "accessibility"
      };
    }
  });

  // node_modules/pixi-v8/lib/accessibility/accessibilityTarget.mjs
  var accessibilityTarget;
  var init_accessibilityTarget = __esm({
    "node_modules/pixi-v8/lib/accessibility/accessibilityTarget.mjs"() {
      "use strict";
      accessibilityTarget = {
        accessible: false,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        _accessibleActive: false,
        _accessibleDiv: null,
        accessibleType: "button",
        accessiblePointerEvents: "auto",
        accessibleChildren: true,
        _renderId: -1
      };
    }
  });

  // node_modules/pixi-v8/lib/accessibility/init.mjs
  var init_init = __esm({
    "node_modules/pixi-v8/lib/accessibility/init.mjs"() {
      init_Extensions();
      init_Container2();
      init_AccessibilitySystem();
      init_accessibilityTarget();
      extensions3.add(AccessibilitySystem);
      Container2.mixin(accessibilityTarget);
    }
  });

  // node_modules/pixi-v8/lib/app/ResizePlugin.mjs
  var ResizePlugin2;
  var init_ResizePlugin2 = __esm({
    "node_modules/pixi-v8/lib/app/ResizePlugin.mjs"() {
      init_Extensions();
      ResizePlugin2 = class {
        static init(options) {
          Object.defineProperty(
            this,
            "resizeTo",
            {
              set(dom) {
                globalThis.removeEventListener("resize", this.queueResize);
                this._resizeTo = dom;
                if (dom) {
                  globalThis.addEventListener("resize", this.queueResize);
                  this.resize();
                }
              },
              get() {
                return this._resizeTo;
              }
            }
          );
          this.queueResize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            this._resizeId = requestAnimationFrame(() => this.resize());
          };
          this._cancelResize = () => {
            if (this._resizeId) {
              cancelAnimationFrame(this._resizeId);
              this._resizeId = null;
            }
          };
          this.resize = () => {
            if (!this._resizeTo) {
              return;
            }
            this._cancelResize();
            let width;
            let height;
            if (this._resizeTo === globalThis.window) {
              width = globalThis.innerWidth;
              height = globalThis.innerHeight;
            } else {
              const { clientWidth, clientHeight } = this._resizeTo;
              width = clientWidth;
              height = clientHeight;
            }
            this.renderer.resize(width, height);
            this.render();
          };
          this._resizeId = null;
          this._resizeTo = null;
          this.resizeTo = options.resizeTo || null;
        }
        static destroy() {
          globalThis.removeEventListener("resize", this.queueResize);
          this._cancelResize();
          this._cancelResize = null;
          this.queueResize = null;
          this.resizeTo = null;
          this.resize = null;
        }
      };
      ResizePlugin2.extension = ExtensionType2.Application;
    }
  });

  // node_modules/pixi-v8/lib/ticker/const.mjs
  var UPDATE_PRIORITY2;
  var init_const8 = __esm({
    "node_modules/pixi-v8/lib/ticker/const.mjs"() {
      "use strict";
      UPDATE_PRIORITY2 = /* @__PURE__ */ ((UPDATE_PRIORITY22) => {
        UPDATE_PRIORITY22[UPDATE_PRIORITY22["INTERACTION"] = 50] = "INTERACTION";
        UPDATE_PRIORITY22[UPDATE_PRIORITY22["HIGH"] = 25] = "HIGH";
        UPDATE_PRIORITY22[UPDATE_PRIORITY22["NORMAL"] = 0] = "NORMAL";
        UPDATE_PRIORITY22[UPDATE_PRIORITY22["LOW"] = -25] = "LOW";
        UPDATE_PRIORITY22[UPDATE_PRIORITY22["UTILITY"] = -50] = "UTILITY";
        return UPDATE_PRIORITY22;
      })(UPDATE_PRIORITY2 || {});
    }
  });

  // node_modules/pixi-v8/lib/ticker/TickerListener.mjs
  var TickerListener2;
  var init_TickerListener2 = __esm({
    "node_modules/pixi-v8/lib/ticker/TickerListener.mjs"() {
      "use strict";
      TickerListener2 = class {
        constructor(fn, context3 = null, priority = 0, once = false) {
          this.next = null;
          this.previous = null;
          this._destroyed = false;
          this._fn = fn;
          this._context = context3;
          this.priority = priority;
          this._once = once;
        }
        match(fn, context3 = null) {
          return this._fn === fn && this._context === context3;
        }
        emit(ticker) {
          if (this._fn) {
            if (this._context) {
              this._fn.call(this._context, ticker);
            } else {
              this._fn(ticker);
            }
          }
          const redirect = this.next;
          if (this._once) {
            this.destroy(true);
          }
          if (this._destroyed) {
            this.next = null;
          }
          return redirect;
        }
        connect(previous) {
          this.previous = previous;
          if (previous.next) {
            previous.next.previous = this;
          }
          this.next = previous.next;
          previous.next = this;
        }
        destroy(hard = false) {
          this._destroyed = true;
          this._fn = null;
          this._context = null;
          if (this.previous) {
            this.previous.next = this.next;
          }
          if (this.next) {
            this.next.previous = this.previous;
          }
          const redirect = this.next;
          this.next = hard ? null : redirect;
          this.previous = null;
          return redirect;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/ticker/Ticker.mjs
  var _Ticker3, Ticker2;
  var init_Ticker2 = __esm({
    "node_modules/pixi-v8/lib/ticker/Ticker.mjs"() {
      init_const8();
      init_TickerListener2();
      _Ticker3 = class _Ticker4 {
        constructor() {
          this.autoStart = false;
          this.deltaTime = 1;
          this.lastTime = -1;
          this.speed = 1;
          this.started = false;
          this._requestId = null;
          this._maxElapsedMS = 100;
          this._minElapsedMS = 0;
          this._protected = false;
          this._lastFrame = -1;
          this._head = new TickerListener2(null, null, Infinity);
          this.deltaMS = 1 / _Ticker4.targetFPMS;
          this.elapsedMS = 1 / _Ticker4.targetFPMS;
          this._tick = (time) => {
            this._requestId = null;
            if (this.started) {
              this.update(time);
              if (this.started && this._requestId === null && this._head.next) {
                this._requestId = requestAnimationFrame(this._tick);
              }
            }
          };
        }
        _requestIfNeeded() {
          if (this._requestId === null && this._head.next) {
            this.lastTime = performance.now();
            this._lastFrame = this.lastTime;
            this._requestId = requestAnimationFrame(this._tick);
          }
        }
        _cancelIfNeeded() {
          if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
          }
        }
        _startIfPossible() {
          if (this.started) {
            this._requestIfNeeded();
          } else if (this.autoStart) {
            this.start();
          }
        }
        add(fn, context3, priority = UPDATE_PRIORITY2.NORMAL) {
          return this._addListener(new TickerListener2(fn, context3, priority));
        }
        addOnce(fn, context3, priority = UPDATE_PRIORITY2.NORMAL) {
          return this._addListener(new TickerListener2(fn, context3, priority, true));
        }
        _addListener(listener) {
          let current = this._head.next;
          let previous = this._head;
          if (!current) {
            listener.connect(previous);
          } else {
            while (current) {
              if (listener.priority > current.priority) {
                listener.connect(previous);
                break;
              }
              previous = current;
              current = current.next;
            }
            if (!listener.previous) {
              listener.connect(previous);
            }
          }
          this._startIfPossible();
          return this;
        }
        remove(fn, context3) {
          let listener = this._head.next;
          while (listener) {
            if (listener.match(fn, context3)) {
              listener = listener.destroy();
            } else {
              listener = listener.next;
            }
          }
          if (!this._head.next) {
            this._cancelIfNeeded();
          }
          return this;
        }
        get count() {
          if (!this._head) {
            return 0;
          }
          let count2 = 0;
          let current = this._head;
          while (current = current.next) {
            count2++;
          }
          return count2;
        }
        start() {
          if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
          }
        }
        stop() {
          if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
          }
        }
        destroy() {
          if (!this._protected) {
            this.stop();
            let listener = this._head.next;
            while (listener) {
              listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
          }
        }
        update(currentTime = performance.now()) {
          let elapsedMS;
          if (currentTime > this.lastTime) {
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            if (elapsedMS > this._maxElapsedMS) {
              elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            if (this._minElapsedMS) {
              const delta = currentTime - this._lastFrame | 0;
              if (delta < this._minElapsedMS) {
                return;
              }
              this._lastFrame = currentTime - delta % this._minElapsedMS;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * _Ticker4.targetFPMS;
            const head = this._head;
            let listener = head.next;
            while (listener) {
              listener = listener.emit(this);
            }
            if (!head.next) {
              this._cancelIfNeeded();
            }
          } else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          }
          this.lastTime = currentTime;
        }
        get FPS() {
          return 1e3 / this.elapsedMS;
        }
        get minFPS() {
          return 1e3 / this._maxElapsedMS;
        }
        set minFPS(fps) {
          const minFPS = Math.min(this.maxFPS, fps);
          const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker4.targetFPMS);
          this._maxElapsedMS = 1 / minFPMS;
        }
        get maxFPS() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        }
        set maxFPS(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            const maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        }
        static get shared() {
          if (!_Ticker4._shared) {
            const shared = _Ticker4._shared = new _Ticker4();
            shared.autoStart = true;
            shared._protected = true;
          }
          return _Ticker4._shared;
        }
        static get system() {
          if (!_Ticker4._system) {
            const system = _Ticker4._system = new _Ticker4();
            system.autoStart = true;
            system._protected = true;
          }
          return _Ticker4._system;
        }
      };
      _Ticker3.targetFPMS = 0.06;
      Ticker2 = _Ticker3;
    }
  });

  // node_modules/pixi-v8/lib/app/TickerPlugin.mjs
  var TickerPlugin2;
  var init_TickerPlugin2 = __esm({
    "node_modules/pixi-v8/lib/app/TickerPlugin.mjs"() {
      init_Extensions();
      init_const8();
      init_Ticker2();
      TickerPlugin2 = class {
        static init(options) {
          options = Object.assign({
            autoStart: true,
            sharedTicker: false
          }, options);
          Object.defineProperty(
            this,
            "ticker",
            {
              set(ticker) {
                if (this._ticker) {
                  this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                  ticker.add(this.render, this, UPDATE_PRIORITY2.LOW);
                }
              },
              get() {
                return this._ticker;
              }
            }
          );
          this.stop = () => {
            this._ticker.stop();
          };
          this.start = () => {
            this._ticker.start();
          };
          this._ticker = null;
          this.ticker = options.sharedTicker ? Ticker2.shared : new Ticker2();
          if (options.autoStart) {
            this.start();
          }
        }
        static destroy() {
          if (this._ticker) {
            const oldTicker = this._ticker;
            this.ticker = null;
            oldTicker.destroy();
          }
        }
      };
      TickerPlugin2.extension = ExtensionType2.Application;
    }
  });

  // node_modules/pixi-v8/lib/app/init.mjs
  var init_init2 = __esm({
    "node_modules/pixi-v8/lib/app/init.mjs"() {
      init_Extensions();
      init_ResizePlugin2();
      init_TickerPlugin2();
      extensions3.add(ResizePlugin2);
      extensions3.add(TickerPlugin2);
    }
  });

  // node_modules/pixi-v8/lib/events/EventTicker.mjs
  var EventsTickerClass2, EventsTicker2;
  var init_EventTicker2 = __esm({
    "node_modules/pixi-v8/lib/events/EventTicker.mjs"() {
      init_const8();
      init_Ticker2();
      EventsTickerClass2 = class {
        constructor() {
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        init(events) {
          this.removeTickerListener();
          this.events = events;
          this.interactionFrequency = 10;
          this._deltaTime = 0;
          this._didMove = false;
          this._tickerAdded = false;
          this._pauseUpdate = true;
        }
        get pauseUpdate() {
          return this._pauseUpdate;
        }
        set pauseUpdate(paused) {
          this._pauseUpdate = paused;
        }
        addTickerListener() {
          if (this._tickerAdded || !this.domElement) {
            return;
          }
          Ticker2.system.add(this._tickerUpdate, this, UPDATE_PRIORITY2.INTERACTION);
          this._tickerAdded = true;
        }
        removeTickerListener() {
          if (!this._tickerAdded) {
            return;
          }
          Ticker2.system.remove(this._tickerUpdate, this);
          this._tickerAdded = false;
        }
        pointerMoved() {
          this._didMove = true;
        }
        _update() {
          if (!this.domElement || this._pauseUpdate) {
            return;
          }
          if (this._didMove) {
            this._didMove = false;
            return;
          }
          const rootPointerEvent = this.events["_rootPointerEvent"];
          if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
            return;
          }
          globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: rootPointerEvent.clientX,
            clientY: rootPointerEvent.clientY,
            pointerType: rootPointerEvent.pointerType,
            pointerId: rootPointerEvent.pointerId
          }));
        }
        _tickerUpdate(ticker) {
          this._deltaTime += ticker.deltaTime;
          if (this._deltaTime < this.interactionFrequency) {
            return;
          }
          this._deltaTime = 0;
          this._update();
        }
      };
      EventsTicker2 = new EventsTickerClass2();
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedMouseEvent.mjs
  var FederatedMouseEvent2;
  var init_FederatedMouseEvent2 = __esm({
    "node_modules/pixi-v8/lib/events/FederatedMouseEvent.mjs"() {
      init_Point2();
      init_FederatedEvent2();
      FederatedMouseEvent2 = class extends FederatedEvent2 {
        constructor() {
          super(...arguments);
          this.client = new Point2();
          this.movement = new Point2();
          this.offset = new Point2();
          this.global = new Point2();
          this.screen = new Point2();
        }
        get clientX() {
          return this.client.x;
        }
        get clientY() {
          return this.client.y;
        }
        get x() {
          return this.clientX;
        }
        get y() {
          return this.clientY;
        }
        get movementX() {
          return this.movement.x;
        }
        get movementY() {
          return this.movement.y;
        }
        get offsetX() {
          return this.offset.x;
        }
        get offsetY() {
          return this.offset.y;
        }
        get globalX() {
          return this.global.x;
        }
        get globalY() {
          return this.global.y;
        }
        get screenX() {
          return this.screen.x;
        }
        get screenY() {
          return this.screen.y;
        }
        getLocalPosition(container, point, globalPos) {
          return container.worldTransform.applyInverse(globalPos || this.global, point);
        }
        getModifierState(key) {
          return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
        }
        initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error("Method not implemented.");
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedPointerEvent.mjs
  var FederatedPointerEvent2;
  var init_FederatedPointerEvent2 = __esm({
    "node_modules/pixi-v8/lib/events/FederatedPointerEvent.mjs"() {
      init_FederatedMouseEvent2();
      FederatedPointerEvent2 = class extends FederatedMouseEvent2 {
        constructor() {
          super(...arguments);
          this.width = 0;
          this.height = 0;
          this.isPrimary = false;
        }
        getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
        getPredictedEvents() {
          throw new Error("getPredictedEvents is not supported!");
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedWheelEvent.mjs
  var FederatedWheelEvent2;
  var init_FederatedWheelEvent2 = __esm({
    "node_modules/pixi-v8/lib/events/FederatedWheelEvent.mjs"() {
      init_FederatedMouseEvent2();
      FederatedWheelEvent2 = class extends FederatedMouseEvent2 {
        constructor() {
          super(...arguments);
          this.DOM_DELTA_PIXEL = 0;
          this.DOM_DELTA_LINE = 1;
          this.DOM_DELTA_PAGE = 2;
        }
      };
      FederatedWheelEvent2.DOM_DELTA_PIXEL = 0;
      FederatedWheelEvent2.DOM_DELTA_LINE = 1;
      FederatedWheelEvent2.DOM_DELTA_PAGE = 2;
    }
  });

  // node_modules/pixi-v8/lib/events/EventBoundary.mjs
  var PROPAGATION_LIMIT2, tempHitLocation2, tempLocalMapping2, EventBoundary2;
  var init_EventBoundary2 = __esm({
    "node_modules/pixi-v8/lib/events/EventBoundary.mjs"() {
      init_eventemitter3();
      init_Point2();
      init_warn();
      init_EventTicker2();
      init_FederatedMouseEvent2();
      init_FederatedPointerEvent2();
      init_FederatedWheelEvent2();
      PROPAGATION_LIMIT2 = 2048;
      tempHitLocation2 = new Point2();
      tempLocalMapping2 = new Point2();
      EventBoundary2 = class {
        constructor(rootTarget) {
          this.dispatch = new eventemitter3_default();
          this.moveOnAll = false;
          this.enableGlobalMoveEvents = true;
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this._allInteractiveElements = [];
          this._hitElements = [];
          this._isPointerMoveEvent = false;
          this.rootTarget = rootTarget;
          this.hitPruneFn = this.hitPruneFn.bind(this);
          this.hitTestFn = this.hitTestFn.bind(this);
          this.mapPointerDown = this.mapPointerDown.bind(this);
          this.mapPointerMove = this.mapPointerMove.bind(this);
          this.mapPointerOut = this.mapPointerOut.bind(this);
          this.mapPointerOver = this.mapPointerOver.bind(this);
          this.mapPointerUp = this.mapPointerUp.bind(this);
          this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
          this.mapWheel = this.mapWheel.bind(this);
          this.mappingTable = {};
          this.addEventMapping("pointerdown", this.mapPointerDown);
          this.addEventMapping("pointermove", this.mapPointerMove);
          this.addEventMapping("pointerout", this.mapPointerOut);
          this.addEventMapping("pointerleave", this.mapPointerOut);
          this.addEventMapping("pointerover", this.mapPointerOver);
          this.addEventMapping("pointerup", this.mapPointerUp);
          this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
          this.addEventMapping("wheel", this.mapWheel);
        }
        addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
            fn,
            priority: 0
          });
          this.mappingTable[type].sort((a2, b2) => a2.priority - b2.priority);
        }
        dispatchEvent(e2, type) {
          e2.propagationStopped = false;
          e2.propagationImmediatelyStopped = false;
          this.propagate(e2, type);
          this.dispatch.emit(type || e2.type, e2);
        }
        mapEvent(e2) {
          if (!this.rootTarget) {
            return;
          }
          const mappers = this.mappingTable[e2.type];
          if (mappers) {
            for (let i2 = 0, j2 = mappers.length; i2 < j2; i2++) {
              mappers[i2].fn(e2);
            }
          } else {
            warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
          }
        }
        hitTest(x2, y2) {
          EventsTicker2.pauseUpdate = true;
          const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
          const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
          const invertedPath = this[fn](
            this.rootTarget,
            this.rootTarget.eventMode,
            tempHitLocation2.set(x2, y2),
            this.hitTestFn,
            this.hitPruneFn
          );
          return invertedPath && invertedPath[0];
        }
        propagate(e2, type) {
          if (!e2.target) {
            return;
          }
          const composedPath = e2.composedPath();
          e2.eventPhase = e2.CAPTURING_PHASE;
          for (let i2 = 0, j2 = composedPath.length - 1; i2 < j2; i2++) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
          e2.eventPhase = e2.AT_TARGET;
          e2.currentTarget = e2.target;
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
            e2.currentTarget = composedPath[i2];
            this.notifyTarget(e2, type);
            if (e2.propagationStopped || e2.propagationImmediatelyStopped)
              return;
          }
        }
        all(e2, type, targets = this._allInteractiveElements) {
          if (targets.length === 0)
            return;
          e2.eventPhase = e2.BUBBLING_PHASE;
          const events = Array.isArray(type) ? type : [type];
          for (let i2 = targets.length - 1; i2 >= 0; i2--) {
            events.forEach((event) => {
              e2.currentTarget = targets[i2];
              this.notifyTarget(e2, event);
            });
          }
        }
        propagationPath(target) {
          const propagationPath = [target];
          for (let i2 = 0; i2 < PROPAGATION_LIMIT2 && (target !== this.rootTarget && target.parent); i2++) {
            if (!target.parent) {
              throw new Error("Cannot find propagation path to disconnected target");
            }
            propagationPath.push(target.parent);
            target = target.parent;
          }
          propagationPath.reverse();
          return propagationPath;
        }
        hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
          let shouldReturn = false;
          if (this._interactivePrune(currentTarget))
            return null;
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker2.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              const child = children[i2];
              const nestedHit = this.hitTestMoveRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                location,
                testFn,
                pruneFn,
                ignore || pruneFn(currentTarget, location)
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive) {
                  if (isInteractive)
                    this._allInteractiveElements.push(currentTarget);
                  nestedHit.push(currentTarget);
                }
                if (this._hitElements.length === 0)
                  this._hitElements = nestedHit;
                shouldReturn = true;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveTarget && isInteractiveTarget)
            this._allInteractiveElements.push(currentTarget);
          if (ignore || this._hitElements.length > 0)
            return null;
          if (shouldReturn)
            return this._hitElements;
          if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
          if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
            return null;
          }
          if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
            EventsTicker2.pauseUpdate = false;
          }
          if (currentTarget.interactiveChildren && currentTarget.children) {
            const children = currentTarget.children;
            const relativeLocation = location;
            for (let i2 = children.length - 1; i2 >= 0; i2--) {
              const child = children[i2];
              const nestedHit = this.hitTestRecursive(
                child,
                this._isInteractive(eventMode) ? eventMode : child.eventMode,
                relativeLocation,
                testFn,
                pruneFn
              );
              if (nestedHit) {
                if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                  continue;
                }
                const isInteractive = currentTarget.isInteractive();
                if (nestedHit.length > 0 || isInteractive)
                  nestedHit.push(currentTarget);
                return nestedHit;
              }
            }
          }
          const isInteractiveMode = this._isInteractive(eventMode);
          const isInteractiveTarget = currentTarget.isInteractive();
          if (isInteractiveMode && testFn(currentTarget, location)) {
            return isInteractiveTarget ? [currentTarget] : [];
          }
          return null;
        }
        _isInteractive(int) {
          return int === "static" || int === "dynamic";
        }
        _interactivePrune(container) {
          if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable) {
            return true;
          }
          if (container.eventMode === "none") {
            return true;
          }
          if (container.eventMode === "passive" && !container.interactiveChildren) {
            return true;
          }
          return false;
        }
        hitPruneFn(container, location) {
          if (container.hitArea) {
            container.worldTransform.applyInverse(location, tempLocalMapping2);
            if (!container.hitArea.contains(tempLocalMapping2.x, tempLocalMapping2.y)) {
              return true;
            }
          }
          if (container.effects && container.effects.length) {
            for (let i2 = 0; i2 < container.effects.length; i2++) {
              const effect = container.effects[i2];
              if (effect.containsPoint) {
                const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
                if (!effectContainsPoint) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        hitTestFn(container, location) {
          if (container.hitArea) {
            return true;
          }
          if (container?.containsPoint) {
            container.worldTransform.applyInverse(location, tempLocalMapping2);
            return container.containsPoint(tempLocalMapping2);
          }
          return false;
        }
        notifyTarget(e2, type) {
          if (!e2.currentTarget.isInteractive()) {
            return;
          }
          type = type ?? e2.type;
          const handlerKey = `on${type}`;
          e2.currentTarget[handlerKey]?.(e2);
          const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
          this._notifyListeners(e2, key);
          if (e2.eventPhase === e2.AT_TARGET) {
            this._notifyListeners(e2, type);
          }
        }
        mapPointerDown(from) {
          if (!(from instanceof FederatedPointerEvent2)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerdown");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchstart");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
          }
          const trackingData = this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e2.composedPath();
          this.freeEvent(e2);
        }
        mapPointerMove(from) {
          if (!(from instanceof FederatedPointerEvent2)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          this._isPointerMoveEvent = true;
          const e2 = this.createPointerEvent(from);
          this._isPointerMoveEvent = false;
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          const trackingData = this.trackingData(from.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
            const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            const outEvent = this.createPointerEvent(from, outType, outTarget);
            this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            if (!e2.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                this.notifyTarget(leaveEvent);
                if (isMouse)
                  this.notifyTarget(leaveEvent, "mouseleave");
                leaveEvent.target = leaveEvent.target.parent;
              }
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e2.target) {
            const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            const overEvent = this.clonePointerEvent(e2, overType);
            this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = outTarget?.parent;
            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
              if (overTargetAncestor === e2.target)
                break;
              overTargetAncestor = overTargetAncestor.parent;
            }
            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
            if (didPointerEnter) {
              const enterEvent = this.clonePointerEvent(e2, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse)
                  this.notifyTarget(enterEvent, "mouseenter");
                enterEvent.target = enterEvent.target.parent;
              }
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          const allMethods = [];
          const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
          this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
          allowGlobalPointerEvents && allMethods.push("globalpointermove");
          if (e2.pointerType === "touch") {
            this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
            allowGlobalPointerEvents && allMethods.push("globaltouchmove");
          }
          if (isMouse) {
            this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
            allowGlobalPointerEvents && allMethods.push("globalmousemove");
            this.cursor = e2.target?.cursor;
          }
          if (allMethods.length > 0) {
            this.all(e2, allMethods);
          }
          this._allInteractiveElements.length = 0;
          this._hitElements.length = 0;
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
        }
        mapPointerOver(from) {
          if (!(from instanceof FederatedPointerEvent2)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const e2 = this.createPointerEvent(from);
          const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
          this.dispatchEvent(e2, "pointerover");
          if (isMouse)
            this.dispatchEvent(e2, "mouseover");
          if (e2.pointerType === "mouse")
            this.cursor = e2.target?.cursor;
          const enterEvent = this.clonePointerEvent(e2, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
            enterEvent.currentTarget = enterEvent.target;
            this.notifyTarget(enterEvent);
            if (isMouse)
              this.notifyTarget(enterEvent, "mouseenter");
            enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e2.composedPath();
          this.freeEvent(e2);
          this.freeEvent(enterEvent);
        }
        mapPointerOut(from) {
          if (!(from instanceof FederatedPointerEvent2)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
            this.dispatchEvent(outEvent);
            if (isMouse)
              this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            trackingData.overTargets = null;
            this.freeEvent(outEvent);
            this.freeEvent(leaveEvent);
          }
          this.cursor = null;
        }
        mapPointerUp(from) {
          if (!(from instanceof FederatedPointerEvent2)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const now = performance.now();
          const e2 = this.createPointerEvent(from);
          this.dispatchEvent(e2, "pointerup");
          if (e2.pointerType === "touch") {
            this.dispatchEvent(e2, "touchend");
          } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
            const isRightButton = e2.button === 2;
            this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e2.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            while (currentTarget && !e2.composedPath().includes(currentTarget)) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                const isRightButton = e2.button === 2;
                this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e2, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = null;
            if (!trackingData.clicksByButton[from.button]) {
              trackingData.clicksByButton[from.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now
              };
            }
            const clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now;
            clickEvent.detail = clickHistory.clickCount;
            if (clickEvent.pointerType === "mouse") {
              const isRightButton = clickEvent.button === 2;
              this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
            } else if (clickEvent.pointerType === "touch") {
              this.dispatchEvent(clickEvent, "tap");
            }
            this.dispatchEvent(clickEvent, "pointertap");
            this.freeEvent(clickEvent);
          }
          this.freeEvent(e2);
        }
        mapPointerUpOutside(from) {
          if (!(from instanceof FederatedPointerEvent2)) {
            warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          const e2 = this.createPointerEvent(from);
          if (pressTarget) {
            let currentTarget = pressTarget;
            while (currentTarget) {
              e2.currentTarget = currentTarget;
              this.notifyTarget(e2, "pointerupoutside");
              if (e2.pointerType === "touch") {
                this.notifyTarget(e2, "touchendoutside");
              } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
                this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e2);
        }
        mapWheel(from) {
          if (!(from instanceof FederatedWheelEvent2)) {
            warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return;
          }
          const wheelEvent = this.createWheelEvent(from);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
        }
        findMountedTarget(propagationPath) {
          if (!propagationPath) {
            return null;
          }
          let currentTarget = propagationPath[0];
          for (let i2 = 1; i2 < propagationPath.length; i2++) {
            if (propagationPath[i2].parent === currentTarget) {
              currentTarget = propagationPath[i2];
            } else {
              break;
            }
          }
          return currentTarget;
        }
        createPointerEvent(from, type, target) {
          const event = this.allocateEvent(FederatedPointerEvent2);
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
          if (typeof type === "string") {
            event.type = type;
          }
          return event;
        }
        createWheelEvent(from) {
          const event = this.allocateEvent(FederatedWheelEvent2);
          this.copyWheelData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = this.hitTest(event.global.x, event.global.y);
          return event;
        }
        clonePointerEvent(from, type) {
          const event = this.allocateEvent(FederatedPointerEvent2);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from.originalEvent;
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.target = from.target;
          event.path = from.composedPath().slice();
          event.type = type ?? event.type;
          return event;
        }
        copyWheelData(from, to) {
          to.deltaMode = from.deltaMode;
          to.deltaX = from.deltaX;
          to.deltaY = from.deltaY;
          to.deltaZ = from.deltaZ;
        }
        copyPointerData(from, to) {
          if (!(from instanceof FederatedPointerEvent2 && to instanceof FederatedPointerEvent2))
            return;
          to.pointerId = from.pointerId;
          to.width = from.width;
          to.height = from.height;
          to.isPrimary = from.isPrimary;
          to.pointerType = from.pointerType;
          to.pressure = from.pressure;
          to.tangentialPressure = from.tangentialPressure;
          to.tiltX = from.tiltX;
          to.tiltY = from.tiltY;
          to.twist = from.twist;
        }
        copyMouseData(from, to) {
          if (!(from instanceof FederatedMouseEvent2 && to instanceof FederatedMouseEvent2))
            return;
          to.altKey = from.altKey;
          to.button = from.button;
          to.buttons = from.buttons;
          to.client.copyFrom(from.client);
          to.ctrlKey = from.ctrlKey;
          to.metaKey = from.metaKey;
          to.movement.copyFrom(from.movement);
          to.screen.copyFrom(from.screen);
          to.shiftKey = from.shiftKey;
          to.global.copyFrom(from.global);
        }
        copyData(from, to) {
          to.isTrusted = from.isTrusted;
          to.srcElement = from.srcElement;
          to.timeStamp = performance.now();
          to.type = from.type;
          to.detail = from.detail;
          to.view = from.view;
          to.which = from.which;
          to.layer.copyFrom(from.layer);
          to.page.copyFrom(from.page);
        }
        trackingData(id) {
          if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            };
          }
          return this.mappingState.trackingData[id];
        }
        allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor).pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.path = null;
          event.target = null;
          return event;
        }
        freeEvent(event) {
          if (event.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor).push(event);
        }
        _notifyListeners(e2, type) {
          const listeners = e2.currentTarget._events[type];
          if (!listeners)
            return;
          if ("fn" in listeners) {
            if (listeners.once)
              e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
            listeners.fn.call(listeners.context, e2);
          } else {
            for (let i2 = 0, j2 = listeners.length; i2 < j2 && !e2.propagationImmediatelyStopped; i2++) {
              if (listeners[i2].once)
                e2.currentTarget.removeListener(type, listeners[i2].fn, void 0, true);
              listeners[i2].fn.call(listeners[i2].context, e2);
            }
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/EventSystem.mjs
  var MOUSE_POINTER_ID2, TOUCH_TO_POINTER2, _EventSystem3, EventSystem2;
  var init_EventSystem2 = __esm({
    "node_modules/pixi-v8/lib/events/EventSystem.mjs"() {
      init_Extensions();
      init_EventBoundary2();
      init_EventTicker2();
      init_FederatedPointerEvent2();
      init_FederatedWheelEvent2();
      MOUSE_POINTER_ID2 = 1;
      TOUCH_TO_POINTER2 = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      _EventSystem3 = class _EventSystem4 {
        constructor(renderer) {
          this.supportsTouchEvents = "ontouchstart" in globalThis;
          this.supportsPointerEvents = !!globalThis.PointerEvent;
          this.domElement = null;
          this.resolution = 1;
          this.renderer = renderer;
          this.rootBoundary = new EventBoundary2(null);
          EventsTicker2.init(this);
          this.autoPreventDefault = true;
          this._eventsAdded = false;
          this._rootPointerEvent = new FederatedPointerEvent2(null);
          this._rootWheelEvent = new FederatedWheelEvent2(null);
          this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
          };
          this.features = new Proxy({ ..._EventSystem4.defaultEventFeatures }, {
            set: (target, key, value) => {
              if (key === "globalMove") {
                this.rootBoundary.enableGlobalMoveEvents = value;
              }
              target[key] = value;
              return true;
            }
          });
          this._onPointerDown = this._onPointerDown.bind(this);
          this._onPointerMove = this._onPointerMove.bind(this);
          this._onPointerUp = this._onPointerUp.bind(this);
          this._onPointerOverOut = this._onPointerOverOut.bind(this);
          this.onWheel = this.onWheel.bind(this);
        }
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        init(options) {
          const { canvas, resolution } = this.renderer;
          this.setTargetElement(canvas);
          this.resolution = resolution;
          _EventSystem4._defaultEventMode = options.eventMode ?? "passive";
          Object.assign(this.features, options.eventFeatures ?? {});
          this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
        }
        resolutionChange(resolution) {
          this.resolution = resolution;
        }
        destroy() {
          this.setTargetElement(null);
          this.renderer = null;
          this._currentCursor = null;
        }
        setCursor(mode) {
          mode = mode || "default";
          let applyStyles = true;
          if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
            applyStyles = false;
          }
          if (this._currentCursor === mode) {
            return;
          }
          this._currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style) {
            switch (typeof style) {
              case "string":
                if (applyStyles) {
                  this.domElement.style.cursor = style;
                }
                break;
              case "function":
                style(mode);
                break;
              case "object":
                if (applyStyles) {
                  Object.assign(this.domElement.style, style);
                }
                break;
            }
          } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.domElement.style.cursor = mode;
          }
        }
        get pointer() {
          return this._rootPointerEvent;
        }
        _onPointerDown(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const events = this._normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          for (let i2 = 0, j2 = events.length; i2 < j2; i2++) {
            const nativeEvent2 = events[i2];
            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
            this.rootBoundary.mapEvent(federatedEvent);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerMove(nativeEvent) {
          if (!this.features.move)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          EventsTicker2.pointerMoved();
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerUp(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let target = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
          }
          const outside = target !== this.domElement ? "outside" : "";
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            event.type += outside;
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerOverOut(nativeEvent) {
          if (!this.features.click)
            return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const normalizedEvents = this._normalizeToPointerData(nativeEvent);
          for (let i2 = 0, j2 = normalizedEvents.length; i2 < j2; i2++) {
            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
            this.rootBoundary.mapEvent(event);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onWheel(nativeEvent) {
          if (!this.features.wheel)
            return;
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          this.rootBoundary.mapEvent(wheelEvent);
        }
        setTargetElement(element) {
          this._removeEvents();
          this.domElement = element;
          EventsTicker2.domElement = element;
          this._addEvents();
        }
        _addEvents() {
          if (this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker2.addTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "none";
              style.msTouchAction = "none";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "none";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
            this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.addEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
            this.domElement.addEventListener("mousedown", this._onPointerDown, true);
            this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.addEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.addEventListener("touchstart", this._onPointerDown, true);
              this.domElement.addEventListener("touchend", this._onPointerUp, true);
              this.domElement.addEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: true,
            capture: true
          });
          this._eventsAdded = true;
        }
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) {
            return;
          }
          EventsTicker2.removeTickerListener();
          const style = this.domElement.style;
          if (style) {
            if (globalThis.navigator.msPointerEnabled) {
              style.msContentZooming = "";
              style.msTouchAction = "";
            } else if (this.supportsPointerEvents) {
              style.touchAction = "";
            }
          }
          if (this.supportsPointerEvents) {
            globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
            this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
            this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
            this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
            globalThis.removeEventListener("pointerup", this._onPointerUp, true);
          } else {
            globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
            this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
            this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
            this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
            globalThis.removeEventListener("mouseup", this._onPointerUp, true);
            if (this.supportsTouchEvents) {
              this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
              this.domElement.removeEventListener("touchend", this._onPointerUp, true);
              this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
            }
          }
          this.domElement.removeEventListener("wheel", this.onWheel, true);
          this.domElement = null;
          this._eventsAdded = false;
        }
        mapPositionToPoint(point, x2, y2) {
          const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
          };
          const resolutionMultiplier = 1 / this.resolution;
          point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
          point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
        }
        _normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
              const touch = event.changedTouches[i2];
              if (typeof touch.button === "undefined")
                touch.button = 0;
              if (typeof touch.buttons === "undefined")
                touch.buttons = 1;
              if (typeof touch.isPrimary === "undefined") {
                touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
              }
              if (typeof touch.width === "undefined")
                touch.width = touch.radiusX || 1;
              if (typeof touch.height === "undefined")
                touch.height = touch.radiusY || 1;
              if (typeof touch.tiltX === "undefined")
                touch.tiltX = 0;
              if (typeof touch.tiltY === "undefined")
                touch.tiltY = 0;
              if (typeof touch.pointerType === "undefined")
                touch.pointerType = "touch";
              if (typeof touch.pointerId === "undefined")
                touch.pointerId = touch.identifier || 0;
              if (typeof touch.pressure === "undefined")
                touch.pressure = touch.force || 0.5;
              if (typeof touch.twist === "undefined")
                touch.twist = 0;
              if (typeof touch.tangentialPressure === "undefined")
                touch.tangentialPressure = 0;
              if (typeof touch.layerX === "undefined")
                touch.layerX = touch.offsetX = touch.clientX;
              if (typeof touch.layerY === "undefined")
                touch.layerY = touch.offsetY = touch.clientY;
              touch.isNormalized = true;
              touch.type = event.type;
              normalizedEvents.push(touch);
            }
          } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
            const tempEvent = event;
            if (typeof tempEvent.isPrimary === "undefined")
              tempEvent.isPrimary = true;
            if (typeof tempEvent.width === "undefined")
              tempEvent.width = 1;
            if (typeof tempEvent.height === "undefined")
              tempEvent.height = 1;
            if (typeof tempEvent.tiltX === "undefined")
              tempEvent.tiltX = 0;
            if (typeof tempEvent.tiltY === "undefined")
              tempEvent.tiltY = 0;
            if (typeof tempEvent.pointerType === "undefined")
              tempEvent.pointerType = "mouse";
            if (typeof tempEvent.pointerId === "undefined")
              tempEvent.pointerId = MOUSE_POINTER_ID2;
            if (typeof tempEvent.pressure === "undefined")
              tempEvent.pressure = 0.5;
            if (typeof tempEvent.twist === "undefined")
              tempEvent.twist = 0;
            if (typeof tempEvent.tangentialPressure === "undefined")
              tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
          } else {
            normalizedEvents.push(event);
          }
          return normalizedEvents;
        }
        normalizeWheelEvent(nativeEvent) {
          const event = this._rootWheelEvent;
          this._transferMouseData(event, nativeEvent);
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          event.deltaMode = nativeEvent.deltaMode;
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
        }
        _bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this._transferMouseData(event, nativeEvent);
          this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
          event.global.copyFrom(event.screen);
          event.offset.copyFrom(event.screen);
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === "pointerleave") {
            event.type = "pointerout";
          }
          if (event.type.startsWith("mouse")) {
            event.type = event.type.replace("mouse", "pointer");
          }
          if (event.type.startsWith("touch")) {
            event.type = TOUCH_TO_POINTER2[event.type] || event.type;
          }
          return event;
        }
        _transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = performance.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
          event.shiftKey = nativeEvent.shiftKey;
        }
      };
      _EventSystem3.extension = {
        name: "events",
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.CanvasSystem,
          ExtensionType2.WebGPUSystem
        ],
        priority: -1
      };
      _EventSystem3.defaultEventFeatures = {
        move: true,
        globalMove: true,
        click: true,
        wheel: true
      };
      EventSystem2 = _EventSystem3;
    }
  });

  // node_modules/pixi-v8/lib/events/FederatedEventTarget.mjs
  var FederatedContainer;
  var init_FederatedEventTarget2 = __esm({
    "node_modules/pixi-v8/lib/events/FederatedEventTarget.mjs"() {
      init_EventSystem2();
      init_FederatedEvent2();
      FederatedContainer = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
          return this.eventMode === "dynamic" || this.eventMode === "static";
        },
        set interactive(value) {
          this.eventMode = value ? "static" : "passive";
        },
        _internalEventMode: void 0,
        get eventMode() {
          return this._internalEventMode ?? EventSystem2.defaultEventMode;
        },
        set eventMode(value) {
          this._internalEventMode = value;
        },
        isInteractive() {
          return this.eventMode === "static" || this.eventMode === "dynamic";
        },
        interactiveChildren: true,
        hitArea: null,
        addEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const signal = typeof options === "object" ? options.signal : void 0;
          const once = typeof options === "object" ? options.once === true : false;
          const context3 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
          const emitter = this;
          if (signal) {
            signal.addEventListener("abort", () => {
              emitter.off(type, listenerFn, context3);
            });
          }
          if (once) {
            emitter.once(type, listenerFn, context3);
          } else {
            emitter.on(type, listenerFn, context3);
          }
        },
        removeEventListener(type, listener, options) {
          const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
          const context3 = typeof listener === "function" ? void 0 : listener;
          type = capture ? `${type}capture` : type;
          listener = typeof listener === "function" ? listener : listener.handleEvent;
          this.off(type, listener, context3);
        },
        dispatchEvent(e2) {
          if (!(e2 instanceof FederatedEvent2)) {
            throw new Error("Container cannot propagate events outside of the Federated Events API");
          }
          e2.defaultPrevented = false;
          e2.path = null;
          e2.target = this;
          e2.manager.dispatchEvent(e2);
          return !e2.defaultPrevented;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/events/init.mjs
  var init_init3 = __esm({
    "node_modules/pixi-v8/lib/events/init.mjs"() {
      init_Extensions();
      init_Container2();
      init_EventSystem2();
      init_FederatedEventTarget2();
      extensions3.add(EventSystem2);
      Container2.mixin(FederatedContainer);
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/LoaderParser.mjs
  var LoaderParserPriority2;
  var init_LoaderParser2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/LoaderParser.mjs"() {
      "use strict";
      LoaderParserPriority2 = /* @__PURE__ */ ((LoaderParserPriority22) => {
        LoaderParserPriority22[LoaderParserPriority22["Low"] = 0] = "Low";
        LoaderParserPriority22[LoaderParserPriority22["Normal"] = 1] = "Normal";
        LoaderParserPriority22[LoaderParserPriority22["High"] = 2] = "High";
        return LoaderParserPriority22;
      })(LoaderParserPriority2 || {});
    }
  });

  // node_modules/pixi-v8/lib/environment-browser/BrowserAdapter.mjs
  var BrowserAdapter2;
  var init_BrowserAdapter = __esm({
    "node_modules/pixi-v8/lib/environment-browser/BrowserAdapter.mjs"() {
      "use strict";
      BrowserAdapter2 = {
        createCanvas: (width, height) => {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          return canvas;
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (url2, options) => fetch(url2, options),
        parseXML: (xml) => {
          const parser = new DOMParser();
          return parser.parseFromString(xml, "text/xml");
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/environment/adapter.mjs
  var currentAdapter, DOMAdapter;
  var init_adapter2 = __esm({
    "node_modules/pixi-v8/lib/environment/adapter.mjs"() {
      init_BrowserAdapter();
      currentAdapter = BrowserAdapter2;
      DOMAdapter = {
        get() {
          return currentAdapter;
        },
        set(adapter) {
          currentAdapter = adapter;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/path.mjs
  function assertPath2(path22) {
    if (typeof path22 !== "string") {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path22)}`);
    }
  }
  function removeUrlParams2(url2) {
    const re = url2.split("?")[0];
    return re.split("#")[0];
  }
  function escapeRegExp2(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function replaceAll2(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp2(find), "g"), replace);
  }
  function normalizeStringPosix2(path22, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = -1;
    for (let i2 = 0; i2 <= path22.length; ++i2) {
      if (i2 < path22.length) {
        code = path22.charCodeAt(i2);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i2;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `/${path22.slice(lastSlash + 1, i2)}`;
          } else {
            res = path22.slice(lastSlash + 1, i2);
          }
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  var path2;
  var init_path2 = __esm({
    "node_modules/pixi-v8/lib/utils/path.mjs"() {
      init_adapter2();
      path2 = {
        toPosix(path22) {
          return replaceAll2(path22, "\\", "/");
        },
        isUrl(path22) {
          return /^https?:/.test(this.toPosix(path22));
        },
        isDataUrl(path22) {
          return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path22);
        },
        isBlobUrl(path22) {
          return path22.startsWith("blob:");
        },
        hasProtocol(path22) {
          return /^[^/:]+:/.test(this.toPosix(path22));
        },
        getProtocol(path22) {
          assertPath2(path22);
          path22 = this.toPosix(path22);
          const matchFile = /^file:\/\/\//.exec(path22);
          if (matchFile) {
            return matchFile[0];
          }
          const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path22);
          if (matchProtocol) {
            return matchProtocol[0];
          }
          return "";
        },
        toAbsolute(url2, customBaseUrl, customRootUrl) {
          assertPath2(url2);
          if (this.isDataUrl(url2) || this.isBlobUrl(url2))
            return url2;
          const baseUrl = removeUrlParams2(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
          const rootUrl = removeUrlParams2(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
          url2 = this.toPosix(url2);
          if (url2.startsWith("/")) {
            return path2.join(rootUrl, url2.slice(1));
          }
          const absolutePath = this.isAbsolute(url2) ? url2 : this.join(baseUrl, url2);
          return absolutePath;
        },
        normalize(path22) {
          assertPath2(path22);
          if (path22.length === 0)
            return ".";
          if (this.isDataUrl(path22) || this.isBlobUrl(path22))
            return path22;
          path22 = this.toPosix(path22);
          let protocol = "";
          const isAbsolute = path22.startsWith("/");
          if (this.hasProtocol(path22)) {
            protocol = this.rootname(path22);
            path22 = path22.slice(protocol.length);
          }
          const trailingSeparator = path22.endsWith("/");
          path22 = normalizeStringPosix2(path22, false);
          if (path22.length > 0 && trailingSeparator)
            path22 += "/";
          if (isAbsolute)
            return `/${path22}`;
          return protocol + path22;
        },
        isAbsolute(path22) {
          assertPath2(path22);
          path22 = this.toPosix(path22);
          if (this.hasProtocol(path22))
            return true;
          return path22.startsWith("/");
        },
        join(...segments) {
          if (segments.length === 0) {
            return ".";
          }
          let joined;
          for (let i2 = 0; i2 < segments.length; ++i2) {
            const arg = segments[i2];
            assertPath2(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else {
                const prevArg = segments[i2 - 1] ?? "";
                if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                  joined += `/../${arg}`;
                } else {
                  joined += `/${arg}`;
                }
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return this.normalize(joined);
        },
        dirname(path22) {
          assertPath2(path22);
          if (path22.length === 0)
            return ".";
          path22 = this.toPosix(path22);
          let code = path22.charCodeAt(0);
          const hasRoot = code === 47;
          let end = -1;
          let matchedSlash = true;
          const proto = this.getProtocol(path22);
          const origpath = path22;
          path22 = path22.slice(proto.length);
          for (let i2 = path22.length - 1; i2 >= 1; --i2) {
            code = path22.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                end = i2;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : this.isUrl(origpath) ? proto + path22 : proto;
          if (hasRoot && end === 1)
            return "//";
          return proto + path22.slice(0, end);
        },
        rootname(path22) {
          assertPath2(path22);
          path22 = this.toPosix(path22);
          let root = "";
          if (path22.startsWith("/"))
            root = "/";
          else {
            root = this.getProtocol(path22);
          }
          if (this.isUrl(path22)) {
            const index = path22.indexOf("/", root.length);
            if (index !== -1) {
              root = path22.slice(0, index);
            } else
              root = path22;
            if (!root.endsWith("/"))
              root += "/";
          }
          return root;
        },
        basename(path22, ext) {
          assertPath2(path22);
          if (ext)
            assertPath2(ext);
          path22 = removeUrlParams2(this.toPosix(path22));
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i2;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path22.length) {
            if (ext.length === path22.length && ext === path22)
              return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i2 = path22.length - 1; i2 >= 0; --i2) {
              const code = path22.charCodeAt(i2);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i2 + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i2 + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i2;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path22.length;
            return path22.slice(start, end);
          }
          for (i2 = path22.length - 1; i2 >= 0; --i2) {
            if (path22.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path22.slice(start, end);
        },
        extname(path22) {
          assertPath2(path22);
          path22 = removeUrlParams2(this.toPosix(path22));
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i2 = path22.length - 1; i2 >= 0; --i2) {
            const code = path22.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path22.slice(startDot, end);
        },
        parse(path22) {
          assertPath2(path22);
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path22.length === 0)
            return ret;
          path22 = removeUrlParams2(this.toPosix(path22));
          let code = path22.charCodeAt(0);
          const isAbsolute = this.isAbsolute(path22);
          let start;
          const protocol = "";
          ret.root = this.rootname(path22);
          if (isAbsolute || this.hasProtocol(path22)) {
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i2 = path22.length - 1;
          let preDotState = 0;
          for (; i2 >= start; --i2) {
            code = path22.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i2 + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i2;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute)
                ret.base = ret.name = path22.slice(1, end);
              else
                ret.base = ret.name = path22.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute) {
              ret.name = path22.slice(1, startDot);
              ret.base = path22.slice(1, end);
            } else {
              ret.name = path22.slice(startPart, startDot);
              ret.base = path22.slice(startPart, end);
            }
            ret.ext = path22.slice(startDot, end);
          }
          ret.dir = this.dirname(path22);
          if (protocol)
            ret.dir = protocol + ret.dir;
          return ret;
        },
        sep: "/",
        delimiter: ":",
        joinExtensions: [".html"]
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/convertToList.mjs
  var convertToList2;
  var init_convertToList2 = __esm({
    "node_modules/pixi-v8/lib/assets/utils/convertToList.mjs"() {
      "use strict";
      convertToList2 = (input, transform2, forceTransform = false) => {
        if (!Array.isArray(input)) {
          input = [input];
        }
        if (!transform2) {
          return input;
        }
        return input.map((item) => {
          if (typeof item === "string" || forceTransform) {
            return transform2(item);
          }
          return item;
        });
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/createStringVariations.mjs
  function processX2(base, ids, depth, result, tags) {
    const id = ids[depth];
    for (let i2 = 0; i2 < id.length; i2++) {
      const value = id[i2];
      if (depth < ids.length - 1) {
        processX2(base.replace(result[depth], value), ids, depth + 1, result, tags);
      } else {
        tags.push(base.replace(result[depth], value));
      }
    }
  }
  function createStringVariations2(string) {
    const regex = /\{(.*?)\}/g;
    const result = string.match(regex);
    const tags = [];
    if (result) {
      const ids = [];
      result.forEach((vars) => {
        const split = vars.substring(1, vars.length - 1).split(",");
        ids.push(split);
      });
      processX2(string, ids, 0, result, tags);
    } else {
      tags.push(string);
    }
    return tags;
  }
  var init_createStringVariations2 = __esm({
    "node_modules/pixi-v8/lib/assets/utils/createStringVariations.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/isSingleItem.mjs
  var isSingleItem2;
  var init_isSingleItem2 = __esm({
    "node_modules/pixi-v8/lib/assets/utils/isSingleItem.mjs"() {
      "use strict";
      isSingleItem2 = (item) => !Array.isArray(item);
    }
  });

  // node_modules/pixi-v8/lib/assets/resolver/Resolver.mjs
  function getUrlExtension(url2) {
    return url2.split(".").pop().split("?").shift().split("#").shift();
  }
  var Resolver2;
  var init_Resolver2 = __esm({
    "node_modules/pixi-v8/lib/assets/resolver/Resolver.mjs"() {
      init_warn();
      init_path2();
      init_convertToList2();
      init_createStringVariations2();
      init_isSingleItem2();
      Resolver2 = class {
        constructor() {
          this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
            extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
          };
          this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
          this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
          this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
          this._assetMap = {};
          this._preferredOrder = [];
          this._parsers = [];
          this._resolverHash = {};
          this._bundles = {};
        }
        setBundleIdentifier(bundleIdentifier) {
          this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
          this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
          this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
          if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
          }
        }
        prefer(...preferOrders) {
          preferOrders.forEach((prefer) => {
            this._preferredOrder.push(prefer);
            if (!prefer.priority) {
              prefer.priority = Object.keys(prefer.params);
            }
          });
          this._resolverHash = {};
        }
        set basePath(basePath) {
          this._basePath = basePath;
        }
        get basePath() {
          return this._basePath;
        }
        set rootPath(rootPath) {
          this._rootPath = rootPath;
        }
        get rootPath() {
          return this._rootPath;
        }
        get parsers() {
          return this._parsers;
        }
        reset() {
          this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
          this._assetMap = {};
          this._preferredOrder = [];
          this._resolverHash = {};
          this._rootPath = null;
          this._basePath = null;
          this._manifest = null;
          this._bundles = {};
          this._defaultSearchParams = null;
        }
        setDefaultSearchParams(searchParams) {
          if (typeof searchParams === "string") {
            this._defaultSearchParams = searchParams;
          } else {
            const queryValues = searchParams;
            this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
          }
        }
        getAlias(asset) {
          const { alias, src } = asset;
          const aliasesToUse = convertToList2(
            alias || src,
            (value) => {
              if (typeof value === "string")
                return value;
              if (Array.isArray(value))
                return value.map((v2) => v2?.src ?? v2);
              if (value?.src)
                return value.src;
              return value;
            },
            true
          );
          return aliasesToUse;
        }
        addManifest(manifest) {
          if (this._manifest) {
            warn("[Resolver] Manifest already exists, this will be overwritten");
          }
          this._manifest = manifest;
          manifest.bundles.forEach((bundle) => {
            this.addBundle(bundle.name, bundle.assets);
          });
        }
        addBundle(bundleId, assets) {
          const assetNames = [];
          let convertedAssets = assets;
          if (!Array.isArray(assets)) {
            convertedAssets = Object.entries(assets).map(([alias, src]) => {
              if (typeof src === "string" || Array.isArray(src)) {
                return { alias, src };
              }
              return { alias, ...src };
            });
          }
          convertedAssets.forEach((asset) => {
            const srcs = asset.src;
            const aliases = asset.alias;
            let ids;
            if (typeof aliases === "string") {
              const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
              assetNames.push(bundleAssetId);
              ids = [aliases, bundleAssetId];
            } else {
              const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
              assetNames.push(...bundleIds);
              ids = [...aliases, ...bundleIds];
            }
            this.add({
              ...asset,
              ...{
                alias: ids,
                src: srcs
              }
            });
          });
          this._bundles[bundleId] = assetNames;
        }
        add(aliases) {
          const assets = [];
          if (Array.isArray(aliases)) {
            assets.push(...aliases);
          } else {
            assets.push(aliases);
          }
          let keyCheck;
          keyCheck = (key) => {
            if (this.hasKey(key)) {
              warn(`[Resolver] already has key: ${key} overwriting`);
            }
          };
          const assetArray = convertToList2(assets);
          assetArray.forEach((asset) => {
            const { src } = asset;
            let { data, format: format2, loadParser } = asset;
            const srcsToUse = convertToList2(src).map((src2) => {
              if (typeof src2 === "string") {
                return createStringVariations2(src2);
              }
              return Array.isArray(src2) ? src2 : [src2];
            });
            const aliasesToUse = this.getAlias(asset);
            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
            const resolvedAssets = [];
            srcsToUse.forEach((srcs) => {
              srcs.forEach((src2) => {
                let formattedAsset = {};
                if (typeof src2 !== "object") {
                  formattedAsset.src = src2;
                  for (let i2 = 0; i2 < this._parsers.length; i2++) {
                    const parser = this._parsers[i2];
                    if (parser.test(src2)) {
                      formattedAsset = parser.parse(src2);
                      break;
                    }
                  }
                } else {
                  data = src2.data ?? data;
                  format2 = src2.format ?? format2;
                  loadParser = src2.loadParser ?? loadParser;
                  formattedAsset = {
                    ...formattedAsset,
                    ...src2
                  };
                }
                if (!aliasesToUse) {
                  throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
                }
                formattedAsset = this._buildResolvedAsset(formattedAsset, {
                  aliases: aliasesToUse,
                  data,
                  format: format2,
                  loadParser
                });
                resolvedAssets.push(formattedAsset);
              });
            });
            aliasesToUse.forEach((alias) => {
              this._assetMap[alias] = resolvedAssets;
            });
          });
        }
        resolveBundle(bundleIds) {
          const singleAsset = isSingleItem2(bundleIds);
          bundleIds = convertToList2(bundleIds);
          const out2 = {};
          bundleIds.forEach((bundleId) => {
            const assetNames = this._bundles[bundleId];
            if (assetNames) {
              const results = this.resolve(assetNames);
              const assets = {};
              for (const key in results) {
                const asset = results[key];
                assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
              }
              out2[bundleId] = assets;
            }
          });
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        resolveUrl(key) {
          const result = this.resolve(key);
          if (typeof key !== "string") {
            const out2 = {};
            for (const i2 in result) {
              out2[i2] = result[i2].src;
            }
            return out2;
          }
          return result.src;
        }
        resolve(keys) {
          const singleAsset = isSingleItem2(keys);
          keys = convertToList2(keys);
          const result = {};
          keys.forEach((key) => {
            if (!this._resolverHash[key]) {
              if (this._assetMap[key]) {
                let assets = this._assetMap[key];
                const preferredOrder = this._getPreferredOrder(assets);
                preferredOrder?.priority.forEach((priorityKey) => {
                  preferredOrder.params[priorityKey].forEach((value) => {
                    const filteredAssets = assets.filter((asset) => {
                      if (asset[priorityKey]) {
                        return asset[priorityKey] === value;
                      }
                      return false;
                    });
                    if (filteredAssets.length) {
                      assets = filteredAssets;
                    }
                  });
                });
                this._resolverHash[key] = assets[0];
              } else {
                this._resolverHash[key] = this._buildResolvedAsset({
                  alias: [key],
                  src: key
                }, {});
              }
            }
            result[key] = this._resolverHash[key];
          });
          return singleAsset ? result[keys[0]] : result;
        }
        hasKey(key) {
          return !!this._assetMap[key];
        }
        hasBundle(key) {
          return !!this._bundles[key];
        }
        _getPreferredOrder(assets) {
          for (let i2 = 0; i2 < assets.length; i2++) {
            const asset = assets[0];
            const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
            if (preferred) {
              return preferred;
            }
          }
          return this._preferredOrder[0];
        }
        _appendDefaultSearchParams(url2) {
          if (!this._defaultSearchParams)
            return url2;
          const paramConnector = /\?/.test(url2) ? "&" : "?";
          return `${url2}${paramConnector}${this._defaultSearchParams}`;
        }
        _buildResolvedAsset(formattedAsset, data) {
          const { aliases, data: assetData, loadParser, format: format2 } = data;
          if (this._basePath || this._rootPath) {
            formattedAsset.src = path2.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
          }
          formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
          formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
          formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
          formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
          formattedAsset.format = format2 ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
          return formattedAsset;
        }
      };
      Resolver2.RETINA_PREFIX = /@([0-9\.]+)x/;
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/copySearchParams.mjs
  var copySearchParams2;
  var init_copySearchParams2 = __esm({
    "node_modules/pixi-v8/lib/assets/utils/copySearchParams.mjs"() {
      "use strict";
      copySearchParams2 = (targetUrl, sourceUrl) => {
        const searchParams = sourceUrl.split("?")[1];
        if (searchParams) {
          targetUrl += `?${searchParams}`;
        }
        return targetUrl;
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/matrix/groupD8.mjs
  function init2() {
    for (let i2 = 0; i2 < 16; i2++) {
      const row = [];
      rotationCayley2.push(row);
      for (let j2 = 0; j2 < 16; j2++) {
        const _ux = signum2(ux2[i2] * ux2[j2] + vx2[i2] * uy2[j2]);
        const _uy = signum2(uy2[i2] * ux2[j2] + vy2[i2] * uy2[j2]);
        const _vx = signum2(ux2[i2] * vx2[j2] + vx2[i2] * vy2[j2]);
        const _vy = signum2(uy2[i2] * vx2[j2] + vy2[i2] * vy2[j2]);
        for (let k2 = 0; k2 < 16; k2++) {
          if (ux2[k2] === _ux && uy2[k2] === _uy && vx2[k2] === _vx && vy2[k2] === _vy) {
            row.push(k2);
            break;
          }
        }
      }
    }
    for (let i2 = 0; i2 < 16; i2++) {
      const mat = new Matrix2();
      mat.set(ux2[i2], uy2[i2], vx2[i2], vy2[i2], 0, 0);
      rotationMatrices2.push(mat);
    }
  }
  var ux2, uy2, vx2, vy2, rotationCayley2, rotationMatrices2, signum2, groupD82;
  var init_groupD82 = __esm({
    "node_modules/pixi-v8/lib/maths/matrix/groupD8.mjs"() {
      init_Matrix2();
      ux2 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
      uy2 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
      vx2 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
      vy2 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
      rotationCayley2 = [];
      rotationMatrices2 = [];
      signum2 = Math.sign;
      init2();
      groupD82 = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: (ind) => ux2[ind],
        uY: (ind) => uy2[ind],
        vX: (ind) => vx2[ind],
        vY: (ind) => vy2[ind],
        inv: (rotation) => {
          if (rotation & 8) {
            return rotation & 15;
          }
          return -rotation & 7;
        },
        add: (rotationSecond, rotationFirst) => rotationCayley2[rotationSecond][rotationFirst],
        sub: (rotationSecond, rotationFirst) => rotationCayley2[rotationSecond][groupD82.inv(rotationFirst)],
        rotate180: (rotation) => rotation ^ 4,
        isVertical: (rotation) => (rotation & 3) === 2,
        byDirection: (dx, dy) => {
          if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
              return groupD82.S;
            }
            return groupD82.N;
          } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
              return groupD82.E;
            }
            return groupD82.W;
          } else if (dy > 0) {
            if (dx > 0) {
              return groupD82.SE;
            }
            return groupD82.SW;
          } else if (dx > 0) {
            return groupD82.NE;
          }
          return groupD82.NW;
        },
        matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
          const mat = rotationMatrices2[groupD82.inv(rotation)];
          mat.tx = tx;
          mat.ty = ty;
          matrix.append(mat);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/misc/NOOP.mjs
  var NOOP;
  var init_NOOP = __esm({
    "node_modules/pixi-v8/lib/utils/misc/NOOP.mjs"() {
      "use strict";
      NOOP = () => {
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/misc/pow2.mjs
  function nextPow22(v2) {
    v2 += v2 === 0 ? 1 : 0;
    --v2;
    v2 |= v2 >>> 1;
    v2 |= v2 >>> 2;
    v2 |= v2 >>> 4;
    v2 |= v2 >>> 8;
    v2 |= v2 >>> 16;
    return v2 + 1;
  }
  function isPow22(v2) {
    return !(v2 & v2 - 1) && !!v2;
  }
  var init_pow22 = __esm({
    "node_modules/pixi-v8/lib/maths/misc/pow2.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/definedProps.mjs
  function definedProps(obj) {
    const result = {};
    for (const key in obj) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  var init_definedProps = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/definedProps.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureStyle.mjs
  function createResourceIdFromString(value) {
    const id = idHash[value];
    if (id === void 0) {
      idHash[value] = uid2("resource");
    }
    return id;
  }
  var idHash, _TextureStyle, TextureStyle;
  var init_TextureStyle = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
      init_eventemitter3();
      init_uid2();
      init_deprecation2();
      idHash = /* @__PURE__ */ Object.create(null);
      _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this._resourceType = "textureSampler";
          this._touched = 0;
          this._maxAnisotropy = 1;
          this.destroyed = false;
          options = { ..._TextureStyle2.defaultOptions, ...options };
          this.addressMode = options.addressMode;
          this.addressModeU = options.addressModeU ?? this.addressModeU;
          this.addressModeV = options.addressModeV ?? this.addressModeV;
          this.addressModeW = options.addressModeW ?? this.addressModeW;
          this.scaleMode = options.scaleMode;
          this.magFilter = options.magFilter ?? this.magFilter;
          this.minFilter = options.minFilter ?? this.minFilter;
          this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
          this.lodMinClamp = options.lodMinClamp;
          this.lodMaxClamp = options.lodMaxClamp;
          this.compare = options.compare;
          this.maxAnisotropy = options.maxAnisotropy ?? 1;
        }
        set addressMode(value) {
          this.addressModeU = value;
          this.addressModeV = value;
          this.addressModeW = value;
        }
        get addressMode() {
          return this.addressModeU;
        }
        set wrapMode(value) {
          deprecation2(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
          this.addressMode = value;
        }
        get wrapMode() {
          return this.addressMode;
        }
        set scaleMode(value) {
          this.magFilter = value;
          this.minFilter = value;
          this.mipmapFilter = value;
        }
        get scaleMode() {
          return this.magFilter;
        }
        set maxAnisotropy(value) {
          this._maxAnisotropy = Math.min(value, 16);
          if (this._maxAnisotropy > 1) {
            this.scaleMode = "linear";
          }
        }
        get maxAnisotropy() {
          return this._maxAnisotropy;
        }
        get _resourceId() {
          return this._sharedResourceId || this._generateResourceId();
        }
        update() {
          this.emit("change", this);
          this._sharedResourceId = null;
        }
        _generateResourceId() {
          const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
          this._sharedResourceId = createResourceIdFromString(bigKey);
          return this._resourceId;
        }
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this.removeAllListeners();
        }
      };
      _TextureStyle.defaultOptions = {
        addressMode: "clamp-to-edge",
        scaleMode: "linear"
      };
      TextureStyle = _TextureStyle;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
  var _TextureSource, TextureSource;
  var init_TextureSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
      init_eventemitter3();
      init_pow22();
      init_definedProps();
      init_uid2();
      init_TextureStyle();
      _TextureSource = class _TextureSource2 extends eventemitter3_default {
        constructor(options = {}) {
          super();
          this.options = options;
          this.uid = uid2("textureSource");
          this._resourceType = "textureSource";
          this._resourceId = uid2("resource");
          this.uploadMethodId = "unknown";
          this._resolution = 1;
          this.pixelWidth = 1;
          this.pixelHeight = 1;
          this.width = 1;
          this.height = 1;
          this.sampleCount = 1;
          this.mipLevelCount = 1;
          this.autoGenerateMipmaps = false;
          this.format = "rgba8unorm";
          this.dimension = "2d";
          this.antialias = false;
          this._touched = 0;
          this._batchTick = -1;
          this._textureBindLocation = -1;
          options = { ..._TextureSource2.defaultOptions, ...options };
          this.label = options.label ?? "";
          this.resource = options.resource;
          this.autoGarbageCollect = options.autoGarbageCollect;
          this._resolution = options.resolution;
          if (options.width) {
            this.pixelWidth = options.width * this._resolution;
          } else {
            this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
          }
          if (options.height) {
            this.pixelHeight = options.height * this._resolution;
          } else {
            this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
          }
          this.width = this.pixelWidth / this._resolution;
          this.height = this.pixelHeight / this._resolution;
          this.format = options.format;
          this.dimension = options.dimensions;
          this.mipLevelCount = options.mipLevelCount;
          this.autoGenerateMipmaps = options.autoGenerateMipmaps;
          this.sampleCount = options.sampleCount;
          this.antialias = options.antialias;
          this.alphaMode = options.alphaMode;
          this.style = new TextureStyle(definedProps(options));
          this.destroyed = false;
          this._refreshPOT();
        }
        get source() {
          return this;
        }
        get style() {
          return this._style;
        }
        set style(value) {
          if (this.style === value)
            return;
          this._style?.off("change", this._onStyleChange, this);
          this._style = value;
          this._style?.on("change", this._onStyleChange, this);
          this._onStyleChange();
        }
        get addressMode() {
          return this._style.addressMode;
        }
        set addressMode(value) {
          this._style.addressMode = value;
        }
        get repeatMode() {
          return this._style.addressMode;
        }
        set repeatMode(value) {
          this._style.addressMode = value;
        }
        get magFilter() {
          return this._style.magFilter;
        }
        set magFilter(value) {
          this._style.magFilter = value;
        }
        get minFilter() {
          return this._style.minFilter;
        }
        set minFilter(value) {
          this._style.minFilter = value;
        }
        get mipmapFilter() {
          return this._style.mipmapFilter;
        }
        set mipmapFilter(value) {
          this._style.mipmapFilter = value;
        }
        get lodMinClamp() {
          return this._style.lodMinClamp;
        }
        set lodMinClamp(value) {
          this._style.lodMinClamp = value;
        }
        get lodMaxClamp() {
          return this._style.lodMaxClamp;
        }
        set lodMaxClamp(value) {
          this._style.lodMaxClamp = value;
        }
        _onStyleChange() {
          this.emit("styleChange", this);
        }
        update() {
          if (this.resource) {
            const resolution = this._resolution;
            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
            if (didResize)
              return;
          }
          this.emit("update", this);
        }
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          if (this._style) {
            this._style.destroy();
            this._style = null;
          }
          this.uploadMethodId = null;
          this.resource = null;
          this.removeAllListeners();
        }
        unload() {
          this._resourceId = uid2("resource");
          this.emit("change", this);
          this.emit("unload", this);
        }
        get resourceWidth() {
          const { resource } = this;
          return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
        }
        get resourceHeight() {
          const { resource } = this;
          return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(resolution) {
          if (this._resolution === resolution)
            return;
          this._resolution = resolution;
          this.width = this.pixelWidth / resolution;
          this.height = this.pixelHeight / resolution;
        }
        resize(width, height, resolution) {
          resolution = resolution || this._resolution;
          width = width || this.width;
          height = height || this.height;
          const newPixelWidth = Math.round(width * resolution);
          const newPixelHeight = Math.round(height * resolution);
          this.width = newPixelWidth / resolution;
          this.height = newPixelHeight / resolution;
          this._resolution = resolution;
          if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
            return false;
          }
          this._refreshPOT();
          this.pixelWidth = newPixelWidth;
          this.pixelHeight = newPixelHeight;
          this.emit("resize", this);
          this._resourceId = uid2("resource");
          this.emit("change", this);
          return true;
        }
        updateMipmaps() {
          if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
            this.emit("updateMipmaps", this);
          }
        }
        set wrapMode(value) {
          this._style.wrapMode = value;
        }
        get wrapMode() {
          return this._style.wrapMode;
        }
        set scaleMode(value) {
          this._style.scaleMode = value;
        }
        get scaleMode() {
          return this._style.scaleMode;
        }
        _refreshPOT() {
          this.isPowerOfTwo = isPow22(this.pixelWidth) && isPow22(this.pixelHeight);
        }
        static test(_resource) {
          throw new Error("Unimplemented");
        }
      };
      _TextureSource.defaultOptions = {
        resolution: 1,
        format: "bgra8unorm",
        alphaMode: "premultiply-alpha-on-upload",
        dimensions: "2d",
        mipLevelCount: 1,
        autoGenerateMipmaps: false,
        sampleCount: 1,
        antialias: false,
        autoGarbageCollect: false
      };
      TextureSource = _TextureSource;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
  var BufferImageSource;
  var init_BufferImageSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
      init_Extensions();
      init_TextureSource();
      BufferImageSource = class extends TextureSource {
        constructor(options) {
          const buffer = options.resource || new Float32Array(options.width * options.height * 4);
          let format2 = options.format;
          if (!format2) {
            if (buffer instanceof Float32Array) {
              format2 = "rgba32float";
            } else if (buffer instanceof Int32Array) {
              format2 = "rgba32uint";
            } else if (buffer instanceof Uint32Array) {
              format2 = "rgba32uint";
            } else if (buffer instanceof Int16Array) {
              format2 = "rgba16uint";
            } else if (buffer instanceof Uint16Array) {
              format2 = "rgba16uint";
            } else if (buffer instanceof Int8Array) {
              format2 = "bgra8unorm";
            } else {
              format2 = "bgra8unorm";
            }
          }
          super({
            ...options,
            resource: buffer,
            format: format2
          });
          this.uploadMethodId = "buffer";
        }
        static test(resource) {
          return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
        }
      };
      BufferImageSource.extension = ExtensionType2.TextureSource;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
  var tempMat3, TextureMatrix2;
  var init_TextureMatrix2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
      init_Matrix2();
      tempMat3 = new Matrix2();
      TextureMatrix2 = class {
        constructor(texture, clampMargin) {
          this.mapCoord = new Matrix2();
          this.uClampFrame = new Float32Array(4);
          this.uClampOffset = new Float32Array(2);
          this._textureID = -1;
          this._updateID = 0;
          this.clampOffset = 0;
          if (typeof clampMargin === "undefined") {
            this.clampMargin = texture.width < 10 ? 0 : 0.5;
          } else {
            this.clampMargin = clampMargin;
          }
          this.isSimple = false;
          this.texture = texture;
        }
        get texture() {
          return this._texture;
        }
        set texture(value) {
          if (this.texture === value)
            return;
          this._texture?.removeListener("update", this.update, this);
          this._texture = value;
          this._texture.addListener("update", this.update, this);
          this.update();
        }
        multiplyUvs(uvs, out2) {
          if (out2 === void 0) {
            out2 = uvs;
          }
          const mat = this.mapCoord;
          for (let i2 = 0; i2 < uvs.length; i2 += 2) {
            const x2 = uvs[i2];
            const y2 = uvs[i2 + 1];
            out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
            out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
          }
          return out2;
        }
        update() {
          const tex = this._texture;
          this._updateID++;
          const uvs = tex.uvs;
          this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
          const orig = tex.orig;
          const trim = tex.trim;
          if (trim) {
            tempMat3.set(
              orig.width / trim.width,
              0,
              0,
              orig.height / trim.height,
              -trim.x / trim.width,
              -trim.y / trim.height
            );
            this.mapCoord.append(tempMat3);
          }
          const texBase = tex.source;
          const frame = this.uClampFrame;
          const margin = this.clampMargin / texBase._resolution;
          const offset = this.clampOffset / texBase._resolution;
          frame[0] = (tex.frame.x + margin + offset) / texBase.width;
          frame[1] = (tex.frame.y + margin + offset) / texBase.height;
          frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
          frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
          this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
          this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
          this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
          return true;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/Texture.mjs
  var Texture2;
  var init_Texture2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/Texture.mjs"() {
      init_eventemitter3();
      init_groupD82();
      init_Rectangle2();
      init_uid2();
      init_deprecation2();
      init_NOOP();
      init_BufferImageSource();
      init_TextureSource();
      init_TextureMatrix2();
      Texture2 = class extends eventemitter3_default {
        constructor({
          source: source2,
          label,
          frame,
          orig,
          trim,
          defaultAnchor,
          defaultBorders,
          rotate,
          dynamic
        } = {}) {
          super();
          this.uid = uid2("texture");
          this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
          this.frame = new Rectangle2();
          this.noFrame = false;
          this.dynamic = false;
          this.isTexture = true;
          this.label = label;
          this.source = source2?.source ?? new TextureSource();
          this.noFrame = !frame;
          if (frame) {
            this.frame.copyFrom(frame);
          } else {
            const { width, height } = this._source;
            this.frame.width = width;
            this.frame.height = height;
          }
          this.orig = orig || this.frame;
          this.trim = trim;
          this.rotate = rotate ?? 0;
          this.defaultAnchor = defaultAnchor;
          this.defaultBorders = defaultBorders;
          this.destroyed = false;
          this.dynamic = dynamic || false;
          this.updateUvs();
        }
        set source(value) {
          if (this._source) {
            this._source.off("resize", this.update, this);
          }
          this._source = value;
          value.on("resize", this.update, this);
          this.emit("update", this);
        }
        get source() {
          return this._source;
        }
        get textureMatrix() {
          if (!this._textureMatrix) {
            this._textureMatrix = new TextureMatrix2(this);
          }
          return this._textureMatrix;
        }
        get width() {
          return this.orig.width;
        }
        get height() {
          return this.orig.height;
        }
        updateUvs() {
          const { uvs, frame } = this;
          const { width, height } = this._source;
          const nX = frame.x / width;
          const nY = frame.y / height;
          const nW = frame.width / width;
          const nH = frame.height / height;
          let rotate = this.rotate;
          if (rotate) {
            const w2 = nW / 2;
            const h2 = nH / 2;
            const cX = nX + w2;
            const cY = nY + h2;
            rotate = groupD82.add(rotate, groupD82.NW);
            uvs.x0 = cX + w2 * groupD82.uX(rotate);
            uvs.y0 = cY + h2 * groupD82.uY(rotate);
            rotate = groupD82.add(rotate, 2);
            uvs.x1 = cX + w2 * groupD82.uX(rotate);
            uvs.y1 = cY + h2 * groupD82.uY(rotate);
            rotate = groupD82.add(rotate, 2);
            uvs.x2 = cX + w2 * groupD82.uX(rotate);
            uvs.y2 = cY + h2 * groupD82.uY(rotate);
            rotate = groupD82.add(rotate, 2);
            uvs.x3 = cX + w2 * groupD82.uX(rotate);
            uvs.y3 = cY + h2 * groupD82.uY(rotate);
          } else {
            uvs.x0 = nX;
            uvs.y0 = nY;
            uvs.x1 = nX + nW;
            uvs.y1 = nY;
            uvs.x2 = nX + nW;
            uvs.y2 = nY + nH;
            uvs.x3 = nX;
            uvs.y3 = nY + nH;
          }
        }
        destroy(destroySource = false) {
          if (this._source) {
            if (destroySource) {
              this._source.destroy();
              this._source = null;
            }
          }
          this._textureMatrix = null;
          this.destroyed = true;
          this.emit("destroy", this);
          this.removeAllListeners();
        }
        update() {
          if (this.noFrame) {
            this.frame.width = this._source.width;
            this.frame.height = this._source.height;
          }
          this.updateUvs();
          this.emit("update", this);
        }
        get baseTexture() {
          deprecation2(v8_0_0, "Texture.baseTexture is now Texture.source");
          return this._source;
        }
      };
      Texture2.EMPTY = new Texture2({
        label: "EMPTY",
        source: new TextureSource({
          label: "EMPTY"
        })
      });
      Texture2.EMPTY.destroy = NOOP;
      Texture2.WHITE = new Texture2({
        source: new BufferImageSource({
          resource: new Uint8Array([255, 255, 255, 255]),
          width: 1,
          height: 1,
          alphaMode: "premultiply-alpha-on-upload",
          label: "WHITE"
        }),
        label: "WHITE"
      });
      Texture2.WHITE.destroy = NOOP;
    }
  });

  // node_modules/pixi-v8/lib/spritesheet/Spritesheet.mjs
  var _Spritesheet3, Spritesheet2;
  var init_Spritesheet2 = __esm({
    "node_modules/pixi-v8/lib/spritesheet/Spritesheet.mjs"() {
      init_Rectangle2();
      init_Texture2();
      _Spritesheet3 = class _Spritesheet4 {
        constructor(texture, data) {
          this.linkedSheets = [];
          this._texture = texture instanceof Texture2 ? texture : null;
          this.textureSource = texture.source;
          this.textures = {};
          this.animations = {};
          this.data = data;
          const metaResolution = parseFloat(data.meta.scale);
          if (metaResolution) {
            this.resolution = metaResolution;
            texture.source.resolution = this.resolution;
          } else {
            this.resolution = texture.source._resolution;
          }
          this._frames = this.data.frames;
          this._frameKeys = Object.keys(this._frames);
          this._batchIndex = 0;
          this._callback = null;
        }
        parse() {
          return new Promise((resolve2) => {
            this._callback = resolve2;
            this._batchIndex = 0;
            if (this._frameKeys.length <= _Spritesheet4.BATCH_SIZE) {
              this._processFrames(0);
              this._processAnimations();
              this._parseComplete();
            } else {
              this._nextBatch();
            }
          });
        }
        _processFrames(initialFrameIndex) {
          let frameIndex = initialFrameIndex;
          const maxFrames = _Spritesheet4.BATCH_SIZE;
          while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            const i2 = this._frameKeys[frameIndex];
            const data = this._frames[i2];
            const rect = data.frame;
            if (rect) {
              let frame = null;
              let trim = null;
              const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
              const orig = new Rectangle2(
                0,
                0,
                Math.floor(sourceSize.w) / this.resolution,
                Math.floor(sourceSize.h) / this.resolution
              );
              if (data.rotated) {
                frame = new Rectangle2(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.h) / this.resolution,
                  Math.floor(rect.w) / this.resolution
                );
              } else {
                frame = new Rectangle2(
                  Math.floor(rect.x) / this.resolution,
                  Math.floor(rect.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              if (data.trimmed !== false && data.spriteSourceSize) {
                trim = new Rectangle2(
                  Math.floor(data.spriteSourceSize.x) / this.resolution,
                  Math.floor(data.spriteSourceSize.y) / this.resolution,
                  Math.floor(rect.w) / this.resolution,
                  Math.floor(rect.h) / this.resolution
                );
              }
              this.textures[i2] = new Texture2({
                source: this.textureSource,
                frame,
                orig,
                trim,
                rotate: data.rotated ? 2 : 0,
                defaultAnchor: data.anchor,
                defaultBorders: data.borders,
                label: i2.toString()
              });
            }
            frameIndex++;
          }
        }
        _processAnimations() {
          const animations = this.data.animations || {};
          for (const animName in animations) {
            this.animations[animName] = [];
            for (let i2 = 0; i2 < animations[animName].length; i2++) {
              const frameName = animations[animName][i2];
              this.animations[animName].push(this.textures[frameName]);
            }
          }
        }
        _parseComplete() {
          const callback = this._callback;
          this._callback = null;
          this._batchIndex = 0;
          callback.call(this, this.textures);
        }
        _nextBatch() {
          this._processFrames(this._batchIndex * _Spritesheet4.BATCH_SIZE);
          this._batchIndex++;
          setTimeout(() => {
            if (this._batchIndex * _Spritesheet4.BATCH_SIZE < this._frameKeys.length) {
              this._nextBatch();
            } else {
              this._processAnimations();
              this._parseComplete();
            }
          }, 0);
        }
        destroy(destroyBase = false) {
          for (const i2 in this.textures) {
            this.textures[i2].destroy();
          }
          this._frames = null;
          this._frameKeys = null;
          this.data = null;
          this.textures = null;
          if (destroyBase) {
            this._texture?.destroy();
            this.textureSource.destroy();
          }
          this._texture = null;
          this.textureSource = null;
          this.linkedSheets = [];
        }
      };
      _Spritesheet3.BATCH_SIZE = 1e3;
      Spritesheet2 = _Spritesheet3;
    }
  });

  // node_modules/pixi-v8/lib/spritesheet/spritesheetAsset.mjs
  function getCacheableAssets2(keys, asset, ignoreMultiPack) {
    const out2 = {};
    keys.forEach((key) => {
      out2[key] = asset;
    });
    Object.keys(asset.textures).forEach((key) => {
      out2[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path2.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i2) => {
        const out22 = getCacheableAssets2([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
        Object.assign(out2, out22);
      });
    }
    return out2;
  }
  var validImages2, spritesheetAsset2;
  var init_spritesheetAsset2 = __esm({
    "node_modules/pixi-v8/lib/spritesheet/spritesheetAsset.mjs"() {
      init_LoaderParser2();
      init_Resolver2();
      init_copySearchParams2();
      init_Extensions();
      init_Texture2();
      init_path2();
      init_Spritesheet2();
      validImages2 = [
        "jpg",
        "png",
        "jpeg",
        "avif",
        "webp",
        "basis",
        "etc2",
        "bc7",
        "bc6h",
        "bc5",
        "bc4",
        "bc3",
        "bc2",
        "bc1",
        "eac",
        "astc"
      ];
      spritesheetAsset2 = {
        extension: ExtensionType2.Asset,
        cache: {
          test: (asset) => asset instanceof Spritesheet2,
          getCacheableAssets: (keys, asset) => getCacheableAssets2(keys, asset, false)
        },
        resolver: {
          extension: {
            type: ExtensionType2.ResolveParser,
            name: "resolveSpritesheet"
          },
          test: (value) => {
            const tempURL = value.split("?")[0];
            const split = tempURL.split(".");
            const extension = split.pop();
            const format2 = split.pop();
            return extension === "json" && validImages2.includes(format2);
          },
          parse: (value) => {
            const split = value.split(".");
            return {
              resolution: parseFloat(Resolver2.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
              format: split[split.length - 2],
              src: value
            };
          }
        },
        loader: {
          name: "spritesheetLoader",
          extension: {
            type: ExtensionType2.LoadParser,
            priority: LoaderParserPriority2.Normal,
            name: "spritesheetLoader"
          },
          async testParse(asset, options) {
            return path2.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
          },
          async parse(asset, options, loader) {
            const {
              texture: imageTexture,
              imageFilename
            } = options?.data ?? {};
            let basePath = path2.dirname(options.src);
            if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
              basePath += "/";
            }
            let texture;
            if (imageTexture instanceof Texture2) {
              texture = imageTexture;
            } else {
              const imagePath = copySearchParams2(basePath + (imageFilename ?? asset.meta.image), options.src);
              const assets = await loader.load([imagePath]);
              texture = assets[imagePath];
            }
            const spritesheet = new Spritesheet2(
              texture.source,
              asset
            );
            await spritesheet.parse();
            const multiPacks = asset?.meta?.related_multi_packs;
            if (Array.isArray(multiPacks)) {
              const promises = [];
              for (const item of multiPacks) {
                if (typeof item !== "string") {
                  continue;
                }
                let itemUrl = basePath + item;
                if (options.data?.ignoreMultiPack) {
                  continue;
                }
                itemUrl = copySearchParams2(itemUrl, options.src);
                promises.push(loader.load({
                  src: itemUrl,
                  data: {
                    ignoreMultiPack: true
                  }
                }));
              }
              const res = await Promise.all(promises);
              spritesheet.linkedSheets = res;
              res.forEach((item) => {
                item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
              });
            }
            return spritesheet;
          },
          async unload(spritesheet, _resolvedAsset, loader) {
            await loader.unload(spritesheet.textureSource._sourceOrigin);
            spritesheet.destroy(false);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/spritesheet/init.mjs
  var init_init4 = __esm({
    "node_modules/pixi-v8/lib/spritesheet/init.mjs"() {
      init_Extensions();
      init_spritesheetAsset2();
      extensions3.add(spritesheetAsset2);
    }
  });

  // node_modules/pixi-v8/lib/utils/data/updateQuadBounds.mjs
  function updateQuadBounds(bounds, anchor, texture, padding) {
    const { width, height } = texture.orig;
    const trim = texture.trim;
    if (trim) {
      const sourceWidth = trim.width;
      const sourceHeight = trim.height;
      bounds.minX = trim.x - anchor._x * width - padding;
      bounds.maxX = bounds.minX + sourceWidth;
      bounds.minY = trim.y - anchor._y * height - padding;
      bounds.maxY = bounds.minY + sourceHeight;
    } else {
      bounds.minX = -anchor._x * width - padding;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height - padding;
      bounds.maxY = bounds.minY + height;
    }
    return;
  }
  var init_updateQuadBounds = __esm({
    "node_modules/pixi-v8/lib/utils/data/updateQuadBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/view/View.mjs
  var ViewContainer;
  var init_View = __esm({
    "node_modules/pixi-v8/lib/scene/view/View.mjs"() {
      init_Bounds2();
      init_Container2();
      ViewContainer = class extends Container2 {
        constructor() {
          super(...arguments);
          this.canBundle = true;
          this.allowChildren = false;
          this._roundPixels = 0;
          this._lastUsed = 0;
          this._lastInstructionTick = -1;
          this._bounds = new Bounds2(0, 1, 0, 0);
          this._boundsDirty = true;
        }
        _updateBounds() {
        }
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(value) {
          this._roundPixels = value ? 1 : 0;
        }
        containsPoint(point) {
          const bounds = this.bounds;
          const { x: x2, y: y2 } = point;
          return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
        }
        destroy(options) {
          super.destroy(options);
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/Sprite.mjs
  var Sprite2;
  var init_Sprite2 = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/Sprite.mjs"() {
      init_ObservablePoint2();
      init_Texture2();
      init_updateQuadBounds();
      init_View();
      Sprite2 = class extends ViewContainer {
        constructor(options = Texture2.EMPTY) {
          if (options instanceof Texture2) {
            options = { texture: options };
          }
          const { texture = Texture2.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
          super({
            label: "Sprite",
            ...rest
          });
          this.renderPipeId = "sprite";
          this.batched = true;
          this._didSpriteUpdate = false;
          this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          this._sourceBoundsDirty = true;
          this._anchor = new ObservablePoint2(
            {
              _onUpdate: () => {
                this.onViewUpdate();
              }
            }
          );
          if (anchor) {
            this.anchor = anchor;
          } else if (texture.defaultAnchor) {
            this.anchor = texture.defaultAnchor;
          }
          this.texture = texture;
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
          if (width !== void 0)
            this.width = width;
          if (height !== void 0)
            this.height = height;
        }
        static from(source2, skipCache = false) {
          if (source2 instanceof Texture2) {
            return new Sprite2(source2);
          }
          return new Sprite2(Texture2.from(source2, skipCache));
        }
        set texture(value) {
          value || (value = Texture2.EMPTY);
          const currentTexture = this._texture;
          if (currentTexture === value)
            return;
          if (currentTexture && currentTexture.dynamic)
            currentTexture.off("update", this.onViewUpdate, this);
          if (value.dynamic)
            value.on("update", this.onViewUpdate, this);
          this._texture = value;
          if (this._width) {
            this._setWidth(this._width, this._texture.orig.width);
          }
          if (this._height) {
            this._setHeight(this._height, this._texture.orig.height);
          }
          this.onViewUpdate();
        }
        get texture() {
          return this._texture;
        }
        get bounds() {
          if (this._boundsDirty) {
            this._updateBounds();
            this._boundsDirty = false;
          }
          return this._bounds;
        }
        get sourceBounds() {
          if (this._sourceBoundsDirty) {
            this._updateSourceBounds();
            this._sourceBoundsDirty = false;
          }
          return this._sourceBounds;
        }
        containsPoint(point) {
          const bounds = this.sourceBounds;
          if (point.x >= bounds.maxX && point.x <= bounds.minX) {
            if (point.y >= bounds.maxY && point.y <= bounds.minY) {
              return true;
            }
          }
          return false;
        }
        addBounds(bounds) {
          const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;
          bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
        }
        onViewUpdate() {
          this._didViewChangeTick++;
          this._didSpriteUpdate = true;
          this._sourceBoundsDirty = this._boundsDirty = true;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        _updateBounds() {
          updateQuadBounds(this._bounds, this._anchor, this._texture, 0);
        }
        _updateSourceBounds() {
          const anchor = this._anchor;
          const texture = this._texture;
          const sourceBounds = this._sourceBounds;
          const { width, height } = texture.orig;
          sourceBounds.maxX = -anchor._x * width;
          sourceBounds.minX = sourceBounds.maxX + width;
          sourceBounds.maxY = -anchor._y * height;
          sourceBounds.minY = sourceBounds.maxY + height;
        }
        destroy(options = false) {
          super.destroy(options);
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            this._texture.destroy(destroyTextureSource);
          }
          this._texture = null;
          this._bounds = null;
          this._sourceBounds = null;
          this._anchor = null;
        }
        get anchor() {
          return this._anchor;
        }
        set anchor(value) {
          typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
        }
        get width() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }
        set width(value) {
          this._setWidth(value, this._texture.orig.width);
          this._width = value;
        }
        get height() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }
        set height(value) {
          this._setHeight(value, this._texture.orig.height);
          this._height = value;
        }
        getSize(out2) {
          out2 || (out2 = {});
          out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
          out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
          return out2;
        }
        setSize(value, height) {
          if (typeof value === "object") {
            height = value.height ?? value.width;
            value = value.width;
          } else {
            height ?? (height = value);
          }
          value !== void 0 && this._setWidth(value, this._texture.orig.width);
          height !== void 0 && this._setHeight(height, this._texture.orig.height);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/utils/addMaskBounds.mjs
  function addMaskBounds(mask, bounds, skipUpdateTransform) {
    const boundsToMask = tempBounds;
    mask.measurable = true;
    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
    bounds.addBoundsMask(boundsToMask);
    mask.measurable = false;
  }
  var tempBounds;
  var init_addMaskBounds = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/utils/addMaskBounds.mjs"() {
      init_Bounds2();
      init_getGlobalBounds();
      tempBounds = new Bounds2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/utils/addMaskLocalBounds.mjs
  function addMaskLocalBounds(mask, bounds, localRoot) {
    const boundsToMask = boundsPool.get();
    mask.measurable = true;
    const tempMatrix9 = matrixPool.get().identity();
    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix9);
    getLocalBounds(mask, boundsToMask, relativeMask);
    mask.measurable = false;
    bounds.addBoundsMask(boundsToMask);
    matrixPool.return(tempMatrix9);
    boundsPool.return(boundsToMask);
  }
  function getMatrixRelativeToParent(target, root, matrix) {
    if (!target) {
      warn("Mask bounds, renderable is not inside the root container");
      return matrix;
    }
    if (target !== root) {
      getMatrixRelativeToParent(target.parent, root, matrix);
      target.updateLocalTransform();
      matrix.append(target.localTransform);
    }
    return matrix;
  }
  var init_addMaskLocalBounds = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
      init_getLocalBounds();
      init_matrixAndBoundsPool();
      init_warn();
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMask.mjs
  var AlphaMask;
  var init_AlphaMask = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMask.mjs"() {
      init_Extensions();
      init_Sprite2();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      AlphaMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "alphaMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.renderMaskToTexture = !(mask instanceof Sprite2);
          this.mask.renderable = this.renderMaskToTexture;
          this.mask.includeInBuild = !this.renderMaskToTexture;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Sprite2;
        }
      };
      AlphaMask.extension = ExtensionType2.MaskEffect;
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/color/ColorMask.mjs
  var ColorMask;
  var init_ColorMask = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/color/ColorMask.mjs"() {
      init_Extensions();
      ColorMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "colorMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
        }
        destroy() {
        }
        static test(mask) {
          return typeof mask === "number";
        }
      };
      ColorMask.extension = ExtensionType2.MaskEffect;
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMask.mjs
  var StencilMask;
  var init_StencilMask = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMask.mjs"() {
      init_Extensions();
      init_Container2();
      init_addMaskBounds();
      init_addMaskLocalBounds();
      StencilMask = class {
        constructor(options) {
          this.priority = 0;
          this.pipe = "stencilMask";
          if (options?.mask) {
            this.init(options.mask);
          }
        }
        init(mask) {
          this.mask = mask;
          this.mask.includeInBuild = false;
          this.mask.measurable = false;
        }
        reset() {
          this.mask.measurable = true;
          this.mask.includeInBuild = true;
          this.mask = null;
        }
        addBounds(bounds, skipUpdateTransform) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
        addLocalBounds(bounds, localRoot) {
          addMaskLocalBounds(this.mask, bounds, localRoot);
        }
        containsPoint(point, hitTestFn) {
          const mask = this.mask;
          return hitTestFn(mask, point);
        }
        destroy() {
          this.reset();
        }
        static test(mask) {
          return mask instanceof Container2;
        }
      };
      StencilMask.extension = ExtensionType2.MaskEffect;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
  var CanvasSource;
  var init_CanvasSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
      init_adapter2();
      init_Extensions();
      init_TextureSource();
      CanvasSource = class extends TextureSource {
        constructor(options) {
          if (!options.resource) {
            options.resource = DOMAdapter.get().createCanvas();
          }
          if (!options.width) {
            options.width = options.resource.width;
            if (!options.autoDensity) {
              options.width /= options.resolution;
            }
          }
          if (!options.height) {
            options.height = options.resource.height;
            if (!options.autoDensity) {
              options.height /= options.resolution;
            }
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoDensity = options.autoDensity;
          const canvas = options.resource;
          if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {
            this.resizeCanvas();
          }
          this.transparent = !!options.transparent;
        }
        resizeCanvas() {
          if (this.autoDensity) {
            this.resource.style.width = `${this.width}px`;
            this.resource.style.height = `${this.height}px`;
          }
          if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
            this.resource.width = this.pixelWidth;
            this.resource.height = this.pixelHeight;
          }
        }
        resize(width = this.width, height = this.height, resolution = this._resolution) {
          const didResize = super.resize(width, height, resolution);
          if (didResize) {
            this.resizeCanvas();
          }
          return didResize;
        }
        static test(resource) {
          return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
        }
        get context2D() {
          return this._context2D || (this._context2D = this.resource.getContext("2d"));
        }
      };
      CanvasSource.extension = ExtensionType2.TextureSource;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
  var ImageSource;
  var init_ImageSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
      init_adapter2();
      init_Extensions();
      init_warn();
      init_TextureSource();
      ImageSource = class extends TextureSource {
        constructor(options) {
          if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {
            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);
            const context3 = canvas.getContext("2d");
            context3.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);
            options.resource = canvas;
            warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
          }
          super(options);
          this.uploadMethodId = "image";
          this.autoGarbageCollect = true;
        }
        static test(resource) {
          return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
        }
      };
      ImageSource.extension = ExtensionType2.TextureSource;
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/detectVideoAlphaMode.mjs
  async function detectVideoAlphaMode2() {
    promise2 ?? (promise2 = (async () => {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        return "premultiply-alpha-on-upload";
      }
      const video = await new Promise((resolve2) => {
        const video2 = document.createElement("video");
        video2.onloadeddata = () => resolve2(video2);
        video2.onerror = () => resolve2(null);
        video2.autoplay = false;
        video2.crossOrigin = "anonymous";
        video2.preload = "auto";
        video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
        video2.load();
      });
      if (!video) {
        return "premultiply-alpha-on-upload";
      }
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      );
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      const pixel = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
      gl.getExtension("WEBGL_lose_context")?.loseContext();
      return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })());
    return promise2;
  }
  var promise2;
  var init_detectVideoAlphaMode2 = __esm({
    "node_modules/pixi-v8/lib/utils/browser/detectVideoAlphaMode.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
  var _VideoSource, VideoSource;
  var init_VideoSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
      init_Extensions();
      init_Ticker2();
      init_detectVideoAlphaMode2();
      init_TextureSource();
      _VideoSource = class _VideoSource2 extends TextureSource {
        constructor(options) {
          super(options);
          this.isReady = false;
          this.uploadMethodId = "video";
          options = {
            ..._VideoSource2.defaultOptions,
            ...options
          };
          this._autoUpdate = true;
          this._isConnectedToTicker = false;
          this._updateFPS = options.updateFPS || 0;
          this._msToNextUpdate = 0;
          this.autoPlay = options.autoPlay !== false;
          this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
          this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
          this._videoFrameRequestCallbackHandle = null;
          this._load = null;
          this._resolve = null;
          this._reject = null;
          this._onCanPlay = this._onCanPlay.bind(this);
          this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
          this._onError = this._onError.bind(this);
          this._onPlayStart = this._onPlayStart.bind(this);
          this._onPlayStop = this._onPlayStop.bind(this);
          this._onSeeked = this._onSeeked.bind(this);
          if (options.autoLoad !== false) {
            void this.load();
          }
        }
        updateFrame() {
          if (this.destroyed) {
            return;
          }
          if (this._updateFPS) {
            const elapsedMS = Ticker2.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          }
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
          if (this.isValid) {
            this.update();
          }
        }
        _videoFrameRequestCallback() {
          this.updateFrame();
          if (this.destroyed) {
            this._videoFrameRequestCallbackHandle = null;
          } else {
            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            );
          }
        }
        get isValid() {
          return !!this.resource.videoWidth && !!this.resource.videoHeight;
        }
        async load() {
          if (this._load) {
            return this._load;
          }
          const source2 = this.resource;
          const options = this.options;
          if ((source2.readyState === source2.HAVE_ENOUGH_DATA || source2.readyState === source2.HAVE_FUTURE_DATA) && source2.width && source2.height) {
            source2.complete = true;
          }
          source2.addEventListener("play", this._onPlayStart);
          source2.addEventListener("pause", this._onPlayStop);
          source2.addEventListener("seeked", this._onSeeked);
          if (!this._isSourceReady()) {
            if (!options.preload) {
              source2.addEventListener("canplay", this._onCanPlay);
            }
            source2.addEventListener("canplaythrough", this._onCanPlayThrough);
            source2.addEventListener("error", this._onError, true);
          } else {
            this._mediaReady();
          }
          this.alphaMode = await detectVideoAlphaMode2();
          this._load = new Promise((resolve2, reject) => {
            if (this.isValid) {
              resolve2(this);
            } else {
              this._resolve = resolve2;
              this._reject = reject;
              if (options.preloadTimeoutMs !== void 0) {
                this._preloadTimeout = setTimeout(() => {
                  this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
                });
              }
              source2.load();
            }
          });
          return this._load;
        }
        _onError(event) {
          this.resource.removeEventListener("error", this._onError, true);
          this.emit("error", event);
          if (this._reject) {
            this._reject(event);
            this._reject = null;
            this._resolve = null;
          }
        }
        _isSourcePlaying() {
          const source2 = this.resource;
          return !source2.paused && !source2.ended;
        }
        _isSourceReady() {
          const source2 = this.resource;
          return source2.readyState > 2;
        }
        _onPlayStart() {
          if (!this.isValid) {
            this._mediaReady();
          }
          this._configureAutoUpdate();
        }
        _onPlayStop() {
          this._configureAutoUpdate();
        }
        _onSeeked() {
          if (this._autoUpdate && !this._isSourcePlaying()) {
            this._msToNextUpdate = 0;
            this.updateFrame();
            this._msToNextUpdate = 0;
          }
        }
        _onCanPlay() {
          const source2 = this.resource;
          source2.removeEventListener("canplay", this._onCanPlay);
          this._mediaReady();
        }
        _onCanPlayThrough() {
          const source2 = this.resource;
          source2.removeEventListener("canplaythrough", this._onCanPlay);
          if (this._preloadTimeout) {
            clearTimeout(this._preloadTimeout);
            this._preloadTimeout = void 0;
          }
          this._mediaReady();
        }
        _mediaReady() {
          const source2 = this.resource;
          if (this.isValid) {
            this.isReady = true;
            this.resize(source2.videoWidth, source2.videoHeight);
          }
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
          if (this._resolve) {
            this._resolve(this);
            this._resolve = null;
            this._reject = null;
          }
          if (this._isSourcePlaying()) {
            this._onPlayStart();
          } else if (this.autoPlay) {
            void this.resource.play();
          }
        }
        destroy() {
          this._configureAutoUpdate();
          const source2 = this.resource;
          if (source2) {
            source2.removeEventListener("play", this._onPlayStart);
            source2.removeEventListener("pause", this._onPlayStop);
            source2.removeEventListener("seeked", this._onSeeked);
            source2.removeEventListener("canplay", this._onCanPlay);
            source2.removeEventListener("canplaythrough", this._onCanPlayThrough);
            source2.removeEventListener("error", this._onError, true);
            source2.pause();
            source2.src = "";
            source2.load();
          }
          super.destroy();
        }
        get autoUpdate() {
          return this._autoUpdate;
        }
        set autoUpdate(value) {
          if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            this._configureAutoUpdate();
          }
        }
        get updateFPS() {
          return this._updateFPS;
        }
        set updateFPS(value) {
          if (value !== this._updateFPS) {
            this._updateFPS = value;
            this._configureAutoUpdate();
          }
        }
        _configureAutoUpdate() {
          if (this._autoUpdate && this._isSourcePlaying()) {
            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
              if (this._isConnectedToTicker) {
                Ticker2.shared.remove(this.updateFrame, this);
                this._isConnectedToTicker = false;
                this._msToNextUpdate = 0;
              }
              if (this._videoFrameRequestCallbackHandle === null) {
                this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                );
              }
            } else {
              if (this._videoFrameRequestCallbackHandle !== null) {
                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
                this._videoFrameRequestCallbackHandle = null;
              }
              if (!this._isConnectedToTicker) {
                Ticker2.shared.add(this.updateFrame, this);
                this._isConnectedToTicker = true;
                this._msToNextUpdate = 0;
              }
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (this._isConnectedToTicker) {
              Ticker2.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
          }
        }
        static test(resource) {
          return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
        }
      };
      _VideoSource.extension = ExtensionType2.TextureSource;
      _VideoSource.defaultOptions = {
        ...TextureSource.defaultOptions,
        autoLoad: true,
        autoPlay: true,
        updateFPS: 0,
        crossorigin: true,
        loop: false,
        muted: true,
        playsinline: true,
        preload: false
      };
      _VideoSource.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      VideoSource = _VideoSource;
    }
  });

  // node_modules/pixi-v8/lib/assets/cache/Cache.mjs
  var CacheClass2, Cache2;
  var init_Cache2 = __esm({
    "node_modules/pixi-v8/lib/assets/cache/Cache.mjs"() {
      init_warn();
      init_convertToList2();
      CacheClass2 = class {
        constructor() {
          this._parsers = [];
          this._cache = /* @__PURE__ */ new Map();
          this._cacheMap = /* @__PURE__ */ new Map();
        }
        reset() {
          this._cacheMap.clear();
          this._cache.clear();
        }
        has(key) {
          return this._cache.has(key);
        }
        get(key) {
          const result = this._cache.get(key);
          if (!result) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
          }
          return result;
        }
        set(key, value) {
          const keys = convertToList2(key);
          let cacheableAssets;
          for (let i2 = 0; i2 < this.parsers.length; i2++) {
            const parser = this.parsers[i2];
            if (parser.test(value)) {
              cacheableAssets = parser.getCacheableAssets(keys, value);
              break;
            }
          }
          const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
          if (!cacheableAssets) {
            keys.forEach((key2) => {
              cacheableMap.set(key2, value);
            });
          }
          const cacheKeys = [...cacheableMap.keys()];
          const cachedAssets = {
            cacheKeys,
            keys
          };
          keys.forEach((key2) => {
            this._cacheMap.set(key2, cachedAssets);
          });
          cacheKeys.forEach((key2) => {
            const val = cacheableAssets ? cacheableAssets[key2] : value;
            if (this._cache.has(key2) && this._cache.get(key2) !== val) {
              warn("[Cache] already has key:", key2);
            }
            this._cache.set(key2, cacheableMap.get(key2));
          });
        }
        remove(key) {
          if (!this._cacheMap.has(key)) {
            warn(`[Assets] Asset id ${key} was not found in the Cache`);
            return;
          }
          const cacheMap2 = this._cacheMap.get(key);
          const cacheKeys = cacheMap2.cacheKeys;
          cacheKeys.forEach((key2) => {
            this._cache.delete(key2);
          });
          cacheMap2.keys.forEach((key2) => {
            this._cacheMap.delete(key2);
          });
        }
        get parsers() {
          return this._parsers;
        }
      };
      Cache2 = new CacheClass2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
  function textureSourceFrom(options = {}) {
    const hasResource = options && options.resource;
    const res = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    for (let i2 = 0; i2 < sources.length; i2++) {
      const Source = sources[i2];
      if (Source.test(res)) {
        return new Source(opts);
      }
    }
    throw new Error(`Could not find a source type for resource: ${opts.resource}`);
  }
  function resourceToTexture(options = {}, skipCache = false) {
    const hasResource = options && options.resource;
    const resource = hasResource ? options.resource : options;
    const opts = hasResource ? options : { resource: options };
    if (!skipCache && Cache2.has(resource)) {
      return Cache2.get(resource);
    }
    const texture = new Texture2({ source: textureSourceFrom(opts) });
    texture.on("destroy", () => {
      if (Cache2.has(resource)) {
        Cache2.remove(resource);
      }
    });
    if (!skipCache) {
      Cache2.set(resource, texture);
    }
    return texture;
  }
  function textureFrom(id, skipCache = false) {
    if (typeof id === "string") {
      return Cache2.get(id);
    } else if (id instanceof TextureSource) {
      return new Texture2({ source: id });
    }
    return resourceToTexture(id, skipCache);
  }
  var sources;
  var init_textureFrom = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
      init_Cache2();
      init_Extensions();
      init_TextureSource();
      init_Texture2();
      sources = [];
      extensions3.handleByList(ExtensionType2.TextureSource, sources);
      Texture2.from = textureFrom;
      TextureSource.from = textureSourceFrom;
    }
  });

  // node_modules/pixi-v8/lib/rendering/init.mjs
  var init_init5 = __esm({
    "node_modules/pixi-v8/lib/rendering/init.mjs"() {
      init_Extensions();
      init_AlphaMask();
      init_ColorMask();
      init_StencilMask();
      init_BufferImageSource();
      init_CanvasSource();
      init_ImageSource();
      init_VideoSource();
      init_textureFrom();
      extensions3.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/BindGroup.mjs
  var BindGroup;
  var init_BindGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
      "use strict";
      BindGroup = class {
        constructor(resources) {
          this.resources = /* @__PURE__ */ Object.create(null);
          this._dirty = true;
          let index = 0;
          for (const i2 in resources) {
            const resource = resources[i2];
            this.setResource(resource, index++);
          }
          this._updateKey();
        }
        _updateKey() {
          if (!this._dirty)
            return;
          this._dirty = false;
          const keyParts = [];
          let index = 0;
          for (const i2 in this.resources) {
            keyParts[index++] = this.resources[i2]._resourceId;
          }
          this._key = keyParts.join("|");
        }
        setResource(resource, index) {
          const currentResource = this.resources[index];
          if (resource === currentResource)
            return;
          if (currentResource) {
            resource.off?.("change", this.onResourceChange, this);
          }
          resource.on?.("change", this.onResourceChange, this);
          this.resources[index] = resource;
          this._dirty = true;
        }
        getResource(index) {
          return this.resources[index];
        }
        _touch(tick) {
          const resources = this.resources;
          for (const i2 in resources) {
            resources[i2]._touched = tick;
          }
        }
        destroy() {
          const resources = this.resources;
          for (const i2 in resources) {
            const resource = resources[i2];
            resource.off?.("change", this.onResourceChange, this);
          }
          this.resources = null;
        }
        onResourceChange(resource) {
          this._dirty = true;
          if (resource.destroyed) {
            const resources = this.resources;
            for (const i2 in resources) {
              if (resources[i2] === resource) {
                resources[i2] = null;
              }
            }
          } else {
            this._updateKey();
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
  function getTestContext2() {
    if (!context2 || context2?.isContextLost()) {
      const canvas = DOMAdapter.get().createCanvas();
      context2 = canvas.getContext("webgl", {});
    }
    return context2;
  }
  var context2;
  var init_getTestContext2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
      init_adapter2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
  function generateIfTestSrc2(maxIfs) {
    let src = "";
    for (let i2 = 0; i2 < maxIfs; ++i2) {
      if (i2 > 0) {
        src += "\nelse ";
      }
      if (i2 < maxIfs - 1) {
        src += `if(test == ${i2}.0){}`;
      }
    }
    return src;
  }
  function checkMaxIfStatementsInShader2(maxIfs, gl) {
    if (maxIfs === 0) {
      throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    }
    const shader = gl.createShader(gl.FRAGMENT_SHADER);
    try {
      while (true) {
        const fragmentSrc = fragTemplate3.replace(/%forloop%/gi, generateIfTestSrc2(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
    } finally {
      gl.deleteShader(shader);
    }
    return maxIfs;
  }
  var fragTemplate3;
  var init_checkMaxIfStatementsInShader2 = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
      "use strict";
      fragTemplate3 = [
        "precision mediump float;",
        "void main(void){",
        "float test = 0.1;",
        "%forloop%",
        "gl_FragColor = vec4(0.0);",
        "}"
      ].join("\n");
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
  function getMaxTexturesPerBatch() {
    if (maxTexturesPerBatchCache)
      return maxTexturesPerBatchCache;
    const gl = getTestContext2();
    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    maxTexturesPerBatchCache = checkMaxIfStatementsInShader2(
      maxTexturesPerBatchCache,
      gl
    );
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return maxTexturesPerBatchCache;
  }
  var maxTexturesPerBatchCache;
  var init_maxRecommendedTextures2 = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
      init_getTestContext2();
      init_checkMaxIfStatementsInShader2();
      maxTexturesPerBatchCache = null;
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
  function getTextureBatchBindGroup(textures, size) {
    let uid4 = 2166136261;
    for (let i2 = 0; i2 < size; i2++) {
      uid4 ^= textures[i2].uid;
      uid4 = Math.imul(uid4, 16777619);
      uid4 >>>= 0;
    }
    return cachedGroups[uid4] || generateTextureBatchBindGroup(textures, size, uid4);
  }
  function generateTextureBatchBindGroup(textures, size, key) {
    const bindGroupResources = {};
    let bindIndex = 0;
    if (!maxTextures)
      maxTextures = getMaxTexturesPerBatch();
    for (let i2 = 0; i2 < maxTextures; i2++) {
      const texture = i2 < size ? textures[i2] : Texture2.EMPTY.source;
      bindGroupResources[bindIndex++] = texture.source;
      bindGroupResources[bindIndex++] = texture.style;
    }
    const bindGroup = new BindGroup(bindGroupResources);
    cachedGroups[key] = bindGroup;
    return bindGroup;
  }
  var cachedGroups, maxTextures;
  var init_getTextureBatchBindGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
      init_BindGroup();
      init_Texture2();
      init_maxRecommendedTextures2();
      cachedGroups = {};
      maxTextures = 0;
    }
  });

  // node_modules/pixi-v8/lib/utils/data/ViewableBuffer.mjs
  var ViewableBuffer2;
  var init_ViewableBuffer2 = __esm({
    "node_modules/pixi-v8/lib/utils/data/ViewableBuffer.mjs"() {
      "use strict";
      ViewableBuffer2 = class {
        constructor(sizeOrBuffer) {
          if (typeof sizeOrBuffer === "number") {
            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
          } else if (sizeOrBuffer instanceof Uint8Array) {
            this.rawBinaryData = sizeOrBuffer.buffer;
          } else {
            this.rawBinaryData = sizeOrBuffer;
          }
          this.uint32View = new Uint32Array(this.rawBinaryData);
          this.float32View = new Float32Array(this.rawBinaryData);
          this.size = this.rawBinaryData.byteLength;
        }
        get int8View() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        }
        get uint8View() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        }
        get int16View() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        }
        get int32View() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        }
        get float64View() {
          if (!this._float64Array) {
            this._float64Array = new Float64Array(this.rawBinaryData);
          }
          return this._float64Array;
        }
        get bigUint64View() {
          if (!this._bigUint64Array) {
            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
          }
          return this._bigUint64Array;
        }
        view(type) {
          return this[`${type}View`];
        }
        destroy() {
          this.rawBinaryData = null;
          this._int8View = null;
          this._uint8View = null;
          this._int16View = null;
          this.uint16View = null;
          this._int32View = null;
          this.uint32View = null;
          this.float32View = null;
        }
        static sizeOf(type) {
          switch (type) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(`${type} isn't a valid view type`);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
  function fastCopy(sourceBuffer, destinationBuffer) {
    const lengthDouble = sourceBuffer.byteLength / 8 | 0;
    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
    destinationFloat64View.set(sourceFloat64View);
    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
    if (remainingBytes > 0) {
      const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
      const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
      destinationUint8View.set(sourceUint8View);
    }
  }
  var init_fastCopy = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/state/const.mjs
  var BLEND_TO_NPM, STENCIL_MODES;
  var init_const9 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/state/const.mjs"() {
      "use strict";
      BLEND_TO_NPM = {
        normal: "normal-npm",
        add: "add-npm",
        screen: "screen-npm"
      };
      STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
        STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
        STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
        STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
        STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
        return STENCIL_MODES2;
      })(STENCIL_MODES || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
  function getAdjustedBlendModeBlend(blendMode, textureSource) {
    if (textureSource.alphaMode === "no-premultiply-alpha") {
      return BLEND_TO_NPM[blendMode] || blendMode;
    }
    return blendMode;
  }
  var init_getAdjustedBlendModeBlend = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
      init_const9();
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/BatchTextureArray.mjs
  var BatchTextureArray2;
  var init_BatchTextureArray2 = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
      "use strict";
      BatchTextureArray2 = class {
        constructor() {
          this.ids = /* @__PURE__ */ Object.create(null);
          this.textures = [];
          this.count = 0;
        }
        clear() {
          for (let i2 = 0; i2 < this.count; i2++) {
            const t2 = this.textures[i2];
            this.textures[i2] = null;
            this.ids[t2.uid] = null;
          }
          this.count = 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/Batcher.mjs
  function getBatchFromPool() {
    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
  }
  function returnBatchToPool(batch) {
    batchPool[batchPoolIndex++] = batch;
  }
  var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
  var init_Batcher = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/Batcher.mjs"() {
      init_uid2();
      init_ViewableBuffer2();
      init_fastCopy();
      init_getAdjustedBlendModeBlend();
      init_maxRecommendedTextures2();
      init_BatchTextureArray2();
      Batch = class {
        constructor() {
          this.renderPipeId = "batch";
          this.action = "startBatch";
          this.start = 0;
          this.size = 0;
          this.textures = new BatchTextureArray2();
          this.blendMode = "normal";
          this.canBundle = true;
        }
        destroy() {
          this.textures = null;
          this.gpuBindGroup = null;
          this.bindGroup = null;
          this.batcher = null;
        }
      };
      batchPool = [];
      batchPoolIndex = 0;
      BATCH_TICK = 0;
      _Batcher = class _Batcher2 {
        constructor(options = {}) {
          this.uid = uid2("batcher");
          this.dirty = true;
          this.batchIndex = 0;
          this.batches = [];
          this._elements = [];
          _Batcher2.defaultOptions.maxTextures = _Batcher2.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();
          options = { ..._Batcher2.defaultOptions, ...options };
          const { maxTextures: maxTextures2, attributesInitialSize, indicesInitialSize } = options;
          this.attributeBuffer = new ViewableBuffer2(attributesInitialSize * 4);
          this.indexBuffer = new Uint16Array(indicesInitialSize);
          this.maxTextures = maxTextures2;
        }
        begin() {
          this.elementSize = 0;
          this.elementStart = 0;
          this.indexSize = 0;
          this.attributeSize = 0;
          for (let i2 = 0; i2 < this.batchIndex; i2++) {
            returnBatchToPool(this.batches[i2]);
          }
          this.batchIndex = 0;
          this._batchIndexStart = 0;
          this._batchIndexSize = 0;
          this.dirty = true;
        }
        add(batchableObject) {
          this._elements[this.elementSize++] = batchableObject;
          batchableObject._indexStart = this.indexSize;
          batchableObject._attributeStart = this.attributeSize;
          batchableObject._batcher = this;
          this.indexSize += batchableObject.indexSize;
          this.attributeSize += batchableObject.attributeSize * this.vertexSize;
        }
        checkAndUpdateTexture(batchableObject, texture) {
          const textureId = batchableObject._batch.textures.ids[texture._source.uid];
          if (!textureId && textureId !== 0)
            return false;
          batchableObject._textureId = textureId;
          batchableObject.texture = texture;
          return true;
        }
        updateElement(batchableObject) {
          this.dirty = true;
          const attributeBuffer = this.attributeBuffer;
          if (batchableObject.packAsQuad) {
            this.packQuadAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          } else {
            this.packAttributes(
              batchableObject,
              attributeBuffer.float32View,
              attributeBuffer.uint32View,
              batchableObject._attributeStart,
              batchableObject._textureId
            );
          }
        }
        break(instructionSet) {
          const elements = this._elements;
          if (!elements[this.elementStart])
            return;
          let batch = getBatchFromPool();
          let textureBatch = batch.textures;
          textureBatch.clear();
          const firstElement = elements[this.elementStart];
          let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
          if (this.attributeSize * 4 > this.attributeBuffer.size) {
            this._resizeAttributeBuffer(this.attributeSize * 4);
          }
          if (this.indexSize > this.indexBuffer.length) {
            this._resizeIndexBuffer(this.indexSize);
          }
          const f32 = this.attributeBuffer.float32View;
          const u32 = this.attributeBuffer.uint32View;
          const indexBuffer = this.indexBuffer;
          let size = this._batchIndexSize;
          let start = this._batchIndexStart;
          let action = "startBatch";
          const maxTextures2 = this.maxTextures;
          for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
            const element = elements[i2];
            elements[i2] = null;
            const texture = element.texture;
            const source2 = texture._source;
            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source2);
            const breakRequired = blendMode !== adjustedBlendMode;
            if (source2._batchTick === BATCH_TICK && !breakRequired) {
              element._textureId = source2._textureBindLocation;
              size += element.indexSize;
              if (element.packAsQuad) {
                this.packQuadAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packQuadIndex(
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              } else {
                this.packAttributes(
                  element,
                  f32,
                  u32,
                  element._attributeStart,
                  element._textureId
                );
                this.packIndex(
                  element,
                  indexBuffer,
                  element._indexStart,
                  element._attributeStart / this.vertexSize
                );
              }
              element._batch = batch;
              continue;
            }
            source2._batchTick = BATCH_TICK;
            if (textureBatch.count >= maxTextures2 || breakRequired) {
              this._finishBatch(
                batch,
                start,
                size - start,
                textureBatch,
                blendMode,
                instructionSet,
                action
              );
              action = "renderBatch";
              start = size;
              blendMode = adjustedBlendMode;
              batch = getBatchFromPool();
              textureBatch = batch.textures;
              textureBatch.clear();
              ++BATCH_TICK;
            }
            element._textureId = source2._textureBindLocation = textureBatch.count;
            textureBatch.ids[source2.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source2;
            element._batch = batch;
            size += element.indexSize;
            if (element.packAsQuad) {
              this.packQuadAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packQuadIndex(
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            } else {
              this.packAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packIndex(
                element,
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            }
          }
          if (textureBatch.count > 0) {
            this._finishBatch(
              batch,
              start,
              size - start,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            start = size;
            ++BATCH_TICK;
          }
          this.elementStart = this.elementSize;
          this._batchIndexStart = start;
          this._batchIndexSize = size;
        }
        _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
          batch.gpuBindGroup = null;
          batch.bindGroup = null;
          batch.action = action;
          batch.batcher = this;
          batch.textures = textureBatch;
          batch.blendMode = blendMode;
          batch.start = indexStart;
          batch.size = indexSize;
          ++BATCH_TICK;
          this.batches[this.batchIndex++] = batch;
          instructionSet.add(batch);
        }
        finish(instructionSet) {
          this.break(instructionSet);
        }
        ensureAttributeBuffer(size) {
          if (size * 4 <= this.attributeBuffer.size)
            return;
          this._resizeAttributeBuffer(size * 4);
        }
        ensureIndexBuffer(size) {
          if (size <= this.indexBuffer.length)
            return;
          this._resizeIndexBuffer(size);
        }
        _resizeAttributeBuffer(size) {
          const newSize = Math.max(size, this.attributeBuffer.size * 2);
          const newArrayBuffer = new ViewableBuffer2(newSize);
          fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
          this.attributeBuffer = newArrayBuffer;
        }
        _resizeIndexBuffer(size) {
          const indexBuffer = this.indexBuffer;
          let newSize = Math.max(size, indexBuffer.length * 1.5);
          newSize += newSize % 2;
          const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
          if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
            for (let i2 = 0; i2 < indexBuffer.length; i2++) {
              newIndexBuffer[i2] = indexBuffer[i2];
            }
          } else {
            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
          }
          this.indexBuffer = newIndexBuffer;
        }
        packQuadIndex(indexBuffer, index, indicesOffset) {
          indexBuffer[index] = indicesOffset + 0;
          indexBuffer[index + 1] = indicesOffset + 1;
          indexBuffer[index + 2] = indicesOffset + 2;
          indexBuffer[index + 3] = indicesOffset + 0;
          indexBuffer[index + 4] = indicesOffset + 2;
          indexBuffer[index + 5] = indicesOffset + 3;
        }
        packIndex(element, indexBuffer, index, indicesOffset) {
          const indices2 = element.indices;
          const size = element.indexSize;
          const indexOffset = element.indexOffset;
          const attributeOffset = element.attributeOffset;
          for (let i2 = 0; i2 < size; i2++) {
            indexBuffer[index++] = indicesOffset + indices2[i2 + indexOffset] - attributeOffset;
          }
        }
        destroy() {
          for (let i2 = 0; i2 < this.batches.length; i2++) {
            returnBatchToPool(this.batches[i2]);
          }
          this.batches = null;
          for (let i2 = 0; i2 < this._elements.length; i2++) {
            this._elements[i2]._batch = null;
          }
          this._elements = null;
          this.indexBuffer = null;
          this.attributeBuffer.destroy();
          this.attributeBuffer = null;
        }
      };
      _Batcher.defaultOptions = {
        maxTextures: null,
        attributesInitialSize: 4,
        indicesInitialSize: 6
      };
      Batcher = _Batcher;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/const.mjs
  var BufferUsage;
  var init_const10 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/const.mjs"() {
      "use strict";
      BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
        BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
        BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
        BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
        BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
        BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
        BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
        BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
        BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
        BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
        BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
        BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
        return BufferUsage2;
      })(BufferUsage || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/Buffer.mjs
  var Buffer3;
  var init_Buffer2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
      init_eventemitter3();
      init_uid2();
      init_const10();
      Buffer3 = class extends eventemitter3_default {
        constructor(options) {
          let { data, size } = options;
          const { usage, label, shrinkToFit } = options;
          super();
          this.uid = uid2("buffer");
          this._resourceType = "buffer";
          this._resourceId = uid2("resource");
          this._touched = 0;
          this._updateID = 1;
          this.shrinkToFit = true;
          this.destroyed = false;
          if (data instanceof Array) {
            data = new Float32Array(data);
          }
          this._data = data;
          size = size ?? data?.byteLength;
          const mappedAtCreation = !!data;
          this.descriptor = {
            size,
            usage,
            mappedAtCreation,
            label
          };
          this.shrinkToFit = shrinkToFit ?? true;
        }
        get data() {
          return this._data;
        }
        set data(value) {
          this.setDataWithSize(value, value.length, true);
        }
        get static() {
          return !!(this.descriptor.usage & BufferUsage.STATIC);
        }
        set static(value) {
          if (value) {
            this.descriptor.usage |= BufferUsage.STATIC;
          } else {
            this.descriptor.usage &= ~BufferUsage.STATIC;
          }
        }
        setDataWithSize(value, size, syncGPU) {
          this._updateID++;
          this._updateSize = size * value.BYTES_PER_ELEMENT;
          if (this._data === value) {
            if (syncGPU)
              this.emit("update", this);
            return;
          }
          const oldData = this._data;
          this._data = value;
          if (oldData.length !== value.length) {
            if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {
              if (syncGPU)
                this.emit("update", this);
            } else {
              this.descriptor.size = value.byteLength;
              this._resourceId = uid2("resource");
              this.emit("change", this);
            }
            return;
          }
          if (syncGPU)
            this.emit("update", this);
        }
        update(sizeInBytes) {
          this._updateSize = sizeInBytes ?? this._updateSize;
          this._updateID++;
          this.emit("update", this);
        }
        destroy() {
          this.destroyed = true;
          this.emit("destroy", this);
          this.emit("change", this);
          this._data = null;
          this.descriptor = null;
          this.removeAllListeners();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
  function ensureIsBuffer(buffer, index) {
    if (!(buffer instanceof Buffer3)) {
      let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
      if (buffer instanceof Array) {
        if (index) {
          buffer = new Uint32Array(buffer);
          usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
        } else {
          buffer = new Float32Array(buffer);
          usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
        }
      }
      buffer = new Buffer3({
        data: buffer,
        label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage
      });
    }
    return buffer;
  }
  var init_ensureIsBuffer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
      init_Buffer2();
      init_const10();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
  function getGeometryBounds(geometry, attributeId, bounds) {
    const attribute = geometry.getAttribute(attributeId);
    if (!attribute) {
      bounds.minX = 0;
      bounds.minY = 0;
      bounds.maxX = 0;
      bounds.maxY = 0;
      return bounds;
    }
    const data = attribute.buffer.data;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    const byteSize = data.BYTES_PER_ELEMENT;
    const offset = (attribute.offset || 0) / byteSize;
    const stride = (attribute.stride || 2 * 4) / byteSize;
    for (let i2 = offset; i2 < data.length; i2 += stride) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
    }
    bounds.minX = minX;
    bounds.minY = minY;
    bounds.maxX = maxX;
    bounds.maxY = maxY;
    return bounds;
  }
  var init_getGeometryBounds = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/Geometry.mjs
  function ensureIsAttribute(attribute) {
    if (attribute instanceof Buffer3 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
      attribute = {
        buffer: attribute
      };
    }
    attribute.buffer = ensureIsBuffer(attribute.buffer, false);
    return attribute;
  }
  var Geometry2;
  var init_Geometry2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
      init_eventemitter3();
      init_Bounds2();
      init_uid2();
      init_Buffer2();
      init_ensureIsBuffer();
      init_getGeometryBounds();
      Geometry2 = class extends eventemitter3_default {
        constructor(options) {
          const { attributes, indexBuffer, topology } = options;
          super();
          this.uid = uid2("geometry");
          this._layoutKey = 0;
          this.instanceCount = 1;
          this._bounds = new Bounds2();
          this._boundsDirty = true;
          this.attributes = attributes;
          this.buffers = [];
          this.instanceCount = options.instanceCount || 1;
          for (const i2 in attributes) {
            const attribute = attributes[i2] = ensureIsAttribute(attributes[i2]);
            const bufferIndex = this.buffers.indexOf(attribute.buffer);
            if (bufferIndex === -1) {
              this.buffers.push(attribute.buffer);
              attribute.buffer.on("update", this.onBufferUpdate, this);
              attribute.buffer.on("change", this.onBufferUpdate, this);
            }
          }
          if (indexBuffer) {
            this.indexBuffer = ensureIsBuffer(indexBuffer, true);
            this.buffers.push(this.indexBuffer);
          }
          this.topology = topology || "triangle-list";
        }
        onBufferUpdate() {
          this._boundsDirty = true;
          this.emit("update", this);
        }
        getAttribute(id) {
          return this.attributes[id];
        }
        getIndex() {
          return this.indexBuffer;
        }
        getBuffer(id) {
          return this.getAttribute(id).buffer;
        }
        getSize() {
          for (const i2 in this.attributes) {
            const attribute = this.attributes[i2];
            const buffer = attribute.buffer;
            return buffer.data.length / (attribute.stride / 4 || attribute.size);
          }
          return 0;
        }
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          this._boundsDirty = false;
          return getGeometryBounds(this, "aPosition", this._bounds);
        }
        destroy(destroyBuffers = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          if (destroyBuffers) {
            this.buffers.forEach((buffer) => buffer.destroy());
          }
          this.attributes = null;
          this.buffers = null;
          this.indexBuffer = null;
          this._bounds = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/BatchGeometry.mjs
  var placeHolderBufferData, placeHolderIndexData, BatchGeometry2;
  var init_BatchGeometry2 = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
      init_Buffer2();
      init_const10();
      init_Geometry2();
      placeHolderBufferData = new Float32Array(1);
      placeHolderIndexData = new Uint32Array(1);
      BatchGeometry2 = class extends Geometry2 {
        constructor() {
          const vertexSize = 6;
          const attributeBuffer = new Buffer3({
            data: placeHolderBufferData,
            label: "attribute-batch-buffer",
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
            shrinkToFit: false
          });
          const indexBuffer = new Buffer3({
            data: placeHolderIndexData,
            label: "index-batch-buffer",
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
            shrinkToFit: false
          });
          const stride = vertexSize * 4;
          super({
            attributes: {
              aPosition: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 0
              },
              aUV: {
                buffer: attributeBuffer,
                format: "float32x2",
                stride,
                offset: 2 * 4
              },
              aColor: {
                buffer: attributeBuffer,
                format: "unorm8x4",
                stride,
                offset: 4 * 4
              },
              aTextureIdAndRound: {
                buffer: attributeBuffer,
                format: "uint16x2",
                stride,
                offset: 5 * 4
              }
            },
            indexBuffer
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/utils/createIdFromString.mjs
  function createIdFromString(value, groupId) {
    let id = idHash2[value];
    if (id === void 0) {
      if (idCounts[groupId] === void 0) {
        idCounts[groupId] = 1;
      }
      idHash2[value] = id = idCounts[groupId]++;
    }
    return id;
  }
  var idCounts, idHash2;
  var init_createIdFromString = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
      "use strict";
      idCounts = /* @__PURE__ */ Object.create(null);
      idHash2 = /* @__PURE__ */ Object.create(null);
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
  function getMaxFragmentPrecision2() {
    if (!maxFragmentPrecision2) {
      maxFragmentPrecision2 = "mediump";
      const gl = getTestContext2();
      if (gl) {
        if (gl.getShaderPrecisionFormat) {
          const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
          maxFragmentPrecision2 = shaderFragment.precision ? "highp" : "mediump";
        }
      }
    }
    return maxFragmentPrecision2;
  }
  var maxFragmentPrecision2;
  var init_getMaxFragmentPrecision2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
      init_getTestContext2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
  function addProgramDefines(src, isES300, isFragment) {
    if (isES300)
      return src;
    if (isFragment) {
      src = src.replace("out vec4 finalColor;", "");
      return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
    }
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
  }
  var init_addProgramDefines = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
  function ensurePrecision(src, options, isFragment) {
    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
    if (src.substring(0, 9) !== "precision") {
      let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
      if (precision === "highp" && maxSupportedPrecision !== "highp") {
        precision = "mediump";
      }
      return `precision ${precision} float;
${src}`;
    } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
      return src.replace("precision highp", "precision mediump");
    }
    return src;
  }
  var init_ensurePrecision = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
  function insertVersion(src, isES300) {
    if (!isES300)
      return src;
    return `#version 300 es
${src}`;
  }
  var init_insertVersion = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
  function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
    name = name.replace(/\s+/g, "-");
    name += isFragment ? "-fragment" : "-vertex";
    const nameCache2 = isFragment ? fragmentNameCache : VertexNameCache;
    if (nameCache2[name]) {
      nameCache2[name]++;
      name += `-${nameCache2[name]}`;
    } else {
      nameCache2[name] = 1;
    }
    if (src.indexOf("#define SHADER_NAME") !== -1)
      return src;
    const shaderName = `#define SHADER_NAME ${name}`;
    return `${shaderName}
${src}`;
  }
  var fragmentNameCache, VertexNameCache;
  var init_setProgramName = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
      "use strict";
      fragmentNameCache = {};
      VertexNameCache = {};
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
  function stripVersion(src, isES300) {
    if (!isES300)
      return src;
    return src.replace("#version 300 es", "");
  }
  var init_stripVersion = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgram.mjs
  var processes, programCache, _GlProgram, GlProgram;
  var init_GlProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
      init_createIdFromString();
      init_getMaxFragmentPrecision2();
      init_addProgramDefines();
      init_ensurePrecision();
      init_insertVersion();
      init_setProgramName();
      init_stripVersion();
      processes = {
        stripVersion,
        ensurePrecision,
        addProgramDefines,
        setProgramName,
        insertVersion
      };
      programCache = /* @__PURE__ */ Object.create(null);
      _GlProgram = class _GlProgram2 {
        constructor(options) {
          options = { ..._GlProgram2.defaultOptions, ...options };
          const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
          const preprocessorOptions = {
            stripVersion: isES300,
            ensurePrecision: {
              requestedFragmentPrecision: options.preferredFragmentPrecision,
              requestedVertexPrecision: options.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: getMaxFragmentPrecision2()
            },
            setProgramName: {
              name: options.name
            },
            addProgramDefines: isES300,
            insertVersion: isES300
          };
          let fragment10 = options.fragment;
          let vertex7 = options.vertex;
          Object.keys(processes).forEach((processKey) => {
            const processOptions = preprocessorOptions[processKey];
            fragment10 = processes[processKey](fragment10, processOptions, true);
            vertex7 = processes[processKey](vertex7, processOptions, false);
          });
          this.fragment = fragment10;
          this.vertex = vertex7;
          this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
        }
        destroy() {
          this.fragment = null;
          this.vertex = null;
          this._attributeData = null;
          this._uniformData = null;
          this._uniformBlockData = null;
          this.transformFeedbackVaryings = null;
        }
        static from(options) {
          const key = `${options.vertex}:${options.fragment}`;
          if (!programCache[key]) {
            programCache[key] = new _GlProgram2(options);
          }
          return programCache[key];
        }
      };
      _GlProgram.defaultOptions = {
        preferredVertexPrecision: "highp",
        preferredFragmentPrecision: "mediump"
      };
      GlProgram = _GlProgram;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
  function getAttributeInfoFromFormat(format2) {
    return attributeFormatData[format2] ?? attributeFormatData.float32;
  }
  var attributeFormatData;
  var init_getAttributeInfoFromFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
      "use strict";
      attributeFormatData = {
        uint8x2: { size: 2, stride: 2, normalised: false },
        uint8x4: { size: 4, stride: 4, normalised: false },
        sint8x2: { size: 2, stride: 2, normalised: false },
        sint8x4: { size: 4, stride: 4, normalised: false },
        unorm8x2: { size: 2, stride: 2, normalised: true },
        unorm8x4: { size: 4, stride: 4, normalised: true },
        snorm8x2: { size: 2, stride: 2, normalised: true },
        snorm8x4: { size: 4, stride: 4, normalised: true },
        uint16x2: { size: 2, stride: 4, normalised: false },
        uint16x4: { size: 4, stride: 8, normalised: false },
        sint16x2: { size: 2, stride: 4, normalised: false },
        sint16x4: { size: 4, stride: 8, normalised: false },
        unorm16x2: { size: 2, stride: 4, normalised: true },
        unorm16x4: { size: 4, stride: 8, normalised: true },
        snorm16x2: { size: 2, stride: 4, normalised: true },
        snorm16x4: { size: 4, stride: 8, normalised: true },
        float16x2: { size: 2, stride: 4, normalised: false },
        float16x4: { size: 4, stride: 8, normalised: false },
        float32: { size: 1, stride: 4, normalised: false },
        float32x2: { size: 2, stride: 8, normalised: false },
        float32x3: { size: 3, stride: 12, normalised: false },
        float32x4: { size: 4, stride: 16, normalised: false },
        uint32: { size: 1, stride: 4, normalised: false },
        uint32x2: { size: 2, stride: 8, normalised: false },
        uint32x3: { size: 3, stride: 12, normalised: false },
        uint32x4: { size: 4, stride: 16, normalised: false },
        sint32: { size: 1, stride: 4, normalised: false },
        sint32x2: { size: 2, stride: 8, normalised: false },
        sint32x3: { size: 3, stride: 12, normalised: false },
        sint32x4: { size: 4, stride: 16, normalised: false }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
  function extractAttributesFromGpuProgram({ source: source2, entryPoint }) {
    const results = {};
    const mainVertStart = source2.indexOf(`fn ${entryPoint}`);
    if (mainVertStart !== -1) {
      const arrowFunctionStart = source2.indexOf("->", mainVertStart);
      if (arrowFunctionStart !== -1) {
        const functionArgsSubstring = source2.substring(mainVertStart, arrowFunctionStart);
        const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let match;
        while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
          const format2 = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
          results[match[2]] = {
            location: parseInt(match[1], 10),
            format: format2,
            stride: getAttributeInfoFromFormat(format2).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return results;
  }
  var WGSL_TO_VERTEX_TYPES;
  var init_extractAttributesFromGpuProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      WGSL_TO_VERTEX_TYPES = {
        f32: "float32",
        "vec2<f32>": "float32x2",
        "vec3<f32>": "float32x3",
        "vec4<f32>": "float32x4",
        vec2f: "float32x2",
        vec3f: "float32x3",
        vec4f: "float32x4",
        i32: "sint32",
        "vec2<i32>": "sint32x2",
        "vec3<i32>": "sint32x3",
        "vec4<i32>": "sint32x4",
        u32: "uint32",
        "vec2<u32>": "uint32x2",
        "vec3<u32>": "uint32x3",
        "vec4<u32>": "uint32x4",
        bool: "uint32",
        "vec2<bool>": "uint32x2",
        "vec3<bool>": "uint32x3",
        "vec4<bool>": "uint32x4"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
  function extractStructAndGroups(wgsl) {
    const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
    const groupPattern = /@group\((\d+)\)/;
    const bindingPattern = /@binding\((\d+)\)/;
    const namePattern = /var(<[^>]+>)? (\w+)/;
    const typePattern = /:\s*(\w+)/;
    const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
    const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
    const structName = /struct\s+(\w+)/;
    const groups = wgsl.match(linePattern)?.map((item) => ({
      group: parseInt(item.match(groupPattern)[1], 10),
      binding: parseInt(item.match(bindingPattern)[1], 10),
      name: item.match(namePattern)[2],
      isUniform: item.match(namePattern)[1] === "<uniform>",
      type: item.match(typePattern)[1]
    }));
    if (!groups) {
      return {
        groups: [],
        structs: []
      };
    }
    const structs = wgsl.match(structPattern)?.map((struct) => {
      const name = struct.match(structName)[1];
      const members = struct.match(structMemberPattern).reduce((acc, member) => {
        const [name2, type] = member.split(":");
        acc[name2.trim()] = type.trim();
        return acc;
      }, {});
      if (!members) {
        return null;
      }
      return { name, members };
    }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
    return {
      groups,
      structs
    };
  }
  var init_extractStructAndGroups = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/const.mjs
  var ShaderStage;
  var init_const11 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/const.mjs"() {
      "use strict";
      ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
        ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
        ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
        ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
        return ShaderStage2;
      })(ShaderStage || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
  function generateGpuLayoutGroups({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = [];
      }
      if (group.isUniform) {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
          buffer: {
            type: "uniform"
          }
        });
      } else if (group.type === "sampler") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          sampler: {
            type: "filtering"
          }
        });
      } else if (group.type === "texture_2d") {
        layout[group.group].push({
          binding: group.binding,
          visibility: ShaderStage.FRAGMENT,
          texture: {
            sampleType: "float",
            viewDimension: "2d",
            multisampled: false
          }
        });
      }
    }
    return layout;
  }
  var init_generateGpuLayoutGroups = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
      init_const11();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
  function generateLayoutHash({ groups }) {
    const layout = [];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      if (!layout[group.group]) {
        layout[group.group] = {};
      }
      layout[group.group][group.name] = group.binding;
    }
    return layout;
  }
  var init_generateLayoutHash = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
  function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
    const structNameSet = /* @__PURE__ */ new Set();
    const dupeGroupKeySet = /* @__PURE__ */ new Set();
    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
      if (structNameSet.has(struct.name)) {
        return false;
      }
      structNameSet.add(struct.name);
      return true;
    });
    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
      const key = `${group.name}-${group.binding}`;
      if (dupeGroupKeySet.has(key)) {
        return false;
      }
      dupeGroupKeySet.add(key);
      return true;
    });
    return { structs, groups };
  }
  var init_removeStructAndGroupDuplicates = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
  var programCache2, GpuProgram;
  var init_GpuProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
      init_createIdFromString();
      init_extractAttributesFromGpuProgram();
      init_extractStructAndGroups();
      init_generateGpuLayoutGroups();
      init_generateLayoutHash();
      init_removeStructAndGroupDuplicates();
      programCache2 = /* @__PURE__ */ Object.create(null);
      GpuProgram = class {
        constructor(options) {
          this._layoutKey = 0;
          this._attributeLocationsKey = 0;
          const { fragment: fragment10, vertex: vertex7, layout, gpuLayout, name } = options;
          this.name = name;
          this.fragment = fragment10;
          this.vertex = vertex7;
          if (fragment10.source === vertex7.source) {
            const structsAndGroups = extractStructAndGroups(fragment10.source);
            this.structsAndGroups = structsAndGroups;
          } else {
            const vertexStructsAndGroups = extractStructAndGroups(vertex7.source);
            const fragmentStructsAndGroups = extractStructAndGroups(fragment10.source);
            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
          }
          this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
          this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
          this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
          this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
          this._generateProgramKey();
        }
        _generateProgramKey() {
          const { vertex: vertex7, fragment: fragment10 } = this;
          const bigKey = vertex7.source + fragment10.source + vertex7.entryPoint + fragment10.entryPoint;
          this._layoutKey = createIdFromString(bigKey, "program");
        }
        get attributeData() {
          this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
          return this._attributeData;
        }
        destroy() {
          this.gpuLayout = null;
          this.layout = null;
          this.structsAndGroups = null;
          this.fragment = null;
          this.vertex = null;
        }
        static from(options) {
          const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
          if (!programCache2[key]) {
            programCache2[key] = new GpuProgram(options);
          }
          return programCache2[key];
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/addBits.mjs
  function addBits(srcParts, parts, name) {
    if (srcParts) {
      for (const i2 in srcParts) {
        const id = i2.toLocaleLowerCase();
        const part = parts[id];
        if (part) {
          let sanitisedPart = srcParts[i2];
          if (i2 === "header") {
            sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
          }
          if (name) {
            part.push(`//----${name}----//`);
          }
          part.push(sanitisedPart);
        } else {
          warn(`${i2} placement hook does not exist in shader`);
        }
      }
    }
  }
  var init_addBits = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
      init_warn();
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
  function compileHooks(programSrc) {
    const parts = {};
    const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
    partMatches.forEach((hook) => {
      parts[hook] = [];
    });
    return parts;
  }
  var findHooksRx;
  var init_compileHooks = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
      "use strict";
      findHooksRx = /\{\{(.*?)\}\}/g;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
  function extractInputs(fragmentSource, out2) {
    let match;
    const regex = /@in\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function compileInputs(fragments, template, sort = false) {
    const results = [];
    extractInputs(template, results);
    fragments.forEach((fragment10) => {
      if (fragment10.header) {
        extractInputs(fragment10.header, results);
      }
    });
    const mainInput = results;
    if (sort) {
      mainInput.sort();
    }
    const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
    let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
    cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
    return cleanedString;
  }
  var init_compileInputs = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
  function extractOutputs(fragmentSource, out2) {
    let match;
    const regex = /@out\s+([^;]+);/g;
    while ((match = regex.exec(fragmentSource)) !== null) {
      out2.push(match[1]);
    }
  }
  function extractVariableName(value) {
    const regex = /\b(\w+)\s*:/g;
    const match = regex.exec(value);
    return match ? match[1] : "";
  }
  function stripVariable(value) {
    const regex = /@.*?\s+/g;
    return value.replace(regex, "");
  }
  function compileOutputs(fragments, template) {
    const results = [];
    extractOutputs(template, results);
    fragments.forEach((fragment10) => {
      if (fragment10.header) {
        extractOutputs(fragment10.header, results);
      }
    });
    let index = 0;
    const mainStruct = results.sort().map((inValue) => {
      if (inValue.indexOf("builtin") > -1) {
        return inValue;
      }
      return `@location(${index++}) ${inValue}`;
    }).join(",\n");
    const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
    const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
    let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
    compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
    compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
    compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
    return compiledCode;
  }
  var init_compileOutputs = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/injectBits.mjs
  function injectBits(templateSrc, fragmentParts) {
    let out2 = templateSrc;
    for (const i2 in fragmentParts) {
      const parts = fragmentParts[i2];
      const toInject = parts.join("\n");
      if (toInject.length) {
        out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
      } else {
        out2 = out2.replace(`{{${i2}}}`, "");
      }
    }
    return out2;
  }
  var init_injectBits = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compiler/compileHighShader.mjs
  function compileHighShader({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    const { vertex: vertex7, fragment: fragment10 } = compileInputsAndOutputs(template, bits);
    cacheMap[cacheId] = compileBits(vertex7, fragment10, bits);
    return cacheMap[cacheId];
  }
  function compileHighShaderGl({
    template,
    bits
  }) {
    const cacheId = generateCacheId(template, bits);
    if (cacheMap[cacheId])
      return cacheMap[cacheId];
    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
    return cacheMap[cacheId];
  }
  function compileInputsAndOutputs(template, bits) {
    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
    compiledVertex = compileOutputs(vertexFragments, compiledVertex);
    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
    return {
      vertex: compiledVertex,
      fragment: compiledFragment
    };
  }
  function generateCacheId(template, bits) {
    return bits.map((highFragment) => {
      if (!bitCacheMap.has(highFragment)) {
        bitCacheMap.set(highFragment, CACHE_UID++);
      }
      return bitCacheMap.get(highFragment);
    }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
  }
  function compileBits(vertex7, fragment10, bits) {
    const vertexParts = compileHooks(vertex7);
    const fragmentParts = compileHooks(fragment10);
    bits.forEach((shaderBit) => {
      addBits(shaderBit.vertex, vertexParts, shaderBit.name);
      addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
    });
    return {
      vertex: injectBits(vertex7, vertexParts),
      fragment: injectBits(fragment10, fragmentParts)
    };
  }
  var cacheMap, bitCacheMap, CACHE_UID;
  var init_compileHighShader = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
      init_addBits();
      init_compileHooks();
      init_compileInputs();
      init_compileOutputs();
      init_injectBits();
      cacheMap = /* @__PURE__ */ Object.create(null);
      bitCacheMap = /* @__PURE__ */ new Map();
      CACHE_UID = 0;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/defaultProgramTemplate.mjs
  var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
  var init_defaultProgramTemplate = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
      "use strict";
      vertexGPUTemplate = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
      fragmentGPUTemplate = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
      vertexGlTemplate = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
      fragmentGlTemplate = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
  var globalUniformsBit, globalUniformsBitGl;
  var init_globalUniformsBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
      "use strict";
      globalUniformsBit = {
        name: "global-uniforms-bit",
        vertex: {
          header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
      };
      globalUniformsBitGl = {
        name: "global-uniforms-bit",
        vertex: {
          header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/compileHighShaderToProgram.mjs
  function compileHighShaderGpuProgram({ bits, name }) {
    const source2 = compileHighShader({
      template: {
        fragment: fragmentGPUTemplate,
        vertex: vertexGPUTemplate
      },
      bits: [
        globalUniformsBit,
        ...bits
      ]
    });
    return GpuProgram.from({
      name,
      vertex: {
        source: source2.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: source2.fragment,
        entryPoint: "main"
      }
    });
  }
  function compileHighShaderGlProgram({ bits, name }) {
    return new GlProgram({
      name,
      ...compileHighShaderGl({
        template: {
          vertex: vertexGlTemplate,
          fragment: fragmentGlTemplate
        },
        bits: [
          globalUniformsBitGl,
          ...bits
        ]
      })
    });
  }
  var init_compileHighShaderToProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_compileHighShader();
      init_defaultProgramTemplate();
      init_globalUniformsBit();
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/colorBit.mjs
  var colorBit, colorBitGl;
  var init_colorBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
      "use strict";
      colorBit = {
        name: "color-bit",
        vertex: {
          header: `
            @in aColor: vec4<f32>;
        `,
          main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
      };
      colorBitGl = {
        name: "color-bit",
        vertex: {
          header: `
            in vec4 aColor;
        `,
          main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
  function generateBindingSrc(maxTextures2) {
    const src = [];
    if (maxTextures2 === 1) {
      src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
      src.push("@group(1) @binding(1) var textureSampler1: sampler;");
    } else {
      let bindingIndex = 0;
      for (let i2 = 0; i2 < maxTextures2; i2++) {
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
        src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
      }
    }
    return src.join("\n");
  }
  function generateSampleSrc(maxTextures2) {
    const src = [];
    if (maxTextures2 === 1) {
      src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    } else {
      src.push("switch vTextureId {");
      for (let i2 = 0; i2 < maxTextures2; i2++) {
        if (i2 === maxTextures2 - 1) {
          src.push(`  default:{`);
        } else {
          src.push(`  case ${i2}:{`);
        }
        src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
        src.push(`      break;}`);
      }
      src.push(`}`);
    }
    return src.join("\n");
  }
  function generateTextureBatchBit(maxTextures2) {
    if (!textureBatchBitGpuCache[maxTextures2]) {
      textureBatchBitGpuCache[maxTextures2] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures2)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures2)}
            `
        }
      };
    }
    return textureBatchBitGpuCache[maxTextures2];
  }
  function generateSampleGlSrc(maxTextures2) {
    const src = [];
    for (let i2 = 0; i2 < maxTextures2; i2++) {
      if (i2 > 0) {
        src.push("else");
      }
      if (i2 < maxTextures2 - 1) {
        src.push(`if(vTextureId < ${i2}.5)`);
      }
      src.push("{");
      src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
      src.push("}");
    }
    return src.join("\n");
  }
  function generateTextureBatchBitGl(maxTextures2) {
    if (!textureBatchBitGlCache[maxTextures2]) {
      textureBatchBitGlCache[maxTextures2] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures2}];

            `,
          main: `

                ${generateSampleGlSrc(maxTextures2)}
            `
        }
      };
    }
    return textureBatchBitGlCache[maxTextures2];
  }
  var textureBatchBitGpuCache, textureBatchBitGlCache;
  var init_generateTextureBatchBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
      "use strict";
      textureBatchBitGpuCache = {};
      textureBatchBitGlCache = {};
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
  var roundPixelsBit, roundPixelsBitGl;
  var init_roundPixelsBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
      "use strict";
      roundPixelsBit = {
        name: "round-pixels-bit",
        vertex: {
          header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
      };
      roundPixelsBitGl = {
        name: "round-pixels-bit",
        vertex: {
          header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/types.mjs
  var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
  var init_types = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/types.mjs"() {
      "use strict";
      UNIFORM_TYPES_VALUES = [
        "f32",
        "i32",
        "vec2<f32>",
        "vec3<f32>",
        "vec4<f32>",
        "mat2x2<f32>",
        "mat3x3<f32>",
        "mat4x4<f32>",
        "mat3x2<f32>",
        "mat4x2<f32>",
        "mat2x3<f32>",
        "mat4x3<f32>",
        "mat2x4<f32>",
        "mat3x4<f32>"
      ];
      UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
        acc[type] = true;
        return acc;
      }, {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
  function getDefaultUniformValue(type, size) {
    switch (type) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * size);
      case "vec3<f32>":
        return new Float32Array(3 * size);
      case "vec4<f32>":
        return new Float32Array(4 * size);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_getDefaultUniformValue = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UniformGroup.mjs
  var _UniformGroup, UniformGroup2;
  var init_UniformGroup2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
      init_uid2();
      init_createIdFromString();
      init_types();
      init_getDefaultUniformValue();
      _UniformGroup = class _UniformGroup2 {
        constructor(uniformStructures, options) {
          this._touched = 0;
          this.uid = uid2("uniform");
          this._resourceType = "uniformGroup";
          this._resourceId = uid2("resource");
          this.isUniformGroup = true;
          this._dirtyId = 0;
          this.destroyed = false;
          options = { ..._UniformGroup2.defaultOptions, ...options };
          this.uniformStructures = uniformStructures;
          const uniforms = {};
          for (const i2 in uniformStructures) {
            const uniformData = uniformStructures[i2];
            uniformData.name = i2;
            uniformData.size = uniformData.size ?? 1;
            if (!UNIFORM_TYPES_MAP[uniformData.type]) {
              throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
            }
            uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
            uniforms[i2] = uniformData.value;
          }
          this.uniforms = uniforms;
          this._dirtyId = 1;
          this.ubo = options.ubo;
          this.isStatic = options.isStatic;
          this._signature = createIdFromString(Object.keys(uniforms).map(
            (i2) => `${i2}-${uniformStructures[i2].type}`
          ).join("-"), "uniform-group");
        }
        update() {
          this._dirtyId++;
        }
      };
      _UniformGroup.defaultOptions = {
        ubo: false,
        isStatic: false
      };
      UniformGroup2 = _UniformGroup;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
  function getBatchSamplersUniformGroup(maxTextures2) {
    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2];
    if (batchSamplersUniformGroup)
      return batchSamplersUniformGroup;
    const sampleValues = new Int32Array(maxTextures2);
    for (let i2 = 0; i2 < maxTextures2; i2++) {
      sampleValues[i2] = i2;
    }
    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2] = new UniformGroup2({
      uTextures: { value: sampleValues, type: `i32`, size: maxTextures2 }
    }, { isStatic: true });
    return batchSamplersUniformGroup;
  }
  var batchSamplersUniformGroupHash;
  var init_getBatchSamplersUniformGroup = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
      init_UniformGroup2();
      batchSamplersUniformGroupHash = {};
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/types.mjs
  var RendererType;
  var init_types2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/types.mjs"() {
      "use strict";
      RendererType = /* @__PURE__ */ ((RendererType2) => {
        RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
        RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
        RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
        return RendererType2;
      })(RendererType || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/Shader.mjs
  var Shader2;
  var init_Shader2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/Shader.mjs"() {
      init_eventemitter3();
      init_GlProgram();
      init_BindGroup();
      init_GpuProgram();
      init_types2();
      init_UniformGroup2();
      Shader2 = class extends eventemitter3_default {
        constructor(options) {
          super();
          this._uniformBindMap = /* @__PURE__ */ Object.create(null);
          this._ownedBindGroups = [];
          let {
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            groups,
            resources,
            compatibleRenderers,
            groupMap
          } = options;
          this.gpuProgram = gpuProgram3;
          this.glProgram = glProgram3;
          if (compatibleRenderers === void 0) {
            compatibleRenderers = 0;
            if (gpuProgram3)
              compatibleRenderers |= RendererType.WEBGPU;
            if (glProgram3)
              compatibleRenderers |= RendererType.WEBGL;
          }
          this.compatibleRenderers = compatibleRenderers;
          const nameHash = {};
          if (!resources && !groups) {
            resources = {};
          }
          if (resources && groups) {
            throw new Error("[Shader] Cannot have both resources and groups");
          } else if (!gpuProgram3 && groups && !groupMap) {
            throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
          } else if (!gpuProgram3 && groups && groupMap) {
            for (const i2 in groupMap) {
              for (const j2 in groupMap[i2]) {
                const uniformName = groupMap[i2][j2];
                nameHash[uniformName] = {
                  group: i2,
                  binding: j2,
                  name: uniformName
                };
              }
            }
          } else if (gpuProgram3 && groups && !groupMap) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupMap = {};
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          } else if (resources) {
            groups = {};
            groupMap = {};
            if (gpuProgram3) {
              const groupData = gpuProgram3.structsAndGroups.groups;
              groupData.forEach((data) => {
                groupMap[data.group] = groupMap[data.group] || {};
                groupMap[data.group][data.binding] = data.name;
                nameHash[data.name] = data;
              });
            }
            let bindTick = 0;
            for (const i2 in resources) {
              if (nameHash[i2])
                continue;
              if (!groups[99]) {
                groups[99] = new BindGroup();
                this._ownedBindGroups.push(groups[99]);
              }
              nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
              groupMap[99] = groupMap[99] || {};
              groupMap[99][bindTick] = i2;
              bindTick++;
            }
            for (const i2 in resources) {
              const name = i2;
              let value = resources[i2];
              if (!value.source && !value._resourceType) {
                value = new UniformGroup2(value);
              }
              const data = nameHash[name];
              if (data) {
                if (!groups[data.group]) {
                  groups[data.group] = new BindGroup();
                  this._ownedBindGroups.push(groups[data.group]);
                }
                groups[data.group].setResource(value, data.binding);
              }
            }
          }
          this.groups = groups;
          this._uniformBindMap = groupMap;
          this.resources = this._buildResourceAccessor(groups, nameHash);
        }
        addResource(name, groupIndex, bindIndex) {
          var _a, _b;
          (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
          (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
          if (!this.groups[groupIndex]) {
            this.groups[groupIndex] = new BindGroup();
            this._ownedBindGroups.push(this.groups[groupIndex]);
          }
        }
        _buildResourceAccessor(groups, nameHash) {
          const uniformsOut = {};
          for (const i2 in nameHash) {
            const data = nameHash[i2];
            Object.defineProperty(uniformsOut, data.name, {
              get() {
                return groups[data.group].getResource(data.binding);
              },
              set(value) {
                groups[data.group].setResource(value, data.binding);
              }
            });
          }
          return uniformsOut;
        }
        destroy(destroyPrograms = false) {
          this.emit("destroy", this);
          if (destroyPrograms) {
            this.gpuProgram?.destroy();
            this.glProgram?.destroy();
          }
          this.gpuProgram = null;
          this.glProgram = null;
          this.removeAllListeners();
          this._uniformBindMap = null;
          this._ownedBindGroups.forEach((bindGroup) => {
            bindGroup.destroy();
          });
          this._ownedBindGroups = null;
          this.resources = null;
          this.groups = null;
        }
        static from(options) {
          const { gpu, gl, ...rest } = options;
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new Shader2({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            ...rest
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/DefaultShader.mjs
  var DefaultShader;
  var init_DefaultShader = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/DefaultShader.mjs"() {
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader2();
      DefaultShader = class extends Shader2 {
        constructor(maxTextures2) {
          const glProgram3 = compileHighShaderGlProgram({
            name: "batch",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              roundPixelsBitGl
            ]
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "batch",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures2),
              roundPixelsBit
            ]
          });
          super({
            glProgram: glProgram3,
            gpuProgram: gpuProgram3,
            resources: {
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/DefaultBatcher.mjs
  var defaultShader, _DefaultBatcher, DefaultBatcher;
  var init_DefaultBatcher = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/DefaultBatcher.mjs"() {
      init_Extensions();
      init_Batcher();
      init_BatchGeometry2();
      init_DefaultShader();
      defaultShader = null;
      _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
        constructor() {
          super(...arguments);
          this.geometry = new BatchGeometry2();
          this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));
          this.name = _DefaultBatcher2.extension.name;
          this.vertexSize = 6;
        }
        packAttributes(element, float32View, uint32View, index, textureId) {
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const { positions, uvs } = element;
          const argb = element.color;
          const offset = element.attributeOffset;
          const end = offset + element.attributeSize;
          for (let i2 = offset; i2 < end; i2++) {
            const i22 = i2 * 2;
            const x2 = positions[i22];
            const y2 = positions[i22 + 1];
            float32View[index++] = a2 * x2 + c2 * y2 + tx;
            float32View[index++] = d2 * y2 + b2 * x2 + ty;
            float32View[index++] = uvs[i22];
            float32View[index++] = uvs[i22 + 1];
            uint32View[index++] = argb;
            uint32View[index++] = textureIdAndRound;
          }
        }
        packQuadAttributes(element, float32View, uint32View, index, textureId) {
          const texture = element.texture;
          const wt = element.transform;
          const a2 = wt.a;
          const b2 = wt.b;
          const c2 = wt.c;
          const d2 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          const bounds = element.bounds;
          const w0 = bounds.maxX;
          const w1 = bounds.minX;
          const h0 = bounds.maxY;
          const h1 = bounds.minY;
          const uvs = texture.uvs;
          const argb = element.color;
          const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
          float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
          float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
          float32View[index + 2] = uvs.x0;
          float32View[index + 3] = uvs.y0;
          uint32View[index + 4] = argb;
          uint32View[index + 5] = textureIdAndRound;
          float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
          float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
          float32View[index + 8] = uvs.x1;
          float32View[index + 9] = uvs.y1;
          uint32View[index + 10] = argb;
          uint32View[index + 11] = textureIdAndRound;
          float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
          float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
          float32View[index + 14] = uvs.x2;
          float32View[index + 15] = uvs.y2;
          uint32View[index + 16] = argb;
          uint32View[index + 17] = textureIdAndRound;
          float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
          float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
          float32View[index + 20] = uvs.x3;
          float32View[index + 21] = uvs.y3;
          uint32View[index + 22] = argb;
          uint32View[index + 23] = textureIdAndRound;
        }
      };
      _DefaultBatcher.extension = {
        type: [
          ExtensionType2.Batcher
        ],
        name: "default"
      };
      DefaultBatcher = _DefaultBatcher;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
  function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
    let index = 0;
    verticesOffset *= verticesStride;
    uvsOffset *= uvsStride;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    while (index < size) {
      const x2 = vertices[verticesOffset];
      const y2 = vertices[verticesOffset + 1];
      uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
      uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
      uvsOffset += uvsStride;
      verticesOffset += verticesStride;
      index++;
    }
  }
  function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
    let index = 0;
    uvsOffset *= uvsStride;
    while (index < size) {
      uvs[uvsOffset] = 0;
      uvs[uvsOffset + 1] = 0;
      uvsOffset += uvsStride;
      index++;
    }
  }
  var init_buildUvs = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
  function transformVertices(vertices, m2, offset, stride, size) {
    const a2 = m2.a;
    const b2 = m2.b;
    const c2 = m2.c;
    const d2 = m2.d;
    const tx = m2.tx;
    const ty = m2.ty;
    offset = offset || 0;
    stride = stride || 2;
    size = size || vertices.length / stride - offset;
    let index = offset * stride;
    for (let i2 = 0; i2 < size; i2++) {
      const x2 = vertices[index];
      const y2 = vertices[index + 1];
      vertices[index] = a2 * x2 + c2 * y2 + tx;
      vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
      index += stride;
    }
  }
  var init_transformVertices = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/multiplyHexColors.mjs
  function multiplyHexColors(color1, color2) {
    if (color1 === 16777215 || !color2)
      return color2;
    if (color2 === 16777215 || !color1)
      return color1;
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 * r2 / 255;
    const g3 = g1 * g2 / 255;
    const b3 = b1 * b2 / 255;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_multiplyHexColors = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/multiplyHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/BatchableGraphics.mjs
  var identityMatrix2, BatchableGraphics;
  var init_BatchableGraphics = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
      init_Matrix2();
      init_multiplyHexColors();
      identityMatrix2 = new Matrix2();
      BatchableGraphics = class {
        constructor() {
          this.packAsQuad = false;
          this.batcherName = "default";
          this.applyTransform = true;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
        }
        get uvs() {
          return this.geometryData.uvs;
        }
        get positions() {
          return this.geometryData.vertices;
        }
        get indices() {
          return this.geometryData.indices;
        }
        get blendMode() {
          if (this.applyTransform) {
            return this.renderable.groupBlendMode;
          }
          return "normal";
        }
        get color() {
          const rgb = this.baseColor;
          const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
          const renderable = this.renderable;
          if (renderable) {
            return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
          }
          return bgr + (this.alpha * 255 << 24);
        }
        get transform() {
          return this.renderable?.groupTransform || identityMatrix2;
        }
        copyTo(gpuBuffer) {
          gpuBuffer.indexOffset = this.indexOffset;
          gpuBuffer.indexSize = this.indexSize;
          gpuBuffer.attributeOffset = this.attributeOffset;
          gpuBuffer.attributeSize = this.attributeSize;
          gpuBuffer.baseColor = this.baseColor;
          gpuBuffer.alpha = this.alpha;
          gpuBuffer.texture = this.texture;
          gpuBuffer.geometryData = this.geometryData;
        }
        reset() {
          this.applyTransform = true;
          this.renderable = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
  var buildCircle2, buildEllipse, buildRoundedRectangle2;
  var init_buildCircle2 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
      init_Extensions();
      buildCircle2 = {
        extension: {
          type: ExtensionType2.ShapeBuilder,
          name: "circle"
        },
        build(shape, points) {
          let x2;
          let y2;
          let dx;
          let dy;
          let rx;
          let ry;
          if (shape.type === "circle") {
            const circle = shape;
            x2 = circle.x;
            y2 = circle.y;
            rx = ry = circle.radius;
            dx = dy = 0;
          } else if (shape.type === "ellipse") {
            const ellipse = shape;
            x2 = ellipse.x;
            y2 = ellipse.y;
            rx = ellipse.halfWidth;
            ry = ellipse.halfHeight;
            dx = dy = 0;
          } else {
            const roundedRect = shape;
            const halfWidth = roundedRect.width / 2;
            const halfHeight = roundedRect.height / 2;
            x2 = roundedRect.x + halfWidth;
            y2 = roundedRect.y + halfHeight;
            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
            dx = halfWidth - rx;
            dy = halfHeight - ry;
          }
          if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
            return points;
          }
          const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
          const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
          if (m2 === 0) {
            return points;
          }
          if (n2 === 0) {
            points[0] = points[6] = x2 + dx;
            points[1] = points[3] = y2 + dy;
            points[2] = points[4] = x2 - dx;
            points[5] = points[7] = y2 - dy;
            return points;
          }
          let j1 = 0;
          let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
          let j3 = j2;
          let j4 = m2;
          let x0 = dx + rx;
          let y0 = dy;
          let x1 = x2 + x0;
          let x22 = x2 - x0;
          let y1 = y2 + y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j2] = y1;
          points[--j2] = x22;
          if (dy) {
            const y222 = y2 - y0;
            points[j3++] = x22;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x1;
          }
          for (let i2 = 1; i2 < n2; i2++) {
            const a2 = Math.PI / 2 * (i2 / n2);
            const x02 = dx + Math.cos(a2) * rx;
            const y02 = dy + Math.sin(a2) * ry;
            const x12 = x2 + x02;
            const x222 = x2 - x02;
            const y12 = y2 + y02;
            const y222 = y2 - y02;
            points[j1++] = x12;
            points[j1++] = y12;
            points[--j2] = y12;
            points[--j2] = x222;
            points[j3++] = x222;
            points[j3++] = y222;
            points[--j4] = y222;
            points[--j4] = x12;
          }
          x0 = dx;
          y0 = dy + ry;
          x1 = x2 + x0;
          x22 = x2 - x0;
          y1 = y2 + y0;
          const y22 = y2 - y0;
          points[j1++] = x1;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x1;
          if (dx) {
            points[j1++] = x22;
            points[j1++] = y1;
            points[--j4] = y22;
            points[--j4] = x22;
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices2, indicesOffset) {
          if (points.length === 0) {
            return;
          }
          let centerX = 0;
          let centerY = 0;
          for (let i2 = 0; i2 < points.length; i2 += 2) {
            centerX += points[i2];
            centerY += points[i2 + 1];
          }
          centerX /= points.length / 2;
          centerY /= points.length / 2;
          let count2 = verticesOffset;
          vertices[count2 * verticesStride] = centerX;
          vertices[count2 * verticesStride + 1] = centerY;
          const centerIndex = count2++;
          for (let i2 = 0; i2 < points.length; i2 += 2) {
            vertices[count2 * verticesStride] = points[i2];
            vertices[count2 * verticesStride + 1] = points[i2 + 1];
            if (i2 > 0) {
              indices2[indicesOffset++] = count2;
              indices2[indicesOffset++] = centerIndex;
              indices2[indicesOffset++] = count2 - 1;
            }
            count2++;
          }
          indices2[indicesOffset++] = centerIndex + 1;
          indices2[indicesOffset++] = centerIndex;
          indices2[indicesOffset++] = count2 - 1;
        }
      };
      buildEllipse = { ...buildCircle2, extension: { ...buildCircle2.extension, name: "ellipse" } };
      buildRoundedRectangle2 = { ...buildCircle2, extension: { ...buildCircle2.extension, name: "roundedRectangle" } };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/const.mjs
  var closePointEps, curveEps;
  var init_const12 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/const.mjs"() {
      "use strict";
      closePointEps = 1e-4;
      curveEps = 1e-4;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
  function getOrientationOfPoints(points) {
    const m2 = points.length;
    if (m2 < 6) {
      return 1;
    }
    let area = 0;
    for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      area += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    if (area < 0) {
      return -1;
    }
    return 1;
  }
  var init_getOrientationOfPoints = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildLine.mjs
  function square2(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    const ix = x2 - nx * innerWeight;
    const iy = y2 - ny * innerWeight;
    const ox = x2 + nx * outerWeight;
    const oy = y2 + ny * outerWeight;
    let exx;
    let eyy;
    if (clockwise) {
      exx = ny;
      eyy = -nx;
    } else {
      exx = -ny;
      eyy = nx;
    }
    const eix = ix + exx;
    const eiy = iy + eyy;
    const eox = ox + exx;
    const eoy = oy + eyy;
    verts.push(eix, eiy);
    verts.push(eox, eoy);
    return 2;
  }
  function round2(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    const cx2p0x = sx - cx;
    const cy2p0y = sy - cy;
    let angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    if (clockwise && angle0 < angle1) {
      angle0 += Math.PI * 2;
    } else if (!clockwise && angle0 > angle1) {
      angle1 += Math.PI * 2;
    }
    let startAngle = angle0;
    const angleDiff = angle1 - angle0;
    const absAngleDiff = Math.abs(angleDiff);
    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
    const angleInc = angleDiff / segCount;
    startAngle += angleInc;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(cx, cy);
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
        verts.push(
          cx + Math.sin(angle) * radius,
          cy + Math.cos(angle) * radius
        );
        verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return segCount * 2;
  }
  function buildLine2(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices2, _indicesOffset) {
    const eps = closePointEps;
    if (points.length === 0) {
      return;
    }
    const style = lineStyle;
    let alignment = style.alignment;
    if (lineStyle.alignment !== 0.5) {
      let orientation = getOrientationOfPoints(points);
      if (flipAlignment)
        orientation *= -1;
      alignment = (alignment - 0.5) * orientation + 0.5;
    }
    const firstPoint = new Point2(points[0], points[1]);
    const lastPoint = new Point2(points[points.length - 2], points[points.length - 1]);
    const closedShape = closed;
    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
    if (closedShape) {
      points = points.slice();
      if (closedPath) {
        points.pop();
        points.pop();
        lastPoint.set(points[points.length - 2], points[points.length - 1]);
      }
      const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
      const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
      points.unshift(midPointX, midPointY);
      points.push(midPointX, midPointY);
    }
    const verts = vertices;
    const length = points.length / 2;
    let indexCount = points.length;
    const indexStart = verts.length / 2;
    const width = style.width / 2;
    const widthSquared = width * width;
    const miterLimitSquared = style.miterLimit * style.miterLimit;
    let x0 = points[0];
    let y0 = points[1];
    let x1 = points[2];
    let y1 = points[3];
    let x2 = 0;
    let y2 = 0;
    let perpX = -(y0 - y1);
    let perpY = x0 - x1;
    let perp1x = 0;
    let perp1y = 0;
    let dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    const ratio = alignment;
    const innerWeight = (1 - ratio) * 2;
    const outerWeight = ratio * 2;
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round2(
          x0 - perpX * (innerWeight - outerWeight) * 0.5,
          y0 - perpY * (innerWeight - outerWeight) * 0.5,
          x0 - perpX * innerWeight,
          y0 - perpY * innerWeight,
          x0 + perpX * outerWeight,
          y0 + perpY * outerWeight,
          verts,
          true
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square2(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
      }
    }
    verts.push(
      x0 - perpX * innerWeight,
      y0 - perpY * innerWeight
    );
    verts.push(
      x0 + perpX * outerWeight,
      y0 + perpY * outerWeight
    );
    for (let i2 = 1; i2 < length - 1; ++i2) {
      x0 = points[(i2 - 1) * 2];
      y0 = points[(i2 - 1) * 2 + 1];
      x1 = points[i2 * 2];
      y1 = points[i2 * 2 + 1];
      x2 = points[(i2 + 1) * 2];
      y2 = points[(i2 + 1) * 2 + 1];
      perpX = -(y0 - y1);
      perpY = x0 - x1;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX /= dist;
      perpY /= dist;
      perpX *= width;
      perpY *= width;
      perp1x = -(y1 - y2);
      perp1y = x1 - x2;
      dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
      perp1x /= dist;
      perp1y /= dist;
      perp1x *= width;
      perp1y *= width;
      const dx0 = x1 - x0;
      const dy0 = y0 - y1;
      const dx1 = x1 - x2;
      const dy1 = y2 - y1;
      const dot = dx0 * dx1 + dy0 * dy1;
      const cross = dy0 * dx1 - dy1 * dx0;
      const clockwise = cross < 0;
      if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
        verts.push(
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight
        );
        verts.push(
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight
        );
        if (dot >= 0) {
          if (style.join === "round") {
            indexCount += round2(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
          } else {
            indexCount += 2;
          }
          verts.push(
            x1 - perp1x * outerWeight,
            y1 - perp1y * outerWeight
          );
          verts.push(
            x1 + perp1x * innerWeight,
            y1 + perp1y * innerWeight
          );
        }
        continue;
      }
      const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
      const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
      const px = (dx0 * c2 - dx1 * c1) / cross;
      const py = (dy1 * c1 - dy0 * c2) / cross;
      const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
      const imx = x1 + (px - x1) * innerWeight;
      const imy = y1 + (py - y1) * innerWeight;
      const omx = x1 - (px - x1) * outerWeight;
      const omy = y1 - (py - y1) * outerWeight;
      const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
      const insideWeight = clockwise ? innerWeight : outerWeight;
      const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
      const insideMiterOk = pDist <= smallerInsideDiagonalSq;
      if (insideMiterOk) {
        if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === "round") {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
            indexCount += round2(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
            verts.push(omx, omy);
            indexCount += round2(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      } else {
        verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
        verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
        if (style.join === "round") {
          if (clockwise) {
            indexCount += round2(
              x1,
              y1,
              x1 + perpX * outerWeight,
              y1 + perpY * outerWeight,
              x1 + perp1x * outerWeight,
              y1 + perp1y * outerWeight,
              verts,
              true
            ) + 2;
          } else {
            indexCount += round2(
              x1,
              y1,
              x1 - perpX * innerWeight,
              y1 - perpY * innerWeight,
              x1 - perp1x * innerWeight,
              y1 - perp1y * innerWeight,
              verts,
              false
            ) + 2;
          }
        } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
          if (clockwise) {
            verts.push(omx, omy);
            verts.push(omx, omy);
          } else {
            verts.push(imx, imy);
            verts.push(imx, imy);
          }
          indexCount += 2;
        }
        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        indexCount += 2;
      }
    }
    x0 = points[(length - 2) * 2];
    y0 = points[(length - 2) * 2 + 1];
    x1 = points[(length - 1) * 2];
    y1 = points[(length - 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
    if (!closedShape) {
      if (style.cap === "round") {
        indexCount += round2(
          x1 - perpX * (innerWeight - outerWeight) * 0.5,
          y1 - perpY * (innerWeight - outerWeight) * 0.5,
          x1 - perpX * innerWeight,
          y1 - perpY * innerWeight,
          x1 + perpX * outerWeight,
          y1 + perpY * outerWeight,
          verts,
          false
        ) + 2;
      } else if (style.cap === "square") {
        indexCount += square2(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
      }
    }
    const eps2 = curveEps * curveEps;
    for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
      x0 = verts[i2 * 2];
      y0 = verts[i2 * 2 + 1];
      x1 = verts[(i2 + 1) * 2];
      y1 = verts[(i2 + 1) * 2 + 1];
      x2 = verts[(i2 + 2) * 2];
      y2 = verts[(i2 + 2) * 2 + 1];
      if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
        continue;
      }
      indices2.push(i2, i2 + 1, i2 + 2);
    }
  }
  var init_buildLine2 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
      init_Point2();
      init_const12();
      init_getOrientationOfPoints();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
  function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices2, indicesOffset) {
    const triangles = (0, import_earcut2.default)(points, holes, 2);
    if (!triangles) {
      return;
    }
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      indices2[indicesOffset++] = triangles[i2] + verticesOffset;
      indices2[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
      indices2[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
    }
    let index = verticesOffset * verticesStride;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      vertices[index] = points[i2];
      vertices[index + 1] = points[i2 + 1];
      index += verticesStride;
    }
  }
  var import_earcut2;
  var init_triangulateWithHoles = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
      import_earcut2 = __toESM(require_earcut(), 1);
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
  var emptyArray, buildPolygon;
  var init_buildPolygon = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
      init_Extensions();
      init_triangulateWithHoles();
      emptyArray = [];
      buildPolygon = {
        extension: {
          type: ExtensionType2.ShapeBuilder,
          name: "polygon"
        },
        build(shape, points) {
          for (let i2 = 0; i2 < shape.points.length; i2++) {
            points[i2] = shape.points[i2];
          }
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices2, indicesOffset) {
          triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices2, indicesOffset);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
  var buildRectangle2;
  var init_buildRectangle2 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
      init_Extensions();
      buildRectangle2 = {
        extension: {
          type: ExtensionType2.ShapeBuilder,
          name: "rectangle"
        },
        build(shape, points) {
          const rectData = shape;
          const x2 = rectData.x;
          const y2 = rectData.y;
          const width = rectData.width;
          const height = rectData.height;
          if (!(width >= 0 && height >= 0)) {
            return points;
          }
          points[0] = x2;
          points[1] = y2;
          points[2] = x2 + width;
          points[3] = y2;
          points[4] = x2 + width;
          points[5] = y2 + height;
          points[6] = x2;
          points[7] = y2 + height;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices2, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[6];
          vertices[verticesOffset + count2 + 1] = points[7];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          count2 += verticesStride;
          const verticesIndex = verticesOffset / verticesStride;
          indices2[indicesOffset++] = verticesIndex;
          indices2[indicesOffset++] = verticesIndex + 1;
          indices2[indicesOffset++] = verticesIndex + 2;
          indices2[indicesOffset++] = verticesIndex + 1;
          indices2[indicesOffset++] = verticesIndex + 3;
          indices2[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
  var buildTriangle;
  var init_buildTriangle = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
      init_Extensions();
      buildTriangle = {
        extension: {
          type: ExtensionType2.ShapeBuilder,
          name: "triangle"
        },
        build(shape, points) {
          points[0] = shape.x;
          points[1] = shape.y;
          points[2] = shape.x2;
          points[3] = shape.y2;
          points[4] = shape.x3;
          points[5] = shape.y3;
          return points;
        },
        triangulate(points, vertices, verticesStride, verticesOffset, indices2, indicesOffset) {
          let count2 = 0;
          verticesOffset *= verticesStride;
          vertices[verticesOffset + count2] = points[0];
          vertices[verticesOffset + count2 + 1] = points[1];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[2];
          vertices[verticesOffset + count2 + 1] = points[3];
          count2 += verticesStride;
          vertices[verticesOffset + count2] = points[4];
          vertices[verticesOffset + count2 + 1] = points[5];
          const verticesIndex = verticesOffset / verticesStride;
          indices2[indicesOffset++] = verticesIndex;
          indices2[indicesOffset++] = verticesIndex + 1;
          indices2[indicesOffset++] = verticesIndex + 2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/buildContextBatches.mjs
  function buildContextBatches(context3, gpuContext) {
    const { geometryData, batches } = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (let i2 = 0; i2 < context3.instructions.length; i2++) {
      const instruction = context3.instructions[i2];
      if (instruction.action === "texture") {
        addTextureToGeometryData(instruction.data, batches, geometryData);
      } else if (instruction.action === "fill" || instruction.action === "stroke") {
        const isStroke = instruction.action === "stroke";
        const shapePath = instruction.data.path.shapePath;
        const style = instruction.data.style;
        const hole = instruction.data.hole;
        if (isStroke && hole) {
          addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
        }
        addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
      }
    }
  }
  function addTextureToGeometryData(data, batches, geometryData) {
    const { vertices, uvs, indices: indices2 } = geometryData;
    const indexOffset = indices2.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = shapeBuilders.rectangle;
    const rect = tempRect3;
    const texture = data.image;
    rect.x = data.dx;
    rect.y = data.dy;
    rect.width = data.dw;
    rect.height = data.dh;
    const matrix = data.transform;
    build.build(rect, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices2, indexOffset);
    const textureUvs = texture.uvs;
    uvs.push(
      textureUvs.x0,
      textureUvs.y0,
      textureUvs.x1,
      textureUvs.y1,
      textureUvs.x3,
      textureUvs.y3,
      textureUvs.x2,
      textureUvs.y2
    );
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices2.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = data.style;
    graphicsBatch.alpha = data.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  }
  function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
    const { vertices, uvs, indices: indices2 } = geometryData;
    const lastIndex = shapePath.shapePrimitives.length - 1;
    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i2) => {
      const indexOffset = indices2.length;
      const vertOffset = vertices.length / 2;
      const points = [];
      const build = shapeBuilders[shape.type];
      build.build(shape, points);
      if (matrix) {
        transformVertices(points, matrix);
      }
      if (!isStroke) {
        if (hole && lastIndex === i2) {
          if (lastIndex !== 0) {
            console.warn("[Pixi Graphics] only the last shape have be cut out");
          }
          const holeIndices = [];
          const otherPoints = points.slice();
          const holeArrays = getHoleArrays(hole.shapePath);
          holeArrays.forEach((holePoints) => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices2, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices2, indexOffset);
        }
      } else {
        const close = shape.closePath ?? true;
        const lineStyle = style;
        buildLine2(points, lineStyle, false, close, vertices, 2, vertOffset, indices2, indexOffset);
      }
      const uvsOffset = uvs.length / 2;
      const texture = style.texture;
      if (texture !== Texture2.WHITE) {
        const textureMatrix = style.matrix;
        if (textureMatrix) {
          if (matrix) {
            textureMatrix.append(matrix.clone().invert());
          }
          buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
        }
      } else {
        buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
      }
      const graphicsBatch = BigPool.get(BatchableGraphics);
      graphicsBatch.indexOffset = indexOffset;
      graphicsBatch.indexSize = indices2.length - indexOffset;
      graphicsBatch.attributeOffset = vertOffset;
      graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
      graphicsBatch.baseColor = style.color;
      graphicsBatch.alpha = style.alpha;
      graphicsBatch.texture = texture;
      graphicsBatch.geometryData = geometryData;
      batches.push(graphicsBatch);
    });
  }
  function getHoleArrays(shape) {
    if (!shape)
      return [];
    const holePrimitives = shape.shapePrimitives;
    const holeArrays = [];
    for (let k2 = 0; k2 < holePrimitives.length; k2++) {
      const holePrimitive = holePrimitives[k2].shape;
      const holePoints = [];
      const holeBuilder = shapeBuilders[holePrimitive.type];
      holeBuilder.build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }
  var shapeBuilders, tempRect3;
  var init_buildContextBatches = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
      init_Extensions();
      init_Rectangle2();
      init_buildUvs();
      init_transformVertices();
      init_Texture2();
      init_PoolGroup();
      init_BatchableGraphics();
      init_buildCircle2();
      init_buildLine2();
      init_buildPolygon();
      init_buildRectangle2();
      init_buildTriangle();
      init_triangulateWithHoles();
      shapeBuilders = {};
      extensions3.handleByMap(ExtensionType2.ShapeBuilder, shapeBuilders);
      extensions3.add(buildRectangle2, buildPolygon, buildTriangle, buildCircle2, buildEllipse, buildRoundedRectangle2);
      tempRect3 = new Rectangle2();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContextSystem.mjs
  var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
  var init_GraphicsContextSystem = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
      init_Extensions();
      init_getTextureBatchBindGroup();
      init_DefaultBatcher();
      init_InstructionSet();
      init_deprecation2();
      init_PoolGroup();
      init_buildContextBatches();
      GpuGraphicsContext = class {
        constructor() {
          this.batches = [];
          this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
          };
        }
      };
      GraphicsContextRenderData = class {
        constructor() {
          this.batcher = new DefaultBatcher();
          this.instructions = new InstructionSet();
        }
        init() {
          this.instructions.reset();
        }
        get geometry() {
          deprecation2(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
          return this.batcher.geometry;
        }
      };
      _GraphicsContextSystem = class _GraphicsContextSystem2 {
        constructor() {
          this._gpuContextHash = {};
          this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
        }
        init(options) {
          _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
        }
        getContextRenderData(context3) {
          return this._graphicsDataContextHash[context3.uid] || this._initContextRenderData(context3);
        }
        updateGpuContext(context3) {
          let gpuContext = this._gpuContextHash[context3.uid] || this._initContext(context3);
          if (context3.dirty) {
            if (gpuContext) {
              this._cleanGraphicsContextData(context3);
            } else {
              gpuContext = this._initContext(context3);
            }
            buildContextBatches(context3, gpuContext);
            const batchMode = context3.batchMode;
            if (context3.customShader || batchMode === "no-batch") {
              gpuContext.isBatchable = false;
            } else if (batchMode === "auto") {
              gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
            }
            context3.dirty = false;
          }
          return gpuContext;
        }
        getGpuContext(context3) {
          return this._gpuContextHash[context3.uid] || this._initContext(context3);
        }
        _initContextRenderData(context3) {
          const graphicsData = BigPool.get(GraphicsContextRenderData);
          const { batches, geometryData } = this._gpuContextHash[context3.uid];
          const vertexSize = geometryData.vertices.length;
          const indexSize = geometryData.indices.length;
          for (let i2 = 0; i2 < batches.length; i2++) {
            batches[i2].applyTransform = false;
          }
          const batcher = graphicsData.batcher;
          batcher.ensureAttributeBuffer(vertexSize);
          batcher.ensureIndexBuffer(indexSize);
          batcher.begin();
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batcher.add(batch);
          }
          batcher.finish(graphicsData.instructions);
          const geometry = batcher.geometry;
          geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
          geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
          const drawBatches = batcher.batches;
          for (let i2 = 0; i2 < drawBatches.length; i2++) {
            const batch = drawBatches[i2];
            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
          }
          this._graphicsDataContextHash[context3.uid] = graphicsData;
          return graphicsData;
        }
        _initContext(context3) {
          const gpuContext = new GpuGraphicsContext();
          gpuContext.context = context3;
          this._gpuContextHash[context3.uid] = gpuContext;
          context3.on("destroy", this.onGraphicsContextDestroy, this);
          return this._gpuContextHash[context3.uid];
        }
        onGraphicsContextDestroy(context3) {
          this._cleanGraphicsContextData(context3);
          context3.off("destroy", this.onGraphicsContextDestroy, this);
          this._gpuContextHash[context3.uid] = null;
        }
        _cleanGraphicsContextData(context3) {
          const gpuContext = this._gpuContextHash[context3.uid];
          if (!gpuContext.isBatchable) {
            if (this._graphicsDataContextHash[context3.uid]) {
              BigPool.return(this.getContextRenderData(context3));
              this._graphicsDataContextHash[context3.uid] = null;
            }
          }
          if (gpuContext.batches) {
            gpuContext.batches.forEach((batch) => {
              BigPool.return(batch);
            });
          }
        }
        destroy() {
          for (const i2 in this._gpuContextHash) {
            if (this._gpuContextHash[i2]) {
              this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
            }
          }
        }
      };
      _GraphicsContextSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "graphicsContext"
      };
      _GraphicsContextSystem.defaultOptions = {
        bezierSmoothness: 0.5
      };
      GraphicsContextSystem = _GraphicsContextSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/state/State.mjs
  var blendModeIds, BLEND3, OFFSET3, CULLING3, DEPTH_TEST3, WINDING3, DEPTH_MASK3, _State, State2;
  var init_State2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/state/State.mjs"() {
      "use strict";
      blendModeIds = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
      };
      BLEND3 = 0;
      OFFSET3 = 1;
      CULLING3 = 2;
      DEPTH_TEST3 = 3;
      WINDING3 = 4;
      DEPTH_MASK3 = 5;
      _State = class _State2 {
        constructor() {
          this.data = 0;
          this.blendMode = "normal";
          this.polygonOffset = 0;
          this.blend = true;
          this.depthMask = true;
        }
        get blend() {
          return !!(this.data & 1 << BLEND3);
        }
        set blend(value) {
          if (!!(this.data & 1 << BLEND3) !== value) {
            this.data ^= 1 << BLEND3;
          }
        }
        get offsets() {
          return !!(this.data & 1 << OFFSET3);
        }
        set offsets(value) {
          if (!!(this.data & 1 << OFFSET3) !== value) {
            this.data ^= 1 << OFFSET3;
          }
        }
        set cullMode(value) {
          if (value === "none") {
            this.culling = false;
            return;
          }
          this.culling = true;
          this.clockwiseFrontFace = value === "front";
        }
        get cullMode() {
          if (!this.culling) {
            return "none";
          }
          return this.clockwiseFrontFace ? "front" : "back";
        }
        get culling() {
          return !!(this.data & 1 << CULLING3);
        }
        set culling(value) {
          if (!!(this.data & 1 << CULLING3) !== value) {
            this.data ^= 1 << CULLING3;
          }
        }
        get depthTest() {
          return !!(this.data & 1 << DEPTH_TEST3);
        }
        set depthTest(value) {
          if (!!(this.data & 1 << DEPTH_TEST3) !== value) {
            this.data ^= 1 << DEPTH_TEST3;
          }
        }
        get depthMask() {
          return !!(this.data & 1 << DEPTH_MASK3);
        }
        set depthMask(value) {
          if (!!(this.data & 1 << DEPTH_MASK3) !== value) {
            this.data ^= 1 << DEPTH_MASK3;
          }
        }
        get clockwiseFrontFace() {
          return !!(this.data & 1 << WINDING3);
        }
        set clockwiseFrontFace(value) {
          if (!!(this.data & 1 << WINDING3) !== value) {
            this.data ^= 1 << WINDING3;
          }
        }
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(value) {
          this.blend = value !== "none";
          this._blendMode = value;
          this._blendModeId = blendModeIds[value] || 0;
        }
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(value) {
          this.offsets = !!value;
          this._polygonOffset = value;
        }
        toString() {
          return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
          const state = new _State2();
          state.depthTest = false;
          state.blend = true;
          return state;
        }
      };
      _State.default2d = _State.for2d();
      State2 = _State;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/gpu/colorToUniform.mjs
  function color32BitToUniform(abgr, out2, offset) {
    const alpha = (abgr >> 24 & 255) / 255;
    out2[offset++] = (abgr & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
    out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
    out2[offset++] = alpha;
  }
  var init_colorToUniform = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/gpu/colorToUniform.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsPipe.mjs
  var GraphicsPipe;
  var init_GraphicsPipe = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
      init_Extensions();
      init_State2();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableGraphics();
      GraphicsPipe = class {
        constructor(renderer, adaptor) {
          this.state = State2.for2d();
          this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(graphics) {
          const context3 = graphics.context;
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(context3);
          if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
            return true;
          }
          return false;
        }
        addRenderable(graphics, instructionSet) {
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (graphics._didGraphicsUpdate) {
            graphics._didGraphicsUpdate = false;
            this._rebuild(graphics);
          }
          if (gpuContext.isBatchable) {
            this._addToBatcher(graphics, instructionSet);
          } else {
            this.renderer.renderPipes.batch.break(instructionSet);
            instructionSet.add(graphics);
          }
        }
        updateRenderable(graphics) {
          const batches = this._graphicsBatchesHash[graphics.uid];
          if (batches) {
            for (let i2 = 0; i2 < batches.length; i2++) {
              const batch = batches[i2];
              batch._batcher.updateElement(batch);
            }
          }
        }
        destroyRenderable(graphics) {
          if (this._graphicsBatchesHash[graphics.uid]) {
            this._removeBatchForRenderable(graphics.uid);
          }
          graphics.off("destroyed", this._destroyRenderableBound);
        }
        execute(graphics) {
          if (!graphics.isRenderable)
            return;
          const renderer = this.renderer;
          const context3 = graphics.context;
          const contextSystem = renderer.graphicsContext;
          if (!contextSystem.getGpuContext(context3).batches.length) {
            return;
          }
          const shader = context3.customShader || this._adaptor.shader;
          this.state.blendMode = graphics.groupBlendMode;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = graphics.groupTransform;
          localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
          color32BitToUniform(
            graphics.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._adaptor.execute(this, graphics);
        }
        _rebuild(graphics) {
          const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
          const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
          if (wasBatched) {
            this._removeBatchForRenderable(graphics.uid);
          }
          if (gpuContext.isBatchable) {
            this._initBatchesForRenderable(graphics);
          }
          graphics.batched = gpuContext.isBatchable;
        }
        _addToBatcher(graphics, instructionSet) {
          const batchPipe = this.renderer.renderPipes.batch;
          const batches = this._getBatchesForRenderable(graphics);
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batchPipe.addToBatch(batch, instructionSet);
          }
        }
        _getBatchesForRenderable(graphics) {
          return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
        }
        _initBatchesForRenderable(graphics) {
          const context3 = graphics.context;
          const gpuContext = this.renderer.graphicsContext.getGpuContext(context3);
          const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
          const batches = gpuContext.batches.map((batch) => {
            const batchClone = BigPool.get(BatchableGraphics);
            batch.copyTo(batchClone);
            batchClone.renderable = graphics;
            batchClone.roundPixels = roundPixels;
            return batchClone;
          });
          if (this._graphicsBatchesHash[graphics.uid] === void 0) {
            graphics.on("destroyed", this._destroyRenderableBound);
          }
          this._graphicsBatchesHash[graphics.uid] = batches;
          return batches;
        }
        _removeBatchForRenderable(graphicsUid) {
          this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
            BigPool.return(batch);
          });
          this._graphicsBatchesHash[graphicsUid] = null;
        }
        destroy() {
          this.renderer = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.state = null;
          for (const i2 in this._graphicsBatchesHash) {
            this._removeBatchForRenderable(i2);
          }
          this._graphicsBatchesHash = null;
        }
      };
      GraphicsPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/init.mjs
  var init_init6 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/init.mjs"() {
      init_Extensions();
      init_GraphicsContextSystem();
      init_GraphicsPipe();
      extensions3.add(GraphicsPipe);
      extensions3.add(GraphicsContextSystem);
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/BatchableMesh.mjs
  var BatchableMesh;
  var init_BatchableMesh = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/BatchableMesh.mjs"() {
      "use strict";
      BatchableMesh = class {
        constructor() {
          this.batcherName = "default";
          this.packAsQuad = false;
          this.indexOffset = 0;
          this.attributeOffset = 0;
          this.roundPixels = 0;
          this._batcher = null;
          this._batch = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.geometry = null;
          this._uvUpdateId = -1;
          this._textureMatrixUpdateId = -1;
        }
        get uvs() {
          const geometry = this.geometry;
          const uvBuffer = geometry.getBuffer("aUV");
          const uvs = uvBuffer.data;
          let transformedUvs = uvs;
          const textureMatrix = this.texture.textureMatrix;
          if (!textureMatrix.isSimple) {
            transformedUvs = this._transformedUvs;
            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
              if (!transformedUvs || transformedUvs.length < uvs.length) {
                transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
              }
              this._textureMatrixUpdateId = textureMatrix._updateID;
              this._uvUpdateId = uvBuffer._updateID;
              textureMatrix.multiplyUvs(uvs, transformedUvs);
            }
          }
          return transformedUvs;
        }
        get positions() {
          return this.geometry.positions;
        }
        get indices() {
          return this.geometry.indices;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        get groupTransform() {
          return this.renderable.groupTransform;
        }
        get attributeSize() {
          return this.geometry.positions.length / 2;
        }
        get indexSize() {
          return this.geometry.indices.length;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/MeshPipe.mjs
  var MeshPipe;
  var init_MeshPipe = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/MeshPipe.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_BindGroup();
      init_UniformGroup2();
      init_getAdjustedBlendModeBlend();
      init_PoolGroup();
      init_colorToUniform();
      init_BatchableMesh();
      MeshPipe = class {
        constructor(renderer, adaptor) {
          this.localUniforms = new UniformGroup2({
            uTransformMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          this.localUniformsBindGroup = new BindGroup({
            0: this.localUniforms
          });
          this._meshDataHash = /* @__PURE__ */ Object.create(null);
          this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init();
        }
        validateRenderable(mesh) {
          const meshData = this._getMeshData(mesh);
          const wasBatched = meshData.batched;
          const isBatched = mesh.batched;
          meshData.batched = isBatched;
          if (wasBatched !== isBatched) {
            return true;
          } else if (isBatched) {
            const geometry = mesh._geometry;
            if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
              meshData.indexSize = geometry.indices.length;
              meshData.vertexSize = geometry.positions.length;
              return true;
            }
            const batchableMesh = this._getBatchableMesh(mesh);
            const texture = mesh.texture;
            if (batchableMesh.texture._source !== texture._source) {
              if (batchableMesh.texture._source !== texture._source) {
                return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);
              }
            }
          }
          return false;
        }
        addRenderable(mesh, instructionSet) {
          const batcher = this.renderer.renderPipes.batch;
          const { batched } = this._getMeshData(mesh);
          if (batched) {
            const gpuBatchableMesh = this._getBatchableMesh(mesh);
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            batcher.addToBatch(gpuBatchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            instructionSet.add(mesh);
          }
        }
        updateRenderable(mesh) {
          if (mesh.batched) {
            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
            gpuBatchableMesh.texture = mesh._texture;
            gpuBatchableMesh.geometry = mesh._geometry;
            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
          }
        }
        destroyRenderable(mesh) {
          this._meshDataHash[mesh.uid] = null;
          const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
          if (gpuMesh) {
            BigPool.return(gpuMesh);
            this._gpuBatchableMeshHash[mesh.uid] = null;
          }
          mesh.off("destroyed", this._destroyRenderableBound);
        }
        execute(mesh) {
          if (!mesh.isRenderable)
            return;
          mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
          const localUniforms = this.localUniforms;
          localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
          localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
          localUniforms.update();
          color32BitToUniform(
            mesh.groupColorAlpha,
            localUniforms.uniforms.uColor,
            0
          );
          this._adaptor.execute(this, mesh);
        }
        _getMeshData(mesh) {
          return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
        }
        _initMeshData(mesh) {
          this._meshDataHash[mesh.uid] = {
            batched: mesh.batched,
            indexSize: mesh._geometry.indices?.length,
            vertexSize: mesh._geometry.positions?.length
          };
          mesh.on("destroyed", this._destroyRenderableBound);
          return this._meshDataHash[mesh.uid];
        }
        _getBatchableMesh(mesh) {
          return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
        }
        _initBatchableMesh(mesh) {
          const gpuMesh = BigPool.get(BatchableMesh);
          gpuMesh.renderable = mesh;
          gpuMesh.texture = mesh._texture;
          gpuMesh.transform = mesh.groupTransform;
          gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
          this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
          return gpuMesh;
        }
        destroy() {
          for (const i2 in this._gpuBatchableMeshHash) {
            if (this._gpuBatchableMeshHash[i2]) {
              BigPool.return(this._gpuBatchableMeshHash[i2]);
            }
          }
          this._gpuBatchableMeshHash = null;
          this._meshDataHash = null;
          this.localUniforms = null;
          this.localUniformsBindGroup = null;
          this._adaptor.destroy();
          this._adaptor = null;
          this.renderer = null;
        }
      };
      MeshPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/init.mjs
  var init_init7 = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/init.mjs"() {
      init_Extensions();
      init_MeshPipe();
      extensions3.add(MeshPipe);
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/BatchableSprite.mjs
  var BatchableSprite;
  var init_BatchableSprite = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/BatchableSprite.mjs"() {
      "use strict";
      BatchableSprite = class {
        constructor() {
          this.batcherName = "default";
          this.attributeSize = 4;
          this.indexSize = 6;
          this.packAsQuad = true;
          this.roundPixels = 0;
          this._attributeStart = 0;
          this._batcher = null;
          this._batch = null;
        }
        get blendMode() {
          return this.renderable.groupBlendMode;
        }
        get color() {
          return this.renderable.groupColorAlpha;
        }
        reset() {
          this.renderable = null;
          this.texture = null;
          this._batcher = null;
          this._batch = null;
          this.bounds = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextPipe.mjs
  var CanvasTextPipe;
  var init_CanvasTextPipe = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
      init_Extensions();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      CanvasTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.runners.resolutionChange.add(this);
        }
        resolutionChange() {
          for (const i2 in this._gpuText) {
            const gpuText = this._gpuText[i2];
            if (!gpuText)
              continue;
            const text = gpuText.batchableSprite.renderable;
            if (text._autoResolution) {
              text._resolution = this._renderer.resolution;
              text.onViewUpdate();
            }
          }
        }
        validateRenderable(text) {
          const gpuText = this._getGpuText(text);
          const newKey = text._getKey();
          if (gpuText.currentKey !== newKey) {
            const { width, height } = this._renderer.canvasText.getTextureSize(
              text.text,
              text.resolution,
              text._style
            );
            if (this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height) {
              return false;
            }
            return true;
          }
          return false;
        }
        addRenderable(text, instructionSet) {
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (text._didTextUpdate) {
            this._updateText(text);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
        }
        updateRenderable(text) {
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (text._didTextUpdate) {
            this._updateText(text);
          }
          batchableSprite._batcher.updateElement(batchableSprite);
        }
        destroyRenderable(text) {
          text.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableById(text.uid);
        }
        _destroyRenderableById(textUid) {
          const gpuText = this._gpuText[textUid];
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[textUid] = null;
        }
        _updateText(text) {
          const newKey = text._getKey();
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(text);
          }
          text._didTextUpdate = false;
          const padding = text._style.padding;
          updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);
        }
        _updateGpuText(text) {
          const gpuText = this._getGpuText(text);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.texture) {
            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
          }
          gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);
          gpuText.currentKey = text._getKey();
          batchableSprite.texture = gpuText.texture;
        }
        _getGpuText(text) {
          return this._gpuText[text.uid] || this.initGpuText(text);
        }
        initGpuText(text) {
          const gpuTextData = {
            texture: null,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite)
          };
          gpuTextData.batchableSprite.renderable = text;
          gpuTextData.batchableSprite.transform = text.groupTransform;
          gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;
          this._gpuText[text.uid] = gpuTextData;
          text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          this._updateText(text);
          text.on("destroyed", this._destroyRenderableBound);
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      CanvasTextPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "text"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/CanvasPool.mjs
  var CanvasPoolClass, CanvasPool;
  var init_CanvasPool = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
      init_adapter2();
      init_pow22();
      CanvasPoolClass = class {
        constructor(canvasOptions) {
          this._canvasPool = /* @__PURE__ */ Object.create(null);
          this.canvasOptions = canvasOptions || {};
          this.enableFullScreen = false;
        }
        _createCanvasAndContext(pixelWidth, pixelHeight) {
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = pixelWidth;
          canvas.height = pixelHeight;
          const context3 = canvas.getContext("2d");
          return { canvas, context: context3 };
        }
        getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
          minWidth = Math.ceil(minWidth * resolution - 1e-6);
          minHeight = Math.ceil(minHeight * resolution - 1e-6);
          minWidth = nextPow22(minWidth);
          minHeight = nextPow22(minHeight);
          const key = (minWidth << 17) + (minHeight << 1);
          if (!this._canvasPool[key]) {
            this._canvasPool[key] = [];
          }
          let canvasAndContext = this._canvasPool[key].pop();
          if (!canvasAndContext) {
            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
          }
          return canvasAndContext;
        }
        returnCanvasAndContext(canvasAndContext) {
          const canvas = canvasAndContext.canvas;
          const { width, height } = canvas;
          const key = (width << 17) + (height << 1);
          this._canvasPool[key].push(canvasAndContext);
        }
        clear() {
          this._canvasPool = {};
        }
      };
      CanvasPool = new CanvasPoolClass();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TexturePool.mjs
  var count, TexturePoolClass, TexturePool;
  var init_TexturePool = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
      init_pow22();
      init_TextureSource();
      init_Texture2();
      count = 0;
      TexturePoolClass = class {
        constructor(textureOptions) {
          this._poolKeyHash = /* @__PURE__ */ Object.create(null);
          this._texturePool = {};
          this.textureOptions = textureOptions || {};
          this.enableFullScreen = false;
        }
        createTexture(pixelWidth, pixelHeight, antialias) {
          const textureSource = new TextureSource({
            ...this.textureOptions,
            width: pixelWidth,
            height: pixelHeight,
            resolution: 1,
            antialias,
            autoGarbageCollect: true
          });
          return new Texture2({
            source: textureSource,
            label: `texturePool_${count++}`
          });
        }
        getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
          let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
          let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
          po2Width = nextPow22(po2Width);
          po2Height = nextPow22(po2Height);
          const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
          if (!this._texturePool[key]) {
            this._texturePool[key] = [];
          }
          let texture = this._texturePool[key].pop();
          if (!texture) {
            texture = this.createTexture(po2Width, po2Height, antialias);
          }
          texture.source._resolution = resolution;
          texture.source.width = po2Width / resolution;
          texture.source.height = po2Height / resolution;
          texture.source.pixelWidth = po2Width;
          texture.source.pixelHeight = po2Height;
          texture.frame.x = 0;
          texture.frame.y = 0;
          texture.frame.width = frameWidth;
          texture.frame.height = frameHeight;
          texture.updateUvs();
          this._poolKeyHash[texture.uid] = key;
          return texture;
        }
        getSameSizeTexture(texture, antialias = false) {
          const source2 = texture.source;
          return this.getOptimalTexture(texture.width, texture.height, source2._resolution, antialias);
        }
        returnTexture(renderTexture) {
          const key = this._poolKeyHash[renderTexture.uid];
          this._texturePool[key].push(renderTexture);
        }
        clear(destroyTextures) {
          destroyTextures = destroyTextures !== false;
          if (destroyTextures) {
            for (const i2 in this._texturePool) {
              const textures = this._texturePool[i2];
              if (textures) {
                for (let j2 = 0; j2 < textures.length; j2++) {
                  textures[j2].destroy(true);
                }
              }
            }
          }
          this._texturePool = {};
        }
      };
      TexturePool = new TexturePoolClass();
    }
  });

  // node_modules/pixi-v8/lib/utils/canvas/getCanvasBoundingBox.mjs
  function checkRow2(data, width, y2) {
    for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function checkColumn2(data, width, x2, top, bottom) {
    const stride = 4 * width;
    for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
      if (data[index + 3] !== 0)
        return false;
    }
    return true;
  }
  function getCanvasBoundingBox2(canvas, resolution = 1) {
    const { width, height } = canvas;
    const context3 = canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (context3 === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    const imageData = context3.getImageData(0, 0, width, height);
    const data = imageData.data;
    let left = 0;
    let top = 0;
    let right = width - 1;
    let bottom = height - 1;
    while (top < height && checkRow2(data, width, top))
      ++top;
    if (top === height)
      return Rectangle2.EMPTY;
    while (checkRow2(data, width, bottom))
      --bottom;
    while (checkColumn2(data, width, left, top, bottom))
      ++left;
    while (checkColumn2(data, width, right, top, bottom))
      --right;
    ++right;
    ++bottom;
    return new Rectangle2(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
  }
  var init_getCanvasBoundingBox2 = __esm({
    "node_modules/pixi-v8/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
      init_Rectangle2();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillGradient.mjs
  var _FillGradient, FillGradient;
  var init_FillGradient = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
      init_Color2();
      init_adapter2();
      init_Matrix2();
      init_ImageSource();
      init_Texture2();
      init_uid2();
      _FillGradient = class _FillGradient2 {
        constructor(x0, y0, x1, y1) {
          this.uid = uid2("fillGradient");
          this.type = "linear";
          this.gradientStops = [];
          this._styleKey = null;
          this.x0 = x0;
          this.y0 = y0;
          this.x1 = x1;
          this.y1 = y1;
        }
        addColorStop(offset, color) {
          this.gradientStops.push({ offset, color: Color2.shared.setValue(color).toHexa() });
          this._styleKey = null;
          return this;
        }
        buildLinearGradient() {
          const defaultSize = _FillGradient2.defaultTextureSize;
          const { gradientStops } = this;
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = defaultSize;
          canvas.height = defaultSize;
          const ctx = canvas.getContext("2d");
          const gradient = ctx.createLinearGradient(0, 0, _FillGradient2.defaultTextureSize, 1);
          for (let i2 = 0; i2 < gradientStops.length; i2++) {
            const stop = gradientStops[i2];
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, defaultSize, defaultSize);
          this.texture = new Texture2({
            source: new ImageSource({
              resource: canvas,
              addressModeU: "clamp-to-edge",
              addressModeV: "repeat"
            })
          });
          const { x0, y0, x1, y1 } = this;
          const m2 = new Matrix2();
          const dx = x1 - x0;
          const dy = y1 - y0;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          m2.translate(-x0, -y0);
          m2.scale(1 / defaultSize, 1 / defaultSize);
          m2.rotate(-angle);
          m2.scale(256 / dist, 1);
          this.transform = m2;
          this._styleKey = null;
        }
        get styleKey() {
          if (this._styleKey) {
            return this._styleKey;
          }
          const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join("-");
          const texture = this.texture.uid;
          const transform2 = this.transform.toArray().join("-");
          return `fill-gradient-${this.uid}-${stops}-${texture}-${transform2}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
        }
      };
      _FillGradient.defaultTextureSize = 256;
      FillGradient = _FillGradient;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillPattern.mjs
  var repetitionMap, FillPattern;
  var init_FillPattern = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
      init_Matrix2();
      init_uid2();
      repetitionMap = {
        repeat: {
          addressModeU: "repeat",
          addressModeV: "repeat"
        },
        "repeat-x": {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge"
        },
        "repeat-y": {
          addressModeU: "clamp-to-edge",
          addressModeV: "repeat"
        },
        "no-repeat": {
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      };
      FillPattern = class {
        constructor(texture, repetition) {
          this.uid = uid2("fillPattern");
          this.transform = new Matrix2();
          this._styleKey = null;
          this.texture = texture;
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          if (repetition) {
            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
          }
        }
        setTransform(transform2) {
          const texture = this.texture;
          this.transform.copyFrom(transform2);
          this.transform.invert();
          this.transform.scale(
            1 / texture.frame.width,
            1 / texture.frame.height
          );
          this._styleKey = null;
        }
        get styleKey() {
          if (this._styleKey)
            return this._styleKey;
          this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
          return this._styleKey;
        }
      };
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse3;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse3(path3) {
        var data = [];
        path3.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type])
              throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
  function SVGToGraphicsPath(svgPath, path3) {
    const commands = (0, import_parse_svg_path.default)(svgPath);
    const subpaths = [];
    let currentSubPath = null;
    let lastX = 0;
    let lastY = 0;
    for (let i2 = 0; i2 < commands.length; i2++) {
      const command = commands[i2];
      const type = command[0];
      const data = command;
      switch (type) {
        case "M":
          lastX = data[1];
          lastY = data[2];
          path3.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += data[1];
          lastY += data[2];
          path3.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = data[1];
          path3.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += data[1];
          path3.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = data[1];
          path3.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += data[1];
          path3.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = data[1];
          lastY = data[2];
          path3.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += data[1];
          lastY += data[2];
          path3.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = data[5];
          lastY = data[6];
          path3.bezierCurveTo(
            data[1],
            data[2],
            data[3],
            data[4],
            lastX,
            lastY
          );
          break;
        case "c":
          path3.bezierCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4],
            lastX + data[5],
            lastY + data[6]
          );
          lastX += data[5];
          lastY += data[6];
          break;
        case "S":
          lastX = data[3];
          lastY = data[4];
          path3.bezierCurveToShort(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "s":
          path3.bezierCurveToShort(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "Q":
          lastX = data[3];
          lastY = data[4];
          path3.quadraticCurveTo(
            data[1],
            data[2],
            lastX,
            lastY
          );
          break;
        case "q":
          path3.quadraticCurveTo(
            lastX + data[1],
            lastY + data[2],
            lastX + data[3],
            lastY + data[4]
          );
          lastX += data[3];
          lastY += data[4];
          break;
        case "T":
          lastX = data[1];
          lastY = data[2];
          path3.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "t":
          lastX += data[1];
          lastY += data[2];
          path3.quadraticCurveToShort(
            lastX,
            lastY
          );
          break;
        case "A":
          lastX = data[6];
          lastY = data[7];
          path3.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "a":
          lastX += data[6];
          lastY += data[7];
          path3.arcToSvg(
            data[1],
            data[2],
            data[3],
            data[4],
            data[5],
            lastX,
            lastY
          );
          break;
        case "Z":
        case "z":
          path3.closePath();
          if (subpaths.length > 0) {
            currentSubPath = subpaths.pop();
            if (currentSubPath) {
              lastX = currentSubPath.startX;
              lastY = currentSubPath.startY;
            } else {
              lastX = 0;
              lastY = 0;
            }
          }
          currentSubPath = null;
          break;
        default:
          warn(`Unknown SVG path command: ${type}`);
      }
      if (type !== "Z" && type !== "z") {
        if (currentSubPath === null) {
          currentSubPath = { startX: lastX, startY: lastY };
          subpaths.push(currentSubPath);
        }
      }
    }
    return path3;
  }
  var import_parse_svg_path;
  var init_SVGToGraphicsPath = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
      import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
      init_warn();
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Circle.mjs
  var Circle2;
  var init_Circle2 = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Circle.mjs"() {
      init_Rectangle2();
      Circle2 = class {
        constructor(x2 = 0, y2 = 0, radius = 0) {
          this.type = "circle";
          this.x = x2;
          this.y = y2;
          this.radius = radius;
        }
        clone() {
          return new Circle2(this.x, this.y, this.radius);
        }
        contains(x2, y2) {
          if (this.radius <= 0)
            return false;
          const r2 = this.radius * this.radius;
          let dx = this.x - x2;
          let dy = this.y - y2;
          dx *= dx;
          dy *= dy;
          return dx + dy <= r2;
        }
        strokeContains(x2, y2, width) {
          if (this.radius === 0)
            return false;
          const dx = this.x - x2;
          const dy = this.y - y2;
          const r2 = this.radius;
          const w2 = width / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < r2 + w2 && distance > r2 - w2;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle2();
          out2.x = this.x - this.radius;
          out2.y = this.y - this.radius;
          out2.width = this.radius * 2;
          out2.height = this.radius * 2;
          return out2;
        }
        copyFrom(circle) {
          this.x = circle.x;
          this.y = circle.y;
          this.radius = circle.radius;
          return this;
        }
        copyTo(circle) {
          circle.copyFrom(this);
          return circle;
        }
        toString() {
          return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Ellipse.mjs
  var Ellipse2;
  var init_Ellipse2 = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Ellipse.mjs"() {
      init_Rectangle2();
      Ellipse2 = class {
        constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
          this.type = "ellipse";
          this.x = x2;
          this.y = y2;
          this.halfWidth = halfWidth;
          this.halfHeight = halfHeight;
        }
        clone() {
          return new Ellipse2(this.x, this.y, this.halfWidth, this.halfHeight);
        }
        contains(x2, y2) {
          if (this.halfWidth <= 0 || this.halfHeight <= 0) {
            return false;
          }
          let normx = (x2 - this.x) / this.halfWidth;
          let normy = (y2 - this.y) / this.halfHeight;
          normx *= normx;
          normy *= normy;
          return normx + normy <= 1;
        }
        strokeContains(x2, y2, width) {
          const { halfWidth, halfHeight } = this;
          if (halfWidth <= 0 || halfHeight <= 0) {
            return false;
          }
          const halfStrokeWidth = width / 2;
          const innerA = halfWidth - halfStrokeWidth;
          const innerB = halfHeight - halfStrokeWidth;
          const outerA = halfWidth + halfStrokeWidth;
          const outerB = halfHeight + halfStrokeWidth;
          const normalizedX = x2 - this.x;
          const normalizedY = y2 - this.y;
          const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
          const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
          return innerEllipse > 1 && outerEllipse <= 1;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle2();
          out2.x = this.x - this.halfWidth;
          out2.y = this.y - this.halfHeight;
          out2.width = this.halfWidth * 2;
          out2.height = this.halfHeight * 2;
          return out2;
        }
        copyFrom(ellipse) {
          this.x = ellipse.x;
          this.y = ellipse.y;
          this.halfWidth = ellipse.halfWidth;
          this.halfHeight = ellipse.halfHeight;
          return this;
        }
        copyTo(ellipse) {
          ellipse.copyFrom(this);
          return ellipse;
        }
        toString() {
          return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/misc/squaredDistanceToLineSegment.mjs
  function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
    const a2 = x2 - x1;
    const b2 = y2 - y1;
    const c2 = x22 - x1;
    const d2 = y22 - y1;
    const dot = a2 * c2 + b2 * d2;
    const lenSq = c2 * c2 + d2 * d2;
    let param = -1;
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    let xx;
    let yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x22;
      yy = y22;
    } else {
      xx = x1 + param * c2;
      yy = y1 + param * d2;
    }
    const dx = x2 - xx;
    const dy = y2 - yy;
    return dx * dx + dy * dy;
  }
  var init_squaredDistanceToLineSegment = __esm({
    "node_modules/pixi-v8/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/Polygon.mjs
  var Polygon2;
  var init_Polygon2 = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/Polygon.mjs"() {
      init_squaredDistanceToLineSegment();
      init_Rectangle2();
      Polygon2 = class {
        constructor(...points) {
          this.type = "polygon";
          let flat = Array.isArray(points[0]) ? points[0] : points;
          if (typeof flat[0] !== "number") {
            const p2 = [];
            for (let i2 = 0, il = flat.length; i2 < il; i2++) {
              p2.push(flat[i2].x, flat[i2].y);
            }
            flat = p2;
          }
          this.points = flat;
          this.closePath = true;
        }
        clone() {
          const points = this.points.slice();
          const polygon = new Polygon2(points);
          polygon.closePath = this.closePath;
          return polygon;
        }
        contains(x2, y2) {
          let inside = false;
          const length = this.points.length / 2;
          for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
            const xi = this.points[i2 * 2];
            const yi = this.points[i2 * 2 + 1];
            const xj = this.points[j2 * 2];
            const yj = this.points[j2 * 2 + 1];
            const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
            if (intersect) {
              inside = !inside;
            }
          }
          return inside;
        }
        strokeContains(x2, y2, strokeWidth) {
          const halfStrokeWidth = strokeWidth / 2;
          const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
          const { points } = this;
          const iterationLength = points.length - (this.closePath ? 0 : 2);
          for (let i2 = 0; i2 < iterationLength; i2 += 2) {
            const x1 = points[i2];
            const y1 = points[i2 + 1];
            const x22 = points[(i2 + 2) % points.length];
            const y22 = points[(i2 + 3) % points.length];
            const distanceSqrd = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
            if (distanceSqrd <= halfStrokeWidthSqrd) {
              return true;
            }
          }
          return false;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle2();
          const points = this.points;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
            const x2 = points[i2];
            const y2 = points[i2 + 1];
            minX = x2 < minX ? x2 : minX;
            maxX = x2 > maxX ? x2 : maxX;
            minY = y2 < minY ? y2 : minY;
            maxY = y2 > maxY ? y2 : maxY;
          }
          out2.x = minX;
          out2.width = maxX - minX;
          out2.y = minY;
          out2.height = maxY - minY;
          return out2;
        }
        copyFrom(polygon) {
          this.points = polygon.points.slice();
          this.closePath = polygon.closePath;
          return this;
        }
        copyTo(polygon) {
          polygon.copyFrom(this);
          return polygon;
        }
        toString() {
          return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
        }
        get lastX() {
          return this.points[this.points.length - 2];
        }
        get lastY() {
          return this.points[this.points.length - 1];
        }
        get x() {
          return this.points[this.points.length - 2];
        }
        get y() {
          return this.points[this.points.length - 1];
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/maths/shapes/RoundedRectangle.mjs
  var isCornerWithinStroke, RoundedRectangle2;
  var init_RoundedRectangle2 = __esm({
    "node_modules/pixi-v8/lib/maths/shapes/RoundedRectangle.mjs"() {
      init_Rectangle2();
      isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {
        const dx = pX - cornerX;
        const dy = pY - cornerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;
      };
      RoundedRectangle2 = class {
        constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
          this.type = "roundedRectangle";
          this.x = x2;
          this.y = y2;
          this.width = width;
          this.height = height;
          this.radius = radius;
        }
        getBounds(out2) {
          out2 = out2 || new Rectangle2();
          out2.x = this.x;
          out2.y = this.y;
          out2.width = this.width;
          out2.height = this.height;
          return out2;
        }
        clone() {
          return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
        }
        copyFrom(rectangle) {
          this.x = rectangle.x;
          this.y = rectangle.y;
          this.width = rectangle.width;
          this.height = rectangle.height;
          return this;
        }
        copyTo(rectangle) {
          rectangle.copyFrom(this);
          return rectangle;
        }
        contains(x2, y2) {
          if (this.width <= 0 || this.height <= 0) {
            return false;
          }
          if (x2 >= this.x && x2 <= this.x + this.width) {
            if (y2 >= this.y && y2 <= this.y + this.height) {
              const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
              if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
                return true;
              }
              let dx = x2 - (this.x + radius);
              let dy = y2 - (this.y + radius);
              const radius2 = radius * radius;
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + this.width - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dy = y2 - (this.y + this.height - radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
              dx = x2 - (this.x + radius);
              if (dx * dx + dy * dy <= radius2) {
                return true;
              }
            }
          }
          return false;
        }
        strokeContains(pX, pY, strokeWidth) {
          const { x: x2, y: y2, width, height, radius } = this;
          const halfStrokeWidth = strokeWidth / 2;
          const innerX = x2 + radius;
          const innerY = y2 + radius;
          const innerWidth = width - radius * 2;
          const innerHeight = height - radius * 2;
          const rightBound = x2 + width;
          const bottomBound = y2 + height;
          if ((pX >= x2 - halfStrokeWidth && pX <= x2 + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {
            return true;
          }
          if ((pY >= y2 - halfStrokeWidth && pY <= y2 + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {
            return true;
          }
          return pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth);
        }
        toString() {
          return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
  function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x34 = (x3 + x4) / 2;
    const y34 = (y3 + y4) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    const x234 = (x23 + x34) / 2;
    const y234 = (y23 + y34) / 2;
    const x1234 = (x123 + x234) / 2;
    const y1234 = (y123 + y234) / 2;
    if (level > 0) {
      let dx = x4 - x1;
      let dy = y4 - y1;
      const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      let da1;
      let da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          const a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < mAngleTolerance) {
            points.push(x1234, y1234);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
            if (da2 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else if (d2 > FLT_EPSILON) {
        if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x2, y2);
              return;
            }
          }
        }
      } else if (d3 > FLT_EPSILON) {
        if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
          if (mAngleTolerance < curveAngleToleranceEpsilon) {
            points.push(x1234, y1234);
            return;
          }
          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da1 < mAngleTolerance) {
            points.push(x2, y2);
            points.push(x3, y3);
            return;
          }
          if (mCuspLimit !== 0) {
            if (da1 > mCuspLimit) {
              points.push(x3, y3);
              return;
            }
          }
        }
      } else {
        dx = x1234 - (x1 + x4) / 2;
        dy = y1234 - (y1 + y4) / 2;
        if (dx * dx + dy * dy <= distanceTolerance) {
          points.push(x1234, y1234);
          return;
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
  var init_buildAdaptiveBezier = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT = 8;
      FLT_EPSILON = 11920929e-14;
      PATH_DISTANCE_EPSILON = 1;
      curveAngleToleranceEpsilon = 0.01;
      mAngleTolerance = 0;
      mCuspLimit = 0;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
  function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    const scale = 1;
    const smoothing = Math.min(
      0.99,
      Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
    );
    let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
    distanceTolerance *= distanceTolerance;
    begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
    return points;
  }
  function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
    recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
    points.push(eX, eY);
  }
  function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (level > RECURSION_LIMIT2) {
      return;
    }
    const pi = Math.PI;
    const x12 = (x1 + x2) / 2;
    const y12 = (y1 + y2) / 2;
    const x23 = (x2 + x3) / 2;
    const y23 = (y2 + y3) / 2;
    const x123 = (x12 + x23) / 2;
    const y123 = (y12 + y23) / 2;
    let dx = x3 - x1;
    let dy = y3 - y1;
    const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
    if (d2 > FLT_EPSILON2) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
          points.push(x123, y123);
          return;
        }
        let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da >= pi)
          da = 2 * pi - da;
        if (da < mAngleTolerance2) {
          points.push(x123, y123);
          return;
        }
      }
    } else {
      dx = x123 - (x1 + x3) / 2;
      dy = y123 - (y1 + y3) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x123, y123);
        return;
      }
    }
    recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
    recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
  }
  var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
  var init_buildAdaptiveQuadratic = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
      init_GraphicsContextSystem();
      RECURSION_LIMIT2 = 8;
      FLT_EPSILON2 = 11920929e-14;
      PATH_DISTANCE_EPSILON2 = 1;
      curveAngleToleranceEpsilon2 = 0.01;
      mAngleTolerance2 = 0;
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArc.mjs
  function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
    let dist = Math.abs(start - end);
    if (!clockwise && start > end) {
      dist = 2 * Math.PI - dist;
    } else if (clockwise && end > start) {
      dist = 2 * Math.PI - dist;
    }
    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
    steps = Math.max(steps, 3);
    let f2 = dist / steps;
    let t2 = start;
    f2 *= clockwise ? -1 : 1;
    for (let i2 = 0; i2 < steps + 1; i2++) {
      const cs = Math.cos(t2);
      const sn = Math.sin(t2);
      const nx = x2 + cs * radius;
      const ny = y2 + sn * radius;
      points.push(nx, ny);
      t2 += f2;
    }
  }
  var init_buildArc = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
  function buildArcTo(points, x1, y1, x2, y2, radius) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    buildArc(
      points,
      cx + x1,
      cy + y1,
      radius,
      startAngle,
      endAngle,
      b1 * a2 > b2 * a1
    );
  }
  var init_buildArcTo = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
      init_buildArc();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
  function approxUnitArc(ang1, ang2) {
    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
    const x1 = Math.cos(ang1);
    const y1 = Math.sin(ang1);
    const x2 = Math.cos(ang1 + ang2);
    const y2 = Math.sin(ang1 + ang2);
    return [
      {
        x: x1 - y1 * a2,
        y: y1 + x1 * a2
      },
      {
        x: x2 + y2 * a2,
        y: y2 - x2 * a2
      },
      {
        x: x2,
        y: y2
      }
    ];
  }
  function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (rx === 0 || ry === 0) {
      return;
    }
    const sinPhi = Math.sin(xAxisRotation * TAU / 360);
    const cosPhi = Math.cos(xAxisRotation * TAU / 360);
    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return;
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    getArcCenter(
      px,
      py,
      cx,
      cy,
      rx,
      ry,
      largeArcFlag,
      sweepFlag,
      sinPhi,
      cosPhi,
      pxp,
      pyp,
      out
    );
    let { ang1, ang2 } = out;
    const { centerX, centerY } = out;
    let ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    const segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    let lastX = points[points.length - 2];
    let lastY = points[points.length - 1];
    const outCurvePoint = { x: 0, y: 0 };
    for (let i2 = 0; i2 < segments; i2++) {
      const curve = approxUnitArc(ang1, ang2);
      const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
      buildAdaptiveBezier(
        points,
        lastX,
        lastY,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3
      );
      lastX = x3;
      lastY = y3;
      ang1 += ang2;
    }
  }
  var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
  var init_buildArcToSvg = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
      init_buildAdaptiveBezier();
      TAU = Math.PI * 2;
      out = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
      };
      mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
        x2 *= rx;
        y2 *= ry;
        const xp = cosPhi * x2 - sinPhi * y2;
        const yp = sinPhi * x2 + cosPhi * y2;
        out2.x = xp + centerX;
        out2.y = yp + centerY;
        return out2;
      };
      vectorAngle = (ux3, uy3, vx3, vy3) => {
        const sign2 = ux3 * vy3 - uy3 * vx3 < 0 ? -1 : 1;
        let dot = ux3 * vx3 + uy3 * vy3;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign2 * Math.acos(dot);
      };
      getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
        const rxSq = Math.pow(rx, 2);
        const rySq = Math.pow(ry, 2);
        const pxpSq = Math.pow(pxp, 2);
        const pypSq = Math.pow(pyp, 2);
        let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxSq * pypSq + rySq * pxpSq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        const centerXp = radicant * rx / ry * pyp;
        const centerYp = radicant * -ry / rx * pxp;
        const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
        const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
        const vx1 = (pxp - centerXp) / rx;
        const vy1 = (pyp - centerYp) / ry;
        const vx22 = (-pxp - centerXp) / rx;
        const vy22 = (-pyp - centerYp) / ry;
        const ang1 = vectorAngle(1, 0, vx1, vy1);
        let ang2 = vectorAngle(vx1, vy1, vx22, vy22);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        out2.centerX = centerX;
        out2.centerY = centerY;
        out2.ang1 = ang1;
        out2.ang2 = ang2;
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/path/roundShape.mjs
  function roundedShapeArc(g2, points, radius) {
    const vecFrom = (p2, pp) => {
      const x2 = pp.x - p2.x;
      const y2 = pp.y - p2.y;
      const len = Math.sqrt(x2 * x2 + y2 * y2);
      const nx = x2 / len;
      const ny = y2 / len;
      return { len, nx, ny };
    };
    const sharpCorner = (i2, p2) => {
      if (i2 === 0) {
        g2.moveTo(p2.x, p2.y);
      } else {
        g2.lineTo(p2.x, p2.y);
      }
    };
    let p1 = points[points.length - 1];
    for (let i2 = 0; i2 < points.length; i2++) {
      const p2 = points[i2 % points.length];
      const pRadius = p2.radius ?? radius;
      if (pRadius <= 0) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      const p3 = points[(i2 + 1) % points.length];
      const v1 = vecFrom(p2, p1);
      const v2 = vecFrom(p2, p3);
      if (v1.len < 1e-4 || v2.len < 1e-4) {
        sharpCorner(i2, p2);
        p1 = p2;
        continue;
      }
      let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
      let radDirection = 1;
      let drawDirection = false;
      if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
        if (angle < 0) {
          angle = Math.PI + angle;
        } else {
          angle = Math.PI - angle;
          radDirection = -1;
          drawDirection = true;
        }
      } else if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
      const halfAngle = angle / 2;
      let cRadius;
      let lenOut = Math.abs(
        Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
      );
      if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
        lenOut = Math.min(v1.len / 2, v2.len / 2);
        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
      } else {
        cRadius = pRadius;
      }
      const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
      const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
      const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
      const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      if (i2 === 0) {
        g2.moveTo(
          cX + Math.cos(startAngle) * cRadius,
          cY + Math.sin(startAngle) * cRadius
        );
      }
      g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
      p1 = p2;
    }
  }
  function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
    const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    const pointLerp = (p1, p2, t2) => ({
      x: p1.x + (p2.x - p1.x) * t2,
      y: p1.y + (p2.y - p1.y) * t2
    });
    const numPoints = points.length;
    for (let i2 = 0; i2 < numPoints; i2++) {
      const thisPoint = points[(i2 + 1) % numPoints];
      const pRadius = thisPoint.radius ?? radius;
      if (pRadius <= 0) {
        if (i2 === 0) {
          g2.moveTo(thisPoint.x, thisPoint.y);
        } else {
          g2.lineTo(thisPoint.x, thisPoint.y);
        }
        continue;
      }
      const lastPoint = points[i2];
      const nextPoint = points[(i2 + 2) % numPoints];
      const lastEdgeLength = distance(lastPoint, thisPoint);
      let start;
      if (lastEdgeLength < 1e-4) {
        start = thisPoint;
      } else {
        const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
        start = pointLerp(
          thisPoint,
          lastPoint,
          lastOffsetDistance / lastEdgeLength
        );
      }
      const nextEdgeLength = distance(nextPoint, thisPoint);
      let end;
      if (nextEdgeLength < 1e-4) {
        end = thisPoint;
      } else {
        const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
        end = pointLerp(
          thisPoint,
          nextPoint,
          nextOffsetDistance / nextEdgeLength
        );
      }
      if (i2 === 0) {
        g2.moveTo(start.x, start.y);
      } else {
        g2.lineTo(start.x, start.y);
      }
      g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
    }
  }
  var init_roundShape = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/path/roundShape.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/path/ShapePath.mjs
  var tempRectangle2, ShapePath;
  var init_ShapePath = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/path/ShapePath.mjs"() {
      init_Circle2();
      init_Ellipse2();
      init_Polygon2();
      init_Rectangle2();
      init_RoundedRectangle2();
      init_Bounds2();
      init_buildAdaptiveBezier();
      init_buildAdaptiveQuadratic();
      init_buildArc();
      init_buildArcTo();
      init_buildArcToSvg();
      init_roundShape();
      tempRectangle2 = new Rectangle2();
      ShapePath = class {
        constructor(graphicsPath2D) {
          this.shapePrimitives = [];
          this._currentPoly = null;
          this._bounds = new Bounds2();
          this._graphicsPath2D = graphicsPath2D;
        }
        moveTo(x2, y2) {
          this.startPoly(x2, y2);
          return this;
        }
        lineTo(x2, y2) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          const fromX = points[points.length - 2];
          const fromY = points[points.length - 1];
          if (fromX !== x2 || fromY !== y2) {
            points.push(x2, y2);
          }
          return this;
        }
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._ensurePoly(false);
          const points = this._currentPoly.points;
          buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
          return this;
        }
        arcTo(x1, y1, x2, y2, radius) {
          this._ensurePoly();
          const points = this._currentPoly.points;
          buildArcTo(points, x1, y1, x2, y2, radius);
          return this;
        }
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          const points = this._currentPoly.points;
          buildArcToSvg(
            points,
            this._currentPoly.lastX,
            this._currentPoly.lastY,
            x2,
            y2,
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag
          );
          return this;
        }
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveBezier(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            cp2x,
            cp2y,
            x2,
            y2,
            smoothness
          );
          return this;
        }
        quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
          this._ensurePoly();
          const currentPoly = this._currentPoly;
          buildAdaptiveQuadratic(
            this._currentPoly.points,
            currentPoly.lastX,
            currentPoly.lastY,
            cp1x,
            cp1y,
            x2,
            y2,
            smoothing
          );
          return this;
        }
        closePath() {
          this.endPoly(true);
          return this;
        }
        addPath(path3, transform2) {
          this.endPoly();
          if (transform2 && !transform2.isIdentity()) {
            path3 = path3.clone(true);
            path3.transform(transform2);
          }
          for (let i2 = 0; i2 < path3.instructions.length; i2++) {
            const instruction = path3.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          return this;
        }
        finish(closePath = false) {
          this.endPoly(closePath);
        }
        rect(x2, y2, w2, h2, transform2) {
          this.drawShape(new Rectangle2(x2, y2, w2, h2), transform2);
          return this;
        }
        circle(x2, y2, radius, transform2) {
          this.drawShape(new Circle2(x2, y2, radius), transform2);
          return this;
        }
        poly(points, close, transform2) {
          const polygon = new Polygon2(points);
          polygon.closePath = close;
          this.drawShape(polygon, transform2);
          return this;
        }
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          sides = Math.max(sides | 0, 3);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const polygon = [];
          for (let i2 = 0; i2 < sides; i2++) {
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + radius * Math.cos(angle),
              y2 + radius * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
          sides = Math.max(sides | 0, 3);
          if (corner <= 0) {
            return this.regularPoly(x2, y2, radius, sides, rotation);
          }
          const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
          corner = Math.min(corner, sideLength);
          const startAngle = -1 * Math.PI / 2 + rotation;
          const delta = Math.PI * 2 / sides;
          const internalAngle = (sides - 2) * Math.PI / sides / 2;
          for (let i2 = 0; i2 < sides; i2++) {
            const angle = i2 * delta + startAngle;
            const x0 = x2 + radius * Math.cos(angle);
            const y0 = y2 + radius * Math.sin(angle);
            const a1 = angle + Math.PI + internalAngle;
            const a2 = angle - Math.PI - internalAngle;
            const x1 = x0 + corner * Math.cos(a1);
            const y1 = y0 + corner * Math.sin(a1);
            const x3 = x0 + corner * Math.cos(a2);
            const y3 = y0 + corner * Math.sin(a2);
            if (i2 === 0) {
              this.moveTo(x1, y1);
            } else {
              this.lineTo(x1, y1);
            }
            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
          }
          return this.closePath();
        }
        roundShape(points, radius, useQuadratic = false, smoothness) {
          if (points.length < 3) {
            return this;
          }
          if (useQuadratic) {
            roundedShapeQuadraticCurve(this, points, radius, smoothness);
          } else {
            roundedShapeArc(this, points, radius);
          }
          return this.closePath();
        }
        filletRect(x2, y2, width, height, fillet) {
          if (fillet === 0) {
            return this.rect(x2, y2, width, height);
          }
          const maxFillet = Math.min(width, height) / 2;
          const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
          const right = x2 + width;
          const bottom = y2 + height;
          const dir = inset < 0 ? -inset : 0;
          const size = Math.abs(inset);
          return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
        }
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          if (chamfer <= 0) {
            return this.rect(x2, y2, width, height);
          }
          const inset = Math.min(chamfer, Math.min(width, height) / 2);
          const right = x2 + width;
          const bottom = y2 + height;
          const points = [
            x2 + inset,
            y2,
            right - inset,
            y2,
            right,
            y2 + inset,
            right,
            bottom - inset,
            right - inset,
            bottom,
            x2 + inset,
            bottom,
            x2,
            bottom - inset,
            x2,
            y2 + inset
          ];
          for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
            if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
              points.splice(i2 - 1, 2);
            }
          }
          return this.poly(points, true, transform2);
        }
        ellipse(x2, y2, radiusX, radiusY, transform2) {
          this.drawShape(new Ellipse2(x2, y2, radiusX, radiusY), transform2);
          return this;
        }
        roundRect(x2, y2, w2, h2, radius, transform2) {
          this.drawShape(new RoundedRectangle2(x2, y2, w2, h2, radius), transform2);
          return this;
        }
        drawShape(shape, matrix) {
          this.endPoly();
          this.shapePrimitives.push({ shape, transform: matrix });
          return this;
        }
        startPoly(x2, y2) {
          let currentPoly = this._currentPoly;
          if (currentPoly) {
            this.endPoly();
          }
          currentPoly = new Polygon2();
          currentPoly.points.push(x2, y2);
          this._currentPoly = currentPoly;
          return this;
        }
        endPoly(closePath = false) {
          const shape = this._currentPoly;
          if (shape && shape.points.length > 2) {
            shape.closePath = closePath;
            this.shapePrimitives.push({ shape });
          }
          this._currentPoly = null;
          return this;
        }
        _ensurePoly(start = true) {
          if (this._currentPoly)
            return;
          this._currentPoly = new Polygon2();
          if (start) {
            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (lastShape) {
              let lx = lastShape.shape.x;
              let ly = lastShape.shape.y;
              if (lastShape.transform && !lastShape.transform.isIdentity()) {
                const t2 = lastShape.transform;
                const tempX = lx;
                lx = t2.a * lx + t2.c * ly + t2.tx;
                ly = t2.b * tempX + t2.d * ly + t2.ty;
              }
              this._currentPoly.points.push(lx, ly);
            } else {
              this._currentPoly.points.push(0, 0);
            }
          }
        }
        buildPath() {
          const path3 = this._graphicsPath2D;
          this.shapePrimitives.length = 0;
          this._currentPoly = null;
          for (let i2 = 0; i2 < path3.instructions.length; i2++) {
            const instruction = path3.instructions[i2];
            this[instruction.action](...instruction.data);
          }
          this.finish();
        }
        get bounds() {
          const bounds = this._bounds;
          bounds.clear();
          const shapePrimitives = this.shapePrimitives;
          for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
            const shapePrimitive = shapePrimitives[i2];
            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle2);
            if (shapePrimitive.transform) {
              bounds.addRect(boundsRect, shapePrimitive.transform);
            } else {
              bounds.addRect(boundsRect);
            }
          }
          return bounds;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/path/GraphicsPath.mjs
  function adjustTransform(currentMatrix, transform2) {
    if (currentMatrix) {
      return currentMatrix.prepend(transform2);
    }
    return transform2.clone();
  }
  var GraphicsPath;
  var init_GraphicsPath = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
      init_Point2();
      init_uid2();
      init_warn();
      init_SVGToGraphicsPath();
      init_ShapePath();
      GraphicsPath = class {
        constructor(instructions) {
          this.instructions = [];
          this.uid = uid2("graphicsPath");
          this._dirty = true;
          if (typeof instructions === "string") {
            SVGToGraphicsPath(instructions, this);
          } else {
            this.instructions = instructions?.slice() ?? [];
          }
        }
        get shapePath() {
          if (!this._shapePath) {
            this._shapePath = new ShapePath(this);
          }
          if (this._dirty) {
            this._dirty = false;
            this._shapePath.buildPath();
          }
          return this._shapePath;
        }
        addPath(path3, transform2) {
          path3 = path3.clone();
          this.instructions.push({ action: "addPath", data: [path3, transform2] });
          this._dirty = true;
          return this;
        }
        arc(...args) {
          this.instructions.push({ action: "arc", data: args });
          this._dirty = true;
          return this;
        }
        arcTo(...args) {
          this.instructions.push({ action: "arcTo", data: args });
          this._dirty = true;
          return this;
        }
        arcToSvg(...args) {
          this.instructions.push({ action: "arcToSvg", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveTo(...args) {
          this.instructions.push({ action: "bezierCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point2.shared);
          let cp1x = 0;
          let cp1y = 0;
          if (!last || last.action !== "bezierCurveTo") {
            cp1x = lastPoint.x;
            cp1y = lastPoint.y;
          } else {
            cp1x = last.data[2];
            cp1y = last.data[3];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cp1x = currentX + (currentX - cp1x);
            cp1y = currentY + (currentY - cp1y);
          }
          this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        closePath() {
          this.instructions.push({ action: "closePath", data: [] });
          this._dirty = true;
          return this;
        }
        ellipse(...args) {
          this.instructions.push({ action: "ellipse", data: args });
          this._dirty = true;
          return this;
        }
        lineTo(...args) {
          this.instructions.push({ action: "lineTo", data: args });
          this._dirty = true;
          return this;
        }
        moveTo(...args) {
          this.instructions.push({ action: "moveTo", data: args });
          return this;
        }
        quadraticCurveTo(...args) {
          this.instructions.push({ action: "quadraticCurveTo", data: args });
          this._dirty = true;
          return this;
        }
        quadraticCurveToShort(x2, y2, smoothness) {
          const last = this.instructions[this.instructions.length - 1];
          const lastPoint = this.getLastPoint(Point2.shared);
          let cpx1 = 0;
          let cpy1 = 0;
          if (!last || last.action !== "quadraticCurveTo") {
            cpx1 = lastPoint.x;
            cpy1 = lastPoint.y;
          } else {
            cpx1 = last.data[0];
            cpy1 = last.data[1];
            const currentX = lastPoint.x;
            const currentY = lastPoint.y;
            cpx1 = currentX + (currentX - cpx1);
            cpy1 = currentY + (currentY - cpy1);
          }
          this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
          this._dirty = true;
          return this;
        }
        rect(x2, y2, w2, h2, transform2) {
          this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform2] });
          this._dirty = true;
          return this;
        }
        circle(x2, y2, radius, transform2) {
          this.instructions.push({ action: "circle", data: [x2, y2, radius, transform2] });
          this._dirty = true;
          return this;
        }
        roundRect(...args) {
          this.instructions.push({ action: "roundRect", data: args });
          this._dirty = true;
          return this;
        }
        poly(...args) {
          this.instructions.push({ action: "poly", data: args });
          this._dirty = true;
          return this;
        }
        regularPoly(...args) {
          this.instructions.push({ action: "regularPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundPoly(...args) {
          this.instructions.push({ action: "roundPoly", data: args });
          this._dirty = true;
          return this;
        }
        roundShape(...args) {
          this.instructions.push({ action: "roundShape", data: args });
          this._dirty = true;
          return this;
        }
        filletRect(...args) {
          this.instructions.push({ action: "filletRect", data: args });
          this._dirty = true;
          return this;
        }
        chamferRect(...args) {
          this.instructions.push({ action: "chamferRect", data: args });
          this._dirty = true;
          return this;
        }
        star(x2, y2, points, radius, innerRadius, rotation, transform2) {
          innerRadius = innerRadius || radius / 2;
          const startAngle = -1 * Math.PI / 2 + rotation;
          const len = points * 2;
          const delta = Math.PI * 2 / len;
          const polygon = [];
          for (let i2 = 0; i2 < len; i2++) {
            const r2 = i2 % 2 ? innerRadius : radius;
            const angle = i2 * delta + startAngle;
            polygon.push(
              x2 + r2 * Math.cos(angle),
              y2 + r2 * Math.sin(angle)
            );
          }
          this.poly(polygon, true, transform2);
          return this;
        }
        clone(deep = false) {
          const newGraphicsPath2D = new GraphicsPath();
          if (!deep) {
            newGraphicsPath2D.instructions = this.instructions.slice();
          } else {
            for (let i2 = 0; i2 < this.instructions.length; i2++) {
              const instruction = this.instructions[i2];
              newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
            }
          }
          return newGraphicsPath2D;
        }
        clear() {
          this.instructions.length = 0;
          this._dirty = true;
          return this;
        }
        transform(matrix) {
          if (matrix.isIdentity())
            return this;
          const a2 = matrix.a;
          const b2 = matrix.b;
          const c2 = matrix.c;
          const d2 = matrix.d;
          const tx = matrix.tx;
          const ty = matrix.ty;
          let x2 = 0;
          let y2 = 0;
          let cpx1 = 0;
          let cpy1 = 0;
          let cpx2 = 0;
          let cpy2 = 0;
          let rx = 0;
          let ry = 0;
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const data = instruction.data;
            switch (instruction.action) {
              case "moveTo":
              case "lineTo":
                x2 = data[0];
                y2 = data[1];
                data[0] = a2 * x2 + c2 * y2 + tx;
                data[1] = b2 * x2 + d2 * y2 + ty;
                break;
              case "bezierCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                cpx2 = data[2];
                cpy2 = data[3];
                x2 = data[4];
                y2 = data[5];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * cpx2 + c2 * cpy2 + tx;
                data[3] = b2 * cpx2 + d2 * cpy2 + ty;
                data[4] = a2 * x2 + c2 * y2 + tx;
                data[5] = b2 * x2 + d2 * y2 + ty;
                break;
              case "quadraticCurveTo":
                cpx1 = data[0];
                cpy1 = data[1];
                x2 = data[2];
                y2 = data[3];
                data[0] = a2 * cpx1 + c2 * cpy1 + tx;
                data[1] = b2 * cpx1 + d2 * cpy1 + ty;
                data[2] = a2 * x2 + c2 * y2 + tx;
                data[3] = b2 * x2 + d2 * y2 + ty;
                break;
              case "arcToSvg":
                x2 = data[5];
                y2 = data[6];
                rx = data[0];
                ry = data[1];
                data[0] = a2 * rx + c2 * ry;
                data[1] = b2 * rx + d2 * ry;
                data[5] = a2 * x2 + c2 * y2 + tx;
                data[6] = b2 * x2 + d2 * y2 + ty;
                break;
              case "circle":
                data[4] = adjustTransform(data[3], matrix);
                break;
              case "rect":
                data[4] = adjustTransform(data[4], matrix);
                break;
              case "ellipse":
                data[8] = adjustTransform(data[8], matrix);
                break;
              case "roundRect":
                data[5] = adjustTransform(data[5], matrix);
                break;
              case "addPath":
                data[0].transform(matrix);
                break;
              case "poly":
                data[2] = adjustTransform(data[2], matrix);
                break;
              default:
                warn("unknown transform action", instruction.action);
                break;
            }
          }
          this._dirty = true;
          return this;
        }
        get bounds() {
          return this.shapePath.bounds;
        }
        getLastPoint(out2) {
          let index = this.instructions.length - 1;
          let lastInstruction = this.instructions[index];
          if (!lastInstruction) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          while (lastInstruction.action === "closePath") {
            index--;
            if (index < 0) {
              out2.x = 0;
              out2.y = 0;
              return out2;
            }
            lastInstruction = this.instructions[index];
          }
          switch (lastInstruction.action) {
            case "moveTo":
            case "lineTo":
              out2.x = lastInstruction.data[0];
              out2.y = lastInstruction.data[1];
              break;
            case "quadraticCurveTo":
              out2.x = lastInstruction.data[2];
              out2.y = lastInstruction.data[3];
              break;
            case "bezierCurveTo":
              out2.x = lastInstruction.data[4];
              out2.y = lastInstruction.data[5];
              break;
            case "arc":
            case "arcToSvg":
              out2.x = lastInstruction.data[5];
              out2.y = lastInstruction.data[6];
              break;
            case "addPath":
              lastInstruction.data[0].getLastPoint(out2);
              break;
          }
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGParser.mjs
  function SVGParser(svg, graphicsContext) {
    if (typeof svg === "string") {
      const div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    const session = {
      context: graphicsContext,
      path: new GraphicsPath()
    };
    renderChildren(svg, session, null, null);
    return graphicsContext;
  }
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children;
    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
    if (f1 && fillStyle) {
      fillStyle = { ...fillStyle, ...f1 };
    } else if (f1) {
      fillStyle = f1;
    }
    if (s1 && strokeStyle) {
      strokeStyle = { ...strokeStyle, ...s1 };
    } else if (s1) {
      strokeStyle = s1;
    }
    session.context.fillStyle = fillStyle;
    session.context.strokeStyle = strokeStyle;
    let x2;
    let y2;
    let x1;
    let y1;
    let x22;
    let y22;
    let cx;
    let cy;
    let r2;
    let rx;
    let ry;
    let points;
    let pointsString;
    let d2;
    let graphicsPath;
    let width;
    let height;
    switch (svg.nodeName.toLowerCase()) {
      case "path":
        d2 = svg.getAttribute("d");
        graphicsPath = new GraphicsPath(d2);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "circle":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        r2 = parseFloatAttribute(svg, "r", 0);
        session.context.ellipse(cx, cy, r2, r2);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "rect":
        x2 = parseFloatAttribute(svg, "x", 0);
        y2 = parseFloatAttribute(svg, "y", 0);
        width = parseFloatAttribute(svg, "width", 0);
        height = parseFloatAttribute(svg, "height", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        if (rx || ry) {
          session.context.roundRect(x2, y2, width, height, rx || ry);
        } else {
          session.context.rect(x2, y2, width, height);
        }
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "ellipse":
        cx = parseFloatAttribute(svg, "cx", 0);
        cy = parseFloatAttribute(svg, "cy", 0);
        rx = parseFloatAttribute(svg, "rx", 0);
        ry = parseFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(cx, cy, rx, ry);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "line":
        x1 = parseFloatAttribute(svg, "x1", 0);
        y1 = parseFloatAttribute(svg, "y1", 0);
        x22 = parseFloatAttribute(svg, "x2", 0);
        y22 = parseFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, y1);
        session.context.lineTo(x22, y22);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polygon":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, true);
        if (fillStyle)
          session.context.fill();
        if (strokeStyle)
          session.context.stroke();
        break;
      case "polyline":
        pointsString = svg.getAttribute("points");
        points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
        session.context.poly(points, false);
        if (strokeStyle)
          session.context.stroke();
        break;
      case "g":
      case "svg":
        break;
      default: {
        console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
        break;
      }
    }
    for (let i2 = 0; i2 < children.length; i2++) {
      renderChildren(children[i2], session, fillStyle, strokeStyle);
    }
  }
  function parseFloatAttribute(svg, id, defaultValue3) {
    const value = svg.getAttribute(id);
    return value ? Number(value) : defaultValue3;
  }
  function parseStyle(svg) {
    const style = svg.getAttribute("style");
    const strokeStyle = {};
    const fillStyle = {};
    let useFill = false;
    let useStroke = false;
    if (style) {
      const styleParts = style.split(";");
      for (let i2 = 0; i2 < styleParts.length; i2++) {
        const stylePart = styleParts[i2];
        const [key, value] = stylePart.split(":");
        switch (key) {
          case "stroke":
            if (value !== "none") {
              strokeStyle.color = Color2.shared.setValue(value).toNumber();
              useStroke = true;
            }
            break;
          case "stroke-width":
            strokeStyle.width = Number(value);
            break;
          case "fill":
            if (value !== "none") {
              useFill = true;
              fillStyle.color = Color2.shared.setValue(value).toNumber();
            }
            break;
          case "fill-opacity":
            fillStyle.alpha = Number(value);
            break;
          case "stroke-opacity":
            strokeStyle.alpha = Number(value);
            break;
          case "opacity":
            fillStyle.alpha = Number(value);
            strokeStyle.alpha = Number(value);
            break;
        }
      }
    } else {
      const stroke = svg.getAttribute("stroke");
      if (stroke && stroke !== "none") {
        useStroke = true;
        strokeStyle.color = Color2.shared.setValue(stroke).toNumber();
        strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
      }
      const fill = svg.getAttribute("fill");
      if (fill && fill !== "none") {
        useFill = true;
        fillStyle.color = Color2.shared.setValue(fill).toNumber();
      }
    }
    return {
      strokeStyle: useStroke ? strokeStyle : null,
      fillStyle: useFill ? fillStyle : null
    };
  }
  var init_SVGParser = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
      init_Color2();
      init_GraphicsPath();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
  function isColorLike(value) {
    return Color2.isColorLike(value);
  }
  function isFillPattern(value) {
    return value instanceof FillPattern;
  }
  function isFillGradient(value) {
    return value instanceof FillGradient;
  }
  function handleColorLike(fill, value, defaultStyle) {
    const temp = Color2.shared.setValue(value ?? 0);
    fill.color = temp.toNumber();
    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
    fill.texture = Texture2.WHITE;
    return { ...defaultStyle, ...fill };
  }
  function handleFillPattern(fill, value, defaultStyle) {
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return { ...defaultStyle, ...fill };
  }
  function handleFillGradient(fill, value, defaultStyle) {
    value.buildLinearGradient();
    fill.fill = value;
    fill.color = 16777215;
    fill.texture = value.texture;
    fill.matrix = value.transform;
    return { ...defaultStyle, ...fill };
  }
  function handleFillObject(value, defaultStyle) {
    const style = { ...defaultStyle, ...value };
    if (style.texture) {
      if (style.texture !== Texture2.WHITE) {
        const m2 = style.matrix?.invert() || new Matrix2();
        m2.translate(style.texture.frame.x, style.texture.frame.y);
        m2.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
        style.matrix = m2;
      }
      const sourceStyle = style.texture.source.style;
      if (sourceStyle.addressMode === "clamp-to-edge") {
        sourceStyle.addressMode = "repeat";
        sourceStyle.update();
      }
    }
    const color = Color2.shared.setValue(style.color);
    style.alpha *= color.alpha;
    style.color = color.toNumber();
    style.matrix = style.matrix ? style.matrix.clone() : null;
    return style;
  }
  function toFillStyle(value, defaultStyle) {
    if (value === void 0 || value === null) {
      return null;
    }
    const fill = {};
    const objectStyle = value;
    if (isColorLike(value)) {
      return handleColorLike(fill, value, defaultStyle);
    } else if (isFillPattern(value)) {
      return handleFillPattern(fill, value, defaultStyle);
    } else if (isFillGradient(value)) {
      return handleFillGradient(fill, value, defaultStyle);
    } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
      return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
    } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
      return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
    }
    return handleFillObject(objectStyle, defaultStyle);
  }
  function toStrokeStyle(value, defaultStyle) {
    const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;
    const fill = toFillStyle(value, rest);
    if (!fill) {
      return null;
    }
    return {
      width,
      alignment,
      miterLimit,
      cap,
      join,
      ...fill
    };
  }
  var init_convertFillInputToFillStyle = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
      init_Color2();
      init_Matrix2();
      init_Texture2();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContext.mjs
  var tmpPoint2, tempMatrix6, _GraphicsContext, GraphicsContext;
  var init_GraphicsContext = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/GraphicsContext.mjs"() {
      init_eventemitter3();
      init_Color2();
      init_Matrix2();
      init_Point2();
      init_Texture2();
      init_uid2();
      init_deprecation2();
      init_Bounds2();
      init_GraphicsPath();
      init_SVGParser();
      init_convertFillInputToFillStyle();
      tmpPoint2 = new Point2();
      tempMatrix6 = new Matrix2();
      _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.uid = uid2("graphicsContext");
          this.dirty = true;
          this.batchMode = "auto";
          this.instructions = [];
          this._activePath = new GraphicsPath();
          this._transform = new Matrix2();
          this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
          this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
          this._stateStack = [];
          this._tick = 0;
          this._bounds = new Bounds2();
          this._boundsDirty = true;
        }
        clone() {
          const clone = new _GraphicsContext2();
          clone.batchMode = this.batchMode;
          clone.instructions = this.instructions.slice();
          clone._activePath = this._activePath.clone();
          clone._transform = this._transform.clone();
          clone._fillStyle = { ...this._fillStyle };
          clone._strokeStyle = { ...this._strokeStyle };
          clone._stateStack = this._stateStack.slice();
          clone._bounds = this._bounds.clone();
          clone._boundsDirty = true;
          return clone;
        }
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(value) {
          this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
        }
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(value) {
          this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
        }
        setFillStyle(style) {
          this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
          return this;
        }
        setStrokeStyle(style) {
          this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
          return this;
        }
        texture(texture, tint, dx, dy, dw, dh) {
          this.instructions.push({
            action: "texture",
            data: {
              image: texture,
              dx: dx || 0,
              dy: dy || 0,
              dw: dw || texture.frame.width,
              dh: dh || texture.frame.height,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: tint ? Color2.shared.setValue(tint).toNumber() : 16777215
            }
          });
          this.onUpdate();
          return this;
        }
        beginPath() {
          this._activePath = new GraphicsPath();
          return this;
        }
        fill(style, alpha) {
          let path3;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
            path3 = lastInstruction.data.path;
          } else {
            path3 = this._activePath.clone();
          }
          if (!path3)
            return this;
          if (style != null) {
            if (alpha !== void 0 && typeof style === "number") {
              deprecation2(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
              style = { color: style, alpha };
            }
            this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
          }
          this.instructions.push({
            action: "fill",
            data: { style: this.fillStyle, path: path3 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        _initNextPathLocation() {
          const { x: x2, y: y2 } = this._activePath.getLastPoint(Point2.shared);
          this._activePath.clear();
          this._activePath.moveTo(x2, y2);
        }
        stroke(style) {
          let path3;
          const lastInstruction = this.instructions[this.instructions.length - 1];
          if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
            path3 = lastInstruction.data.path;
          } else {
            path3 = this._activePath.clone();
          }
          if (!path3)
            return this;
          if (style != null) {
            this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
          }
          this.instructions.push({
            action: "stroke",
            data: { style: this.strokeStyle, path: path3 }
          });
          this.onUpdate();
          this._initNextPathLocation();
          this._tick = 0;
          return this;
        }
        cut() {
          for (let i2 = 0; i2 < 2; i2++) {
            const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
            const holePath = this._activePath.clone();
            if (lastInstruction) {
              if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
                if (lastInstruction.data.hole) {
                  lastInstruction.data.hole.addPath(holePath);
                } else {
                  lastInstruction.data.hole = holePath;
                  break;
                }
              }
            }
          }
          this._initNextPathLocation();
          return this;
        }
        arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arc(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius,
            startAngle,
            endAngle,
            counterclockwise
          );
          return this;
        }
        arcTo(x1, y1, x2, y2, radius) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcTo(
            t2.a * x1 + t2.c * y1 + t2.tx,
            t2.b * x1 + t2.d * y1 + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            radius
          );
          return this;
        }
        arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.arcToSvg(
            rx,
            ry,
            xAxisRotation,
            largeArcFlag,
            sweepFlag,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.bezierCurveTo(
            t2.a * cp1x + t2.c * cp1y + t2.tx,
            t2.b * cp1x + t2.d * cp1y + t2.ty,
            t2.a * cp2x + t2.c * cp2y + t2.tx,
            t2.b * cp2x + t2.d * cp2y + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        closePath() {
          this._tick++;
          this._activePath?.closePath();
          return this;
        }
        ellipse(x2, y2, radiusX, radiusY) {
          this._tick++;
          this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
          return this;
        }
        circle(x2, y2, radius) {
          this._tick++;
          this._activePath.circle(x2, y2, radius, this._transform.clone());
          return this;
        }
        path(path3) {
          this._tick++;
          this._activePath.addPath(path3, this._transform.clone());
          return this;
        }
        lineTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.lineTo(
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty
          );
          return this;
        }
        moveTo(x2, y2) {
          this._tick++;
          const t2 = this._transform;
          const instructions = this._activePath.instructions;
          const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
          const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
          if (instructions.length === 1 && instructions[0].action === "moveTo") {
            instructions[0].data[0] = transformedX;
            instructions[0].data[1] = transformedY;
            return this;
          }
          this._activePath.moveTo(
            transformedX,
            transformedY
          );
          return this;
        }
        quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
          this._tick++;
          const t2 = this._transform;
          this._activePath.quadraticCurveTo(
            t2.a * cpx + t2.c * cpy + t2.tx,
            t2.b * cpx + t2.d * cpy + t2.ty,
            t2.a * x2 + t2.c * y2 + t2.tx,
            t2.b * x2 + t2.d * y2 + t2.ty,
            smoothness
          );
          return this;
        }
        rect(x2, y2, w2, h2) {
          this._tick++;
          this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
          return this;
        }
        roundRect(x2, y2, w2, h2, radius) {
          this._tick++;
          this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
          return this;
        }
        poly(points, close) {
          this._tick++;
          this._activePath.poly(points, close, this._transform.clone());
          return this;
        }
        regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
          this._tick++;
          this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform2);
          return this;
        }
        roundPoly(x2, y2, radius, sides, corner, rotation) {
          this._tick++;
          this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
          return this;
        }
        roundShape(points, radius, useQuadratic, smoothness) {
          this._tick++;
          this._activePath.roundShape(points, radius, useQuadratic, smoothness);
          return this;
        }
        filletRect(x2, y2, width, height, fillet) {
          this._tick++;
          this._activePath.filletRect(x2, y2, width, height, fillet);
          return this;
        }
        chamferRect(x2, y2, width, height, chamfer, transform2) {
          this._tick++;
          this._activePath.chamferRect(x2, y2, width, height, chamfer, transform2);
          return this;
        }
        star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
          this._tick++;
          this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
          return this;
        }
        svg(svg) {
          this._tick++;
          SVGParser(svg, this);
          return this;
        }
        restore() {
          const state = this._stateStack.pop();
          if (state) {
            this._transform = state.transform;
            this._fillStyle = state.fillStyle;
            this._strokeStyle = state.strokeStyle;
          }
          return this;
        }
        save() {
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: { ...this._fillStyle },
            strokeStyle: { ...this._strokeStyle }
          });
          return this;
        }
        getTransform() {
          return this._transform;
        }
        resetTransform() {
          this._transform.identity();
          return this;
        }
        rotate(angle) {
          this._transform.rotate(angle);
          return this;
        }
        scale(x2, y2 = x2) {
          this._transform.scale(x2, y2);
          return this;
        }
        setTransform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix2) {
            this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
            return this;
          }
          this._transform.set(a2, b2, c2, d2, dx, dy);
          return this;
        }
        transform(a2, b2, c2, d2, dx, dy) {
          if (a2 instanceof Matrix2) {
            this._transform.append(a2);
            return this;
          }
          tempMatrix6.set(a2, b2, c2, d2, dx, dy);
          this._transform.append(tempMatrix6);
          return this;
        }
        translate(x2, y2 = x2) {
          this._transform.translate(x2, y2);
          return this;
        }
        clear() {
          this._activePath.clear();
          this.instructions.length = 0;
          this.resetTransform();
          this.onUpdate();
          return this;
        }
        onUpdate() {
          if (this.dirty)
            return;
          this.emit("update", this, 16);
          this.dirty = true;
          this._boundsDirty = true;
        }
        get bounds() {
          if (!this._boundsDirty)
            return this._bounds;
          const bounds = this._bounds;
          bounds.clear();
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            const action = instruction.action;
            if (action === "fill") {
              const data = instruction.data;
              bounds.addBounds(data.path.bounds);
            } else if (action === "texture") {
              const data = instruction.data;
              bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
            }
            if (action === "stroke") {
              const data = instruction.data;
              const padding = data.style.width / 2;
              const _bounds = data.path.bounds;
              bounds.addFrame(
                _bounds.minX - padding,
                _bounds.minY - padding,
                _bounds.maxX + padding,
                _bounds.maxY + padding
              );
            }
          }
          return bounds;
        }
        containsPoint(point) {
          if (!this.bounds.containsPoint(point.x, point.y))
            return false;
          const instructions = this.instructions;
          let hasHit = false;
          for (let k2 = 0; k2 < instructions.length; k2++) {
            const instruction = instructions[k2];
            const data = instruction.data;
            const path3 = data.path;
            if (!instruction.action || !path3)
              continue;
            const style = data.style;
            const shapes = path3.shapePath.shapePrimitives;
            for (let i2 = 0; i2 < shapes.length; i2++) {
              const shape = shapes[i2].shape;
              if (!style || !shape)
                continue;
              const transform2 = shapes[i2].transform;
              const transformedPoint = transform2 ? transform2.applyInverse(point, tmpPoint2) : point;
              if (instruction.action === "fill") {
                hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
              } else {
                hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);
              }
              const holes = data.hole;
              if (holes) {
                const holeShapes = holes.shapePath?.shapePrimitives;
                if (holeShapes) {
                  for (let j2 = 0; j2 < holeShapes.length; j2++) {
                    if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                      hasHit = false;
                    }
                  }
                }
              }
              if (hasHit) {
                return true;
              }
            }
          }
          return hasHit;
        }
        destroy(options = false) {
          this._stateStack.length = 0;
          this._transform = null;
          this.emit("destroy", this);
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fillStyle.texture) {
              this._fillStyle.texture.destroy(destroyTextureSource);
            }
            if (this._strokeStyle.texture) {
              this._strokeStyle.texture.destroy(destroyTextureSource);
            }
          }
          this._fillStyle = null;
          this._strokeStyle = null;
          this.instructions = null;
          this._activePath = null;
          this._bounds = null;
          this._stateStack = null;
          this.customShader = null;
          this._transform = null;
        }
      };
      _GraphicsContext.defaultFillStyle = {
        color: 16777215,
        alpha: 1,
        texture: Texture2.WHITE,
        matrix: null,
        fill: null
      };
      _GraphicsContext.defaultStrokeStyle = {
        width: 1,
        color: 16777215,
        alpha: 1,
        alignment: 0.5,
        miterLimit: 10,
        cap: "butt",
        join: "miter",
        texture: Texture2.WHITE,
        matrix: null,
        fill: null
      };
      GraphicsContext = _GraphicsContext;
    }
  });

  // node_modules/pixi-v8/lib/scene/text/utils/generateTextStyleKey.mjs
  function generateTextStyleKey(style) {
    const key = [];
    let index = 0;
    for (let i2 = 0; i2 < valuesToIterateForKeys.length; i2++) {
      const prop = `_${valuesToIterateForKeys[i2]}`;
      key[index++] = style[prop];
    }
    index = addFillStyleKey(style._fill, key, index);
    index = addStokeStyleKey(style._stroke, key, index);
    index = addDropShadowKey(style.dropShadow, key, index);
    return key.join("-");
  }
  function addFillStyleKey(fillStyle, key, index) {
    if (!fillStyle)
      return index;
    key[index++] = fillStyle.color;
    key[index++] = fillStyle.alpha;
    key[index++] = fillStyle.fill?.styleKey;
    return index;
  }
  function addStokeStyleKey(strokeStyle, key, index) {
    if (!strokeStyle)
      return index;
    index = addFillStyleKey(strokeStyle, key, index);
    key[index++] = strokeStyle.width;
    key[index++] = strokeStyle.alignment;
    key[index++] = strokeStyle.cap;
    key[index++] = strokeStyle.join;
    key[index++] = strokeStyle.miterLimit;
    return index;
  }
  function addDropShadowKey(dropShadow, key, index) {
    if (!dropShadow)
      return index;
    key[index++] = dropShadow.alpha;
    key[index++] = dropShadow.angle;
    key[index++] = dropShadow.blur;
    key[index++] = dropShadow.distance;
    key[index++] = Color2.shared.setValue(dropShadow.color).toNumber();
    return index;
  }
  var valuesToIterateForKeys;
  var init_generateTextStyleKey = __esm({
    "node_modules/pixi-v8/lib/scene/text/utils/generateTextStyleKey.mjs"() {
      init_Color2();
      valuesToIterateForKeys = [
        "align",
        "breakWords",
        "cssOverrides",
        "fontVariant",
        "fontWeight",
        "leading",
        "letterSpacing",
        "lineHeight",
        "padding",
        "textBaseline",
        "trim",
        "whiteSpace",
        "wordWrap",
        "wordWrapWidth",
        "fontFamily",
        "fontStyle",
        "fontSize"
      ];
    }
  });

  // node_modules/pixi-v8/lib/scene/text/TextStyle.mjs
  function convertV7Tov8Style(style) {
    const oldStyle = style;
    if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
      const defaults = TextStyle2.defaultDropShadow;
      style.dropShadow = {
        alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
        angle: oldStyle.dropShadowAngle ?? defaults.angle,
        blur: oldStyle.dropShadowBlur ?? defaults.blur,
        color: oldStyle.dropShadowColor ?? defaults.color,
        distance: oldStyle.dropShadowDistance ?? defaults.distance
      };
    }
    if (oldStyle.strokeThickness !== void 0) {
      deprecation2(v8_0_0, "strokeThickness is now a part of stroke");
      const color = oldStyle.stroke;
      let obj = {};
      if (Color2.isColorLike(color)) {
        obj.color = color;
      } else if (color instanceof FillGradient || color instanceof FillPattern) {
        obj.fill = color;
      } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
        obj = color;
      } else {
        throw new Error("Invalid stroke value.");
      }
      style.stroke = {
        ...obj,
        width: oldStyle.strokeThickness
      };
    }
    if (Array.isArray(oldStyle.fillGradientStops)) {
      deprecation2(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let fontSize;
      if (style.fontSize == null) {
        style.fontSize = TextStyle2.defaultTextStyle.fontSize;
      } else if (typeof style.fontSize === "string") {
        fontSize = parseInt(style.fontSize, 10);
      } else {
        fontSize = style.fontSize;
      }
      const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);
      const fills = oldStyle.fillGradientStops.map((color) => Color2.shared.setValue(color).toNumber());
      fills.forEach((number, index) => {
        const ratio = index / (fills.length - 1);
        gradientFill.addColorStop(ratio, number);
      });
      style.fill = {
        fill: gradientFill
      };
    }
  }
  var _TextStyle3, TextStyle2;
  var init_TextStyle2 = __esm({
    "node_modules/pixi-v8/lib/scene/text/TextStyle.mjs"() {
      init_eventemitter3();
      init_Color2();
      init_deprecation2();
      init_FillGradient();
      init_FillPattern();
      init_GraphicsContext();
      init_convertFillInputToFillStyle();
      init_generateTextStyleKey();
      _TextStyle3 = class _TextStyle4 extends eventemitter3_default {
        constructor(style = {}) {
          super();
          convertV7Tov8Style(style);
          const fullStyle = { ..._TextStyle4.defaultTextStyle, ...style };
          for (const key in fullStyle) {
            const thisKey = key;
            this[thisKey] = fullStyle[key];
          }
          this.update();
        }
        get align() {
          return this._align;
        }
        set align(value) {
          this._align = value;
          this.update();
        }
        get breakWords() {
          return this._breakWords;
        }
        set breakWords(value) {
          this._breakWords = value;
          this.update();
        }
        get dropShadow() {
          return this._dropShadow;
        }
        set dropShadow(value) {
          if (value !== null && typeof value === "object") {
            this._dropShadow = this._createProxy({ ..._TextStyle4.defaultDropShadow, ...value });
          } else {
            this._dropShadow = value ? this._createProxy({ ..._TextStyle4.defaultDropShadow }) : null;
          }
          this.update();
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fontFamily(value) {
          this._fontFamily = value;
          this.update();
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontSize(value) {
          if (typeof value === "string") {
            this._fontSize = parseInt(value, 10);
          } else {
            this._fontSize = value;
          }
          this.update();
        }
        get fontStyle() {
          return this._fontStyle;
        }
        set fontStyle(value) {
          this._fontStyle = value;
          this.update();
        }
        get fontVariant() {
          return this._fontVariant;
        }
        set fontVariant(value) {
          this._fontVariant = value;
          this.update();
        }
        get fontWeight() {
          return this._fontWeight;
        }
        set fontWeight(value) {
          this._fontWeight = value;
          this.update();
        }
        get leading() {
          return this._leading;
        }
        set leading(value) {
          this._leading = value;
          this.update();
        }
        get letterSpacing() {
          return this._letterSpacing;
        }
        set letterSpacing(value) {
          this._letterSpacing = value;
          this.update();
        }
        get lineHeight() {
          return this._lineHeight;
        }
        set lineHeight(value) {
          this._lineHeight = value;
          this.update();
        }
        get padding() {
          return this._padding;
        }
        set padding(value) {
          this._padding = value;
          this.update();
        }
        get trim() {
          return this._trim;
        }
        set trim(value) {
          this._trim = value;
          this.update();
        }
        get textBaseline() {
          return this._textBaseline;
        }
        set textBaseline(value) {
          this._textBaseline = value;
          this.update();
        }
        get whiteSpace() {
          return this._whiteSpace;
        }
        set whiteSpace(value) {
          this._whiteSpace = value;
          this.update();
        }
        get wordWrap() {
          return this._wordWrap;
        }
        set wordWrap(value) {
          this._wordWrap = value;
          this.update();
        }
        get wordWrapWidth() {
          return this._wordWrapWidth;
        }
        set wordWrapWidth(value) {
          this._wordWrapWidth = value;
          this.update();
        }
        get fill() {
          return this._originalFill;
        }
        set fill(value) {
          if (value === this._originalFill)
            return;
          this._originalFill = value;
          if (this._isFillStyle(value)) {
            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {
              this._fill = toFillStyle(
                { ...this._originalFill },
                GraphicsContext.defaultFillStyle
              );
            });
          }
          this._fill = toFillStyle(
            value === 0 ? "black" : value,
            GraphicsContext.defaultFillStyle
          );
          this.update();
        }
        get stroke() {
          return this._originalStroke;
        }
        set stroke(value) {
          if (value === this._originalStroke)
            return;
          this._originalStroke = value;
          if (this._isFillStyle(value)) {
            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {
              this._stroke = toStrokeStyle(
                { ...this._originalStroke },
                GraphicsContext.defaultStrokeStyle
              );
            });
          }
          this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
          this.update();
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this);
          return this._styleKey;
        }
        update() {
          this._styleKey = null;
          this.emit("update", this);
        }
        reset() {
          const defaultStyle = _TextStyle4.defaultTextStyle;
          for (const key in defaultStyle) {
            this[key] = defaultStyle[key];
          }
        }
        get styleKey() {
          return this._styleKey || this._generateKey();
        }
        clone() {
          return new _TextStyle4({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth
          });
        }
        destroy(options = false) {
          this.removeAllListeners();
          const destroyTexture = typeof options === "boolean" ? options : options?.texture;
          if (destroyTexture) {
            const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
            if (this._fill?.texture) {
              this._fill.texture.destroy(destroyTextureSource);
            }
            if (this._originalFill?.texture) {
              this._originalFill.texture.destroy(destroyTextureSource);
            }
            if (this._stroke?.texture) {
              this._stroke.texture.destroy(destroyTextureSource);
            }
            if (this._originalStroke?.texture) {
              this._originalStroke.texture.destroy(destroyTextureSource);
            }
          }
          this._fill = null;
          this._stroke = null;
          this.dropShadow = null;
          this._originalStroke = null;
          this._originalFill = null;
        }
        _createProxy(value, cb) {
          return new Proxy(value, {
            set: (target, property, newValue) => {
              target[property] = newValue;
              cb?.(property, newValue);
              this.update();
              return true;
            }
          });
        }
        _isFillStyle(value) {
          return (value ?? null) !== null && !(Color2.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
        }
      };
      _TextStyle3.defaultDropShadow = {
        alpha: 1,
        angle: Math.PI / 6,
        blur: 0,
        color: "black",
        distance: 5
      };
      _TextStyle3.defaultTextStyle = {
        align: "left",
        breakWords: false,
        dropShadow: null,
        fill: "black",
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: null,
        textBaseline: "alphabetic",
        trim: false,
        whiteSpace: "pre",
        wordWrap: false,
        wordWrapWidth: 100
      };
      TextStyle2 = _TextStyle3;
    }
  });

  // node_modules/pixi-v8/lib/scene/text/utils/getPo2TextureFromSource.mjs
  function getPo2TextureFromSource(image, width, height, resolution) {
    const bounds = tempBounds2;
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = image.width / resolution | 0;
    bounds.maxY = image.height / resolution | 0;
    const texture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      resolution,
      false
    );
    texture.source.uploadMethodId = "image";
    texture.source.resource = image;
    texture.source.alphaMode = "premultiply-alpha-on-upload";
    texture.frame.width = width / resolution;
    texture.frame.height = height / resolution;
    texture.source.emit("update", texture.source);
    texture.updateUvs();
    return texture;
  }
  var tempBounds2;
  var init_getPo2TextureFromSource = __esm({
    "node_modules/pixi-v8/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
      init_TexturePool();
      init_Bounds2();
      tempBounds2 = new Bounds2();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
  function fontStringFromTextStyle(style) {
    const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
    let fontFamilies = style.fontFamily;
    if (!Array.isArray(style.fontFamily)) {
      fontFamilies = style.fontFamily.split(",");
    }
    for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      let fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies2.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i2] = fontFamily;
    }
    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
  var genericFontFamilies2;
  var init_fontStringFromTextStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
      "use strict";
      genericFontFamilies2 = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui"
      ];
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextMetrics.mjs
  var contextSettings2, _CanvasTextMetrics, CanvasTextMetrics;
  var init_CanvasTextMetrics = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
      init_adapter2();
      init_fontStringFromTextStyle();
      contextSettings2 = {
        willReadFrequently: true
      };
      _CanvasTextMetrics = class _CanvasTextMetrics2 {
        static get experimentalLetterSpacingSupported() {
          let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
          if (result !== void 0) {
            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
            result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
          }
          return result;
        }
        constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
          this.text = text;
          this.style = style;
          this.width = width;
          this.height = height;
          this.lines = lines;
          this.lineWidths = lineWidths;
          this.lineHeight = lineHeight;
          this.maxLineWidth = maxLineWidth;
          this.fontProperties = fontProperties;
        }
        static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
          const textKey = `${text}:${style.styleKey}`;
          if (_CanvasTextMetrics2._measurementCache[textKey])
            return _CanvasTextMetrics2._measurementCache[textKey];
          const font = fontStringFromTextStyle(style);
          const fontProperties = _CanvasTextMetrics2.measureFont(font);
          if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
          }
          const context3 = _CanvasTextMetrics2.__context;
          context3.font = font;
          const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
          const lines = outputText.split(/(?:\r\n|\r|\n)/);
          const lineWidths = new Array(lines.length);
          let maxLineWidth = 0;
          for (let i2 = 0; i2 < lines.length; i2++) {
            const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context3);
            lineWidths[i2] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
          }
          const strokeWidth = style._stroke?.width || 0;
          let width = maxLineWidth + strokeWidth;
          if (style.dropShadow) {
            width += style.dropShadow.distance;
          }
          const lineHeight = style.lineHeight || fontProperties.fontSize;
          let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
          if (style.dropShadow) {
            height += style.dropShadow.distance;
          }
          const measurements = new _CanvasTextMetrics2(
            text,
            style,
            width,
            height,
            lines,
            lineWidths,
            lineHeight + style.leading,
            maxLineWidth,
            fontProperties
          );
          return measurements;
        }
        static _measureText(text, letterSpacing, context3) {
          let useExperimentalLetterSpacing = false;
          if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
            if (_CanvasTextMetrics2.experimentalLetterSpacing) {
              context3.letterSpacing = `${letterSpacing}px`;
              context3.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context3.letterSpacing = "0px";
              context3.textLetterSpacing = "0px";
            }
          }
          let width = context3.measureText(text).width;
          if (width > 0) {
            if (useExperimentalLetterSpacing) {
              width -= letterSpacing;
            } else {
              width += (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
            }
          }
          return width;
        }
        static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
          const context3 = canvas.getContext("2d", contextSettings2);
          let width = 0;
          let line = "";
          let lines = "";
          const cache = /* @__PURE__ */ Object.create(null);
          const { letterSpacing, whiteSpace } = style;
          const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
          const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
          let canPrependSpaces = !collapseSpaces;
          const wordWrapWidth = style.wordWrapWidth + letterSpacing;
          const tokens = _CanvasTextMetrics2._tokenize(text);
          for (let i2 = 0; i2 < tokens.length; i2++) {
            let token = tokens[i2];
            if (_CanvasTextMetrics2._isNewline(token)) {
              if (!collapseNewlines) {
                lines += _CanvasTextMetrics2._addLine(line);
                canPrependSpaces = !collapseSpaces;
                line = "";
                width = 0;
                continue;
              }
              token = " ";
            }
            if (collapseSpaces) {
              const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
              const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
              if (currIsBreakingSpace && lastIsBreakingSpace) {
                continue;
              }
            }
            const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context3);
            if (tokenWidth > wordWrapWidth) {
              if (line !== "") {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
                const characters = _CanvasTextMetrics2.wordWrapSplit(token);
                for (let j2 = 0; j2 < characters.length; j2++) {
                  let char = characters[j2];
                  let lastChar = char;
                  let k2 = 1;
                  while (characters[j2 + k2]) {
                    const nextChar = characters[j2 + k2];
                    if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                      char += nextChar;
                    } else {
                      break;
                    }
                    lastChar = nextChar;
                    k2++;
                  }
                  j2 += k2 - 1;
                  const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context3);
                  if (characterWidth + width > wordWrapWidth) {
                    lines += _CanvasTextMetrics2._addLine(line);
                    canPrependSpaces = false;
                    line = "";
                    width = 0;
                  }
                  line += char;
                  width += characterWidth;
                }
              } else {
                if (line.length > 0) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  line = "";
                  width = 0;
                }
                const isLastToken = i2 === tokens.length - 1;
                lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
                canPrependSpaces = false;
                line = "";
                width = 0;
              }
            } else {
              if (tokenWidth + width > wordWrapWidth) {
                canPrependSpaces = false;
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
                line += token;
                width += tokenWidth;
              }
            }
          }
          lines += _CanvasTextMetrics2._addLine(line, false);
          return lines;
        }
        static _addLine(line, newLine = true) {
          line = _CanvasTextMetrics2._trimRight(line);
          line = newLine ? `${line}
` : line;
          return line;
        }
        static _getFromCache(key, letterSpacing, cache, context3) {
          let width = cache[key];
          if (typeof width !== "number") {
            width = _CanvasTextMetrics2._measureText(key, letterSpacing, context3) + letterSpacing;
            cache[key] = width;
          }
          return width;
        }
        static _collapseSpaces(whiteSpace) {
          return whiteSpace === "normal" || whiteSpace === "pre-line";
        }
        static _collapseNewlines(whiteSpace) {
          return whiteSpace === "normal";
        }
        static _trimRight(text) {
          if (typeof text !== "string") {
            return "";
          }
          for (let i2 = text.length - 1; i2 >= 0; i2--) {
            const char = text[i2];
            if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
              break;
            }
            text = text.slice(0, -1);
          }
          return text;
        }
        static _isNewline(char) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
        }
        static isBreakingSpace(char, _nextChar) {
          if (typeof char !== "string") {
            return false;
          }
          return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
        }
        static _tokenize(text) {
          const tokens = [];
          let token = "";
          if (typeof text !== "string") {
            return tokens;
          }
          for (let i2 = 0; i2 < text.length; i2++) {
            const char = text[i2];
            const nextChar = text[i2 + 1];
            if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
              if (token !== "") {
                tokens.push(token);
                token = "";
              }
              tokens.push(char);
              continue;
            }
            token += char;
          }
          if (token !== "") {
            tokens.push(token);
          }
          return tokens;
        }
        static canBreakWords(_token, breakWords) {
          return breakWords;
        }
        static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
          return true;
        }
        static wordWrapSplit(token) {
          return _CanvasTextMetrics2.graphemeSegmenter(token);
        }
        static measureFont(font) {
          if (_CanvasTextMetrics2._fonts[font]) {
            return _CanvasTextMetrics2._fonts[font];
          }
          const context3 = _CanvasTextMetrics2._context;
          context3.font = font;
          const metrics = context3.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
          const properties = {
            ascent: metrics.actualBoundingBoxAscent,
            descent: metrics.actualBoundingBoxDescent,
            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
          };
          _CanvasTextMetrics2._fonts[font] = properties;
          return properties;
        }
        static clearMetrics(font = "") {
          if (font) {
            delete _CanvasTextMetrics2._fonts[font];
          } else {
            _CanvasTextMetrics2._fonts = {};
          }
        }
        static get _canvas() {
          if (!_CanvasTextMetrics2.__canvas) {
            let canvas;
            try {
              const c2 = new OffscreenCanvas(0, 0);
              const context3 = c2.getContext("2d", contextSettings2);
              if (context3?.measureText) {
                _CanvasTextMetrics2.__canvas = c2;
                return c2;
              }
              canvas = DOMAdapter.get().createCanvas();
            } catch (ex) {
              canvas = DOMAdapter.get().createCanvas();
            }
            canvas.width = canvas.height = 10;
            _CanvasTextMetrics2.__canvas = canvas;
          }
          return _CanvasTextMetrics2.__canvas;
        }
        static get _context() {
          if (!_CanvasTextMetrics2.__context) {
            _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings2);
          }
          return _CanvasTextMetrics2.__context;
        }
      };
      _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
      _CanvasTextMetrics.BASELINE_SYMBOL = "M";
      _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
      _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
      _CanvasTextMetrics.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter === "function") {
          const segmenter = new Intl.Segmenter();
          return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
        }
        return (s2) => [...s2];
      })();
      _CanvasTextMetrics.experimentalLetterSpacing = false;
      _CanvasTextMetrics._fonts = {};
      _CanvasTextMetrics._newlines = [
        10,
        13
      ];
      _CanvasTextMetrics._breakingSpaces = [
        9,
        32,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8200,
        8201,
        8202,
        8287,
        12288
      ];
      _CanvasTextMetrics._measurementCache = {};
      CanvasTextMetrics = _CanvasTextMetrics;
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
  function getCanvasFillStyle(fillStyle, context3) {
    if (fillStyle.texture === Texture2.WHITE && !fillStyle.fill) {
      return Color2.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
    } else if (!fillStyle.fill) {
      const pattern = context3.createPattern(fillStyle.texture.source.resource, "repeat");
      const tempMatrix9 = fillStyle.matrix.copyTo(Matrix2.shared);
      tempMatrix9.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
      pattern.setTransform(tempMatrix9);
      return pattern;
    } else if (fillStyle.fill instanceof FillPattern) {
      const fillPattern = fillStyle.fill;
      const pattern = context3.createPattern(fillPattern.texture.source.resource, "repeat");
      const tempMatrix9 = fillPattern.transform.copyTo(Matrix2.shared);
      tempMatrix9.scale(
        fillPattern.texture.frame.width,
        fillPattern.texture.frame.height
      );
      pattern.setTransform(tempMatrix9);
      return pattern;
    } else if (fillStyle.fill instanceof FillGradient) {
      const fillGradient = fillStyle.fill;
      if (fillGradient.type === "linear") {
        const gradient = context3.createLinearGradient(
          fillGradient.x0,
          fillGradient.y0,
          fillGradient.x1,
          fillGradient.y1
        );
        fillGradient.gradientStops.forEach((stop) => {
          gradient.addColorStop(stop.offset, Color2.shared.setValue(stop.color).toHex());
        });
        return gradient;
      }
    }
    warn("FillStyle not recognised", fillStyle);
    return "red";
  }
  var init_getCanvasFillStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
      init_Color2();
      init_Matrix2();
      init_Texture2();
      init_warn();
      init_FillGradient();
      init_FillPattern();
    }
  });

  // node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextSystem.mjs
  var CanvasTextSystem;
  var init_CanvasTextSystem = __esm({
    "node_modules/pixi-v8/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
      init_Color2();
      init_Extensions();
      init_pow22();
      init_CanvasPool();
      init_TexturePool();
      init_getCanvasBoundingBox2();
      init_deprecation2();
      init_TextStyle2();
      init_getPo2TextureFromSource();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      CanvasTextSystem = class {
        constructor(_renderer) {
          this._activeTextures = {};
          this._renderer = _renderer;
        }
        getTextureSize(text, resolution, style) {
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          width = Math.ceil(width - 1e-6);
          height = Math.ceil(height - 1e-6);
          width = nextPow22(width);
          height = nextPow22(height);
          return { width, height };
        }
        getTexture(options, resolution, style, _textKey) {
          if (typeof options === "string") {
            deprecation2("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
            options = {
              text: options,
              style,
              resolution
            };
          }
          if (!(options.style instanceof TextStyle2)) {
            options.style = new TextStyle2(options.style);
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(
            options
          );
          this._renderer.texture.initSource(texture._source);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return texture;
        }
        createTextureAndCanvas(options) {
          const { text, style } = options;
          const resolution = options.resolution ?? this._renderer.resolution;
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
          const { canvas } = canvasAndContext;
          this.renderTextToCanvas(text, style, resolution, canvasAndContext);
          const texture = getPo2TextureFromSource(canvas, width, height, resolution);
          if (style.trim) {
            const trimmed = getCanvasBoundingBox2(canvas, resolution);
            texture.frame.copyFrom(trimmed);
            texture.updateUvs();
          }
          return { texture, canvasAndContext };
        }
        getManagedTexture(text) {
          text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
          const textKey = text._getKey();
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].texture;
          }
          const { texture, canvasAndContext } = this.createTextureAndCanvas(text);
          this._activeTextures[textKey] = {
            canvasAndContext,
            texture,
            usageCount: 1
          };
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
            TexturePool.returnTexture(activeTexture.texture);
            const source2 = activeTexture.texture.source;
            source2.resource = null;
            source2.uploadMethodId = "unknown";
            source2.alphaMode = "no-premultiply-alpha";
            this._activeTextures[textKey] = null;
          }
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        renderTextToCanvas(text, style, resolution, canvasAndContext) {
          const { canvas, context: context3 } = canvasAndContext;
          const font = fontStringFromTextStyle(style);
          const measured = CanvasTextMetrics.measureText(text || " ", style);
          const lines = measured.lines;
          const lineHeight = measured.lineHeight;
          const lineWidths = measured.lineWidths;
          const maxLineWidth = measured.maxLineWidth;
          const fontProperties = measured.fontProperties;
          const height = canvas.height;
          context3.resetTransform();
          context3.scale(resolution, resolution);
          const padding = style.padding * 2;
          context3.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);
          if (style._stroke?.width) {
            const strokeStyle = style._stroke;
            context3.lineWidth = strokeStyle.width;
            context3.miterLimit = strokeStyle.miterLimit;
            context3.lineJoin = strokeStyle.join;
            context3.lineCap = strokeStyle.cap;
          }
          context3.font = font;
          let linePositionX;
          let linePositionY;
          const passesCount = style.dropShadow ? 2 : 1;
          for (let i2 = 0; i2 < passesCount; ++i2) {
            const isShadowPass = style.dropShadow && i2 === 0;
            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
            const dsOffsetShadow = dsOffsetText * resolution;
            if (isShadowPass) {
              context3.fillStyle = "black";
              context3.strokeStyle = "black";
              const shadowOptions = style.dropShadow;
              const dropShadowColor = shadowOptions.color;
              const dropShadowAlpha = shadowOptions.alpha;
              context3.shadowColor = Color2.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
              const dropShadowBlur = shadowOptions.blur * resolution;
              const dropShadowDistance = shadowOptions.distance * resolution;
              context3.shadowBlur = dropShadowBlur;
              context3.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
              context3.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
            } else {
              context3.globalAlpha = style._fill?.alpha ?? 1;
              context3.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context3) : null;
              if (style._stroke?.width) {
                context3.strokeStyle = getCanvasFillStyle(style._stroke, context3);
              }
              context3.shadowColor = "black";
            }
            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
            if (lineHeight - fontProperties.fontSize < 0) {
              linePositionYShift = 0;
            }
            const strokeWidth = style._stroke?.width ?? 0;
            for (let i22 = 0; i22 < lines.length; i22++) {
              linePositionX = strokeWidth / 2;
              linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
              if (style.align === "right") {
                linePositionX += maxLineWidth - lineWidths[i22];
              } else if (style.align === "center") {
                linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
              }
              if (style._stroke?.width) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText,
                  true
                );
              }
              if (style._fill !== void 0) {
                this._drawLetterSpacing(
                  lines[i22],
                  style,
                  canvasAndContext,
                  linePositionX + style.padding,
                  linePositionY + style.padding - dsOffsetText
                );
              }
            }
          }
        }
        _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
          const { context: context3 } = canvasAndContext;
          const letterSpacing = style.letterSpacing;
          let useExperimentalLetterSpacing = false;
          if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
            if (CanvasTextMetrics.experimentalLetterSpacing) {
              context3.letterSpacing = `${letterSpacing}px`;
              context3.textLetterSpacing = `${letterSpacing}px`;
              useExperimentalLetterSpacing = true;
            } else {
              context3.letterSpacing = "0px";
              context3.textLetterSpacing = "0px";
            }
          }
          if (letterSpacing === 0 || useExperimentalLetterSpacing) {
            if (isStroke) {
              context3.strokeText(text, x2, y2);
            } else {
              context3.fillText(text, x2, y2);
            }
            return;
          }
          let currentPosition = x2;
          const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
          let previousWidth = context3.measureText(text).width;
          let currentWidth = 0;
          for (let i2 = 0; i2 < stringArray.length; ++i2) {
            const currentChar = stringArray[i2];
            if (isStroke) {
              context3.strokeText(currentChar, currentPosition, y2);
            } else {
              context3.fillText(currentChar, currentPosition, y2);
            }
            let textStr = "";
            for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
              textStr += stringArray[j2];
            }
            currentWidth = context3.measureText(textStr).width;
            currentPosition += previousWidth - currentWidth + letterSpacing;
            previousWidth = currentWidth;
          }
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      CanvasTextSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "canvasText"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/init.mjs
  var init_init8 = __esm({
    "node_modules/pixi-v8/lib/scene/text/init.mjs"() {
      init_Extensions();
      init_CanvasTextPipe();
      init_CanvasTextSystem();
      extensions3.add(CanvasTextSystem);
      extensions3.add(CanvasTextPipe);
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/shared/Graphics.mjs
  var Graphics2;
  var init_Graphics2 = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/shared/Graphics.mjs"() {
      init_deprecation2();
      init_View();
      init_GraphicsContext();
      Graphics2 = class extends ViewContainer {
        constructor(options) {
          if (options instanceof GraphicsContext) {
            options = { context: options };
          }
          const { context: context3, roundPixels, ...rest } = options || {};
          super({
            label: "Graphics",
            ...rest
          });
          this.renderPipeId = "graphics";
          if (!context3) {
            this._context = this._ownedContext = new GraphicsContext();
          } else {
            this._context = context3;
          }
          this._context.on("update", this.onViewUpdate, this);
          this.allowChildren = false;
          this.roundPixels = roundPixels ?? false;
        }
        set context(context3) {
          if (context3 === this._context)
            return;
          this._context.off("update", this.onViewUpdate, this);
          this._context = context3;
          this._context.on("update", this.onViewUpdate, this);
          this.onViewUpdate();
        }
        get context() {
          return this._context;
        }
        get bounds() {
          return this._context.bounds;
        }
        addBounds(bounds) {
          bounds.addBounds(this._context.bounds);
        }
        containsPoint(point) {
          return this._context.containsPoint(point);
        }
        onViewUpdate() {
          this._didViewChangeTick++;
          this._didGraphicsUpdate = true;
          if (this.didViewUpdate)
            return;
          this.didViewUpdate = true;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
          }
        }
        destroy(options) {
          if (this._ownedContext && !options) {
            this._ownedContext.destroy(options);
          } else if (options === true || options?.context === true) {
            this._context.destroy(options);
          }
          this._ownedContext = null;
          this._context = null;
          super.destroy(options);
        }
        _callContextMethod(method, args) {
          this.context[method](...args);
          return this;
        }
        setFillStyle(...args) {
          return this._callContextMethod("setFillStyle", args);
        }
        setStrokeStyle(...args) {
          return this._callContextMethod("setStrokeStyle", args);
        }
        fill(...args) {
          return this._callContextMethod("fill", args);
        }
        stroke(...args) {
          return this._callContextMethod("stroke", args);
        }
        texture(...args) {
          return this._callContextMethod("texture", args);
        }
        beginPath() {
          return this._callContextMethod("beginPath", []);
        }
        cut() {
          return this._callContextMethod("cut", []);
        }
        arc(...args) {
          return this._callContextMethod("arc", args);
        }
        arcTo(...args) {
          return this._callContextMethod("arcTo", args);
        }
        arcToSvg(...args) {
          return this._callContextMethod("arcToSvg", args);
        }
        bezierCurveTo(...args) {
          return this._callContextMethod("bezierCurveTo", args);
        }
        closePath() {
          return this._callContextMethod("closePath", []);
        }
        ellipse(...args) {
          return this._callContextMethod("ellipse", args);
        }
        circle(...args) {
          return this._callContextMethod("circle", args);
        }
        path(...args) {
          return this._callContextMethod("path", args);
        }
        lineTo(...args) {
          return this._callContextMethod("lineTo", args);
        }
        moveTo(...args) {
          return this._callContextMethod("moveTo", args);
        }
        quadraticCurveTo(...args) {
          return this._callContextMethod("quadraticCurveTo", args);
        }
        rect(...args) {
          return this._callContextMethod("rect", args);
        }
        roundRect(...args) {
          return this._callContextMethod("roundRect", args);
        }
        poly(...args) {
          return this._callContextMethod("poly", args);
        }
        regularPoly(...args) {
          return this._callContextMethod("regularPoly", args);
        }
        roundPoly(...args) {
          return this._callContextMethod("roundPoly", args);
        }
        roundShape(...args) {
          return this._callContextMethod("roundShape", args);
        }
        filletRect(...args) {
          return this._callContextMethod("filletRect", args);
        }
        chamferRect(...args) {
          return this._callContextMethod("chamferRect", args);
        }
        star(...args) {
          return this._callContextMethod("star", args);
        }
        svg(...args) {
          return this._callContextMethod("svg", args);
        }
        restore(...args) {
          return this._callContextMethod("restore", args);
        }
        save() {
          return this._callContextMethod("save", []);
        }
        getTransform() {
          return this.context.getTransform();
        }
        resetTransform() {
          return this._callContextMethod("resetTransform", []);
        }
        rotateTransform(...args) {
          return this._callContextMethod("rotate", args);
        }
        scaleTransform(...args) {
          return this._callContextMethod("scale", args);
        }
        setTransform(...args) {
          return this._callContextMethod("setTransform", args);
        }
        transform(...args) {
          return this._callContextMethod("transform", args);
        }
        translateTransform(...args) {
          return this._callContextMethod("translate", args);
        }
        clear() {
          return this._callContextMethod("clear", []);
        }
        get fillStyle() {
          return this._context.fillStyle;
        }
        set fillStyle(value) {
          this._context.fillStyle = value;
        }
        get strokeStyle() {
          return this._context.strokeStyle;
        }
        set strokeStyle(value) {
          this._context.strokeStyle = value;
        }
        clone(deep = false) {
          if (deep) {
            return new Graphics2(this._context.clone());
          }
          this._ownedContext = null;
          const clone = new Graphics2(this._context);
          return clone;
        }
        lineStyle(width, color, alpha) {
          deprecation2(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
          const strokeStyle = {};
          width && (strokeStyle.width = width);
          color && (strokeStyle.color = color);
          alpha && (strokeStyle.alpha = alpha);
          this.context.strokeStyle = strokeStyle;
          return this;
        }
        beginFill(color, alpha) {
          deprecation2(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          const fillStyle = {};
          color && (fillStyle.color = color);
          alpha && (fillStyle.alpha = alpha);
          this.context.fillStyle = fillStyle;
          return this;
        }
        endFill() {
          deprecation2(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
          this.context.fill();
          const strokeStyle = this.context.strokeStyle;
          if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
            this.context.stroke();
          }
          return this;
        }
        drawCircle(...args) {
          deprecation2(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
          return this._callContextMethod("circle", args);
        }
        drawEllipse(...args) {
          deprecation2(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
          return this._callContextMethod("ellipse", args);
        }
        drawPolygon(...args) {
          deprecation2(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
          return this._callContextMethod("poly", args);
        }
        drawRect(...args) {
          deprecation2(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
          return this._callContextMethod("rect", args);
        }
        drawRoundedRect(...args) {
          deprecation2(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
          return this._callContextMethod("roundRect", args);
        }
        drawStar(...args) {
          deprecation2(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
          return this._callContextMethod("star", args);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
  var localUniformMSDFBit, localUniformMSDFBitGl;
  var init_localUniformMSDFBit = __esm({
    "node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
      "use strict";
      localUniformMSDFBit = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        },
        fragment: {
          header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
          main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        }
      };
      localUniformMSDFBitGl = {
        name: "local-uniform-msdf-bit",
        vertex: {
          header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
          main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
          end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        },
        fragment: {
          header: `
            uniform float uDistance;
         `,
          main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
  var mSDFBit, mSDFBitGl;
  var init_mSDFBit = __esm({
    "node_modules/pixi-v8/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
      "use strict";
      mSDFBit = {
        name: "msdf-bit",
        fragment: {
          header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
        }
      };
      mSDFBitGl = {
        name: "msdf-bit",
        fragment: {
          header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text/sdfShader/SdfShader.mjs
  var gpuProgram, glProgram, SdfShader;
  var init_SdfShader = __esm({
    "node_modules/pixi-v8/lib/scene/text/sdfShader/SdfShader.mjs"() {
      init_Matrix2();
      init_maxRecommendedTextures2();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader2();
      init_UniformGroup2();
      init_localUniformMSDFBit();
      init_mSDFBit();
      SdfShader = class extends Shader2 {
        constructor() {
          const uniforms = new UniformGroup2({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uDistance: { value: 4, type: "f32" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures2 = getMaxTexturesPerBatch();
          gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
            name: "sdf-shader",
            bits: [
              colorBit,
              generateTextureBatchBit(maxTextures2),
              localUniformMSDFBit,
              mSDFBit,
              roundPixelsBit
            ]
          }));
          glProgram ?? (glProgram = compileHighShaderGlProgram({
            name: "sdf-shader",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              localUniformMSDFBitGl,
              mSDFBitGl,
              roundPixelsBitGl
            ]
          }));
          super({
            glProgram,
            gpuProgram,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/AbstractBitmapFont.mjs
  var AbstractBitmapFont;
  var init_AbstractBitmapFont = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
      init_eventemitter3();
      init_deprecation2();
      AbstractBitmapFont = class extends eventemitter3_default {
        constructor() {
          super(...arguments);
          this.chars = /* @__PURE__ */ Object.create(null);
          this.lineHeight = 0;
          this.fontFamily = "";
          this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
          this.baseLineOffset = 0;
          this.distanceField = { type: "none", range: 0 };
          this.pages = [];
          this.applyFillAsTint = true;
          this.baseMeasurementFontSize = 100;
          this.baseRenderedFontSize = 100;
        }
        get font() {
          deprecation2(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
          return this.fontFamily;
        }
        get pageTextures() {
          deprecation2(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        get size() {
          deprecation2(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
          return this.fontMetrics.fontSize;
        }
        get distanceFieldRange() {
          deprecation2(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
          return this.distanceField.range;
        }
        get distanceFieldType() {
          deprecation2(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
          return this.distanceField.type;
        }
        destroy(destroyTextures = false) {
          this.emit("destroy", this);
          this.removeAllListeners();
          for (const i2 in this.chars) {
            this.chars[i2].texture?.destroy();
          }
          this.chars = null;
          if (destroyTextures) {
            this.pages.forEach((page) => page.texture.destroy(true));
            this.pages = null;
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/utils/resolveCharacters.mjs
  function resolveCharacters2(chars) {
    if (chars === "") {
      return [];
    }
    if (typeof chars === "string") {
      chars = [chars];
    }
    const result = [];
    for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
      const item = chars[i2];
      if (Array.isArray(item)) {
        if (item.length !== 2) {
          throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
        }
        if (item[0].length === 0 || item[1].length === 0) {
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        }
        const startCode = item[0].charCodeAt(0);
        const endCode = item[1].charCodeAt(0);
        if (endCode < startCode) {
          throw new Error("[BitmapFont]: Invalid character range.");
        }
        for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
          result.push(String.fromCharCode(i22));
        }
      } else {
        result.push(...Array.from(item));
      }
    }
    if (result.length === 0) {
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    }
    return result;
  }
  var init_resolveCharacters2 = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/DynamicBitmapFont.mjs
  var _DynamicBitmapFont, DynamicBitmapFont;
  var init_DynamicBitmapFont = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
      init_Color2();
      init_Rectangle2();
      init_CanvasPool();
      init_ImageSource();
      init_Texture2();
      init_deprecation2();
      init_CanvasTextMetrics();
      init_fontStringFromTextStyle();
      init_getCanvasFillStyle();
      init_TextStyle2();
      init_AbstractBitmapFont();
      init_resolveCharacters2();
      _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
        constructor(options) {
          super();
          this.resolution = 1;
          this.pages = [];
          this._padding = 0;
          this._measureCache = /* @__PURE__ */ Object.create(null);
          this._currentChars = [];
          this._currentX = 0;
          this._currentY = 0;
          this._currentPageIndex = -1;
          this._skipKerning = false;
          const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
          this._textureSize = dynamicOptions.textureSize;
          this._mipmap = dynamicOptions.mipmap;
          const style = dynamicOptions.style.clone();
          if (dynamicOptions.overrideFill) {
            style._fill.color = 16777215;
            style._fill.alpha = 1;
            style._fill.texture = Texture2.WHITE;
            style._fill.fill = null;
          }
          this.applyFillAsTint = dynamicOptions.overrideFill;
          const requestedFontSize = style.fontSize;
          style.fontSize = this.baseMeasurementFontSize;
          const font = fontStringFromTextStyle(style);
          if (dynamicOptions.overrideSize) {
            if (style._stroke) {
              style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
            }
          } else {
            style.fontSize = this.baseRenderedFontSize = requestedFontSize;
          }
          this._style = style;
          this._skipKerning = dynamicOptions.skipKerning ?? false;
          this.resolution = dynamicOptions.resolution ?? 1;
          this._padding = dynamicOptions.padding ?? 4;
          this.fontMetrics = CanvasTextMetrics.measureFont(font);
          this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
        }
        ensureCharacters(chars) {
          const charList = resolveCharacters2(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
          if (!charList.length)
            return;
          this._currentChars = [...this._currentChars, ...charList];
          let pageData;
          if (this._currentPageIndex === -1) {
            pageData = this._nextPage();
          } else {
            pageData = this.pages[this._currentPageIndex];
          }
          let { canvas, context: context3 } = pageData.canvasAndContext;
          let textureSource = pageData.texture.source;
          const style = this._style;
          let currentX = this._currentX;
          let currentY = this._currentY;
          const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
          const padding = this._padding * fontScale;
          const widthScale = style.fontStyle === "italic" ? 2 : 1;
          let maxCharHeight = 0;
          let skipTexture = false;
          for (let i2 = 0; i2 < charList.length; i2++) {
            const char = charList[i2];
            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
            metrics.lineHeight = metrics.height;
            const width = widthScale * metrics.width * fontScale;
            const height = metrics.height * fontScale;
            const paddedWidth = width + padding * 2;
            const paddedHeight = height + padding * 2;
            skipTexture = false;
            if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
              skipTexture = true;
              maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
            }
            if (currentX + paddedWidth > this._textureSize) {
              currentY += maxCharHeight;
              maxCharHeight = paddedHeight;
              currentX = 0;
              if (currentY + maxCharHeight > this._textureSize) {
                textureSource.update();
                const pageData2 = this._nextPage();
                canvas = pageData2.canvasAndContext.canvas;
                context3 = pageData2.canvasAndContext.context;
                textureSource = pageData2.texture.source;
                currentY = 0;
              }
            }
            const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
            this.chars[char] = {
              id: char.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance,
              kerning: {}
            };
            if (skipTexture) {
              this._drawGlyph(
                context3,
                metrics,
                currentX + padding,
                currentY + padding,
                fontScale,
                style
              );
              const px = textureSource.width * fontScale;
              const py = textureSource.height * fontScale;
              const frame = new Rectangle2(
                currentX / px * textureSource.width,
                currentY / py * textureSource.height,
                paddedWidth / px * textureSource.width,
                paddedHeight / py * textureSource.height
              );
              this.chars[char].texture = new Texture2({
                source: textureSource,
                frame
              });
              currentX += Math.ceil(paddedWidth);
            }
          }
          textureSource.update();
          this._currentX = currentX;
          this._currentY = currentY;
          this._skipKerning && this._applyKerning(charList, context3);
        }
        get pageTextures() {
          deprecation2(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
          return this.pages;
        }
        _applyKerning(newChars, context3) {
          const measureCache = this._measureCache;
          for (let i2 = 0; i2 < newChars.length; i2++) {
            const first = newChars[i2];
            for (let j2 = 0; j2 < this._currentChars.length; j2++) {
              const second = this._currentChars[j2];
              let c1 = measureCache[first];
              if (!c1)
                c1 = measureCache[first] = context3.measureText(first).width;
              let c2 = measureCache[second];
              if (!c2)
                c2 = measureCache[second] = context3.measureText(second).width;
              let total = context3.measureText(first + second).width;
              let amount = total - (c1 + c2);
              if (amount) {
                this.chars[first].kerning[second] = amount;
              }
              total = context3.measureText(first + second).width;
              amount = total - (c1 + c2);
              if (amount) {
                this.chars[second].kerning[first] = amount;
              }
            }
          }
        }
        _nextPage() {
          this._currentPageIndex++;
          const textureResolution = this.resolution;
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
            this._textureSize,
            this._textureSize,
            textureResolution
          );
          this._setupContext(canvasAndContext.context, this._style, textureResolution);
          const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
          const texture = new Texture2({
            source: new ImageSource({
              resource: canvasAndContext.canvas,
              resolution,
              alphaMode: "premultiply-alpha-on-upload",
              autoGenerateMipmaps: this._mipmap
            })
          });
          const pageData = {
            canvasAndContext,
            texture
          };
          this.pages[this._currentPageIndex] = pageData;
          return pageData;
        }
        _setupContext(context3, style, resolution) {
          style.fontSize = this.baseRenderedFontSize;
          context3.scale(resolution, resolution);
          context3.font = fontStringFromTextStyle(style);
          style.fontSize = this.baseMeasurementFontSize;
          context3.textBaseline = style.textBaseline;
          const stroke = style._stroke;
          const strokeThickness = stroke?.width ?? 0;
          if (stroke) {
            context3.lineWidth = strokeThickness;
            context3.lineJoin = stroke.join;
            context3.miterLimit = stroke.miterLimit;
            context3.strokeStyle = getCanvasFillStyle(stroke, context3);
          }
          if (style._fill) {
            context3.fillStyle = getCanvasFillStyle(style._fill, context3);
          }
          if (style.dropShadow) {
            const shadowOptions = style.dropShadow;
            const rgb = Color2.shared.setValue(shadowOptions.color).toArray();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context3.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
            context3.shadowBlur = dropShadowBlur;
            context3.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context3.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
          } else {
            context3.shadowColor = "black";
            context3.shadowBlur = 0;
            context3.shadowOffsetX = 0;
            context3.shadowOffsetY = 0;
          }
        }
        _drawGlyph(context3, metrics, x2, y2, fontScale, style) {
          const char = metrics.text;
          const fontProperties = metrics.fontProperties;
          const stroke = style._stroke;
          const strokeThickness = (stroke?.width ?? 0) * fontScale;
          const tx = x2 + strokeThickness / 2;
          const ty = y2 - strokeThickness / 2;
          const descent = fontProperties.descent * fontScale;
          const lineHeight = metrics.lineHeight * fontScale;
          if (style.stroke && strokeThickness) {
            context3.strokeText(char, tx, ty + lineHeight - descent);
          }
          if (style._fill) {
            context3.fillText(char, tx, ty + lineHeight - descent);
          }
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { canvasAndContext, texture } = this.pages[i2];
            canvasAndContext.canvas.width = canvasAndContext.canvas.width;
            CanvasPool.returnCanvasAndContext(canvasAndContext);
            texture.destroy(true);
          }
          this.pages = null;
        }
      };
      _DynamicBitmapFont.defaultOptions = {
        textureSize: 512,
        style: new TextStyle2(),
        mipmap: true
      };
      DynamicBitmapFont = _DynamicBitmapFont;
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
  function getBitmapTextLayout(chars, style, font, trimEnd) {
    const layoutData = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: style.fontSize / font.baseMeasurementFontSize,
      lines: [{
        width: 0,
        charPositions: [],
        spaceWidth: 0,
        spacesIndex: [],
        chars: []
      }]
    };
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    let previousChar = null;
    let firstWord = true;
    const currentWord = {
      spaceWord: false,
      width: 0,
      start: 0,
      index: 0,
      positions: [],
      chars: []
    };
    const nextWord = (word) => {
      const start = currentLine.width;
      for (let j2 = 0; j2 < currentWord.index; j2++) {
        const position = word.positions[j2];
        currentLine.chars.push(word.chars[j2]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = false;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    };
    const nextLine = () => {
      let index = currentLine.chars.length - 1;
      if (trimEnd) {
        let lastChar = currentLine.chars[index];
        while (lastChar === " ") {
          currentLine.width -= font.chars[lastChar].xAdvance;
          lastChar = currentLine.chars[--index];
        }
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {
        width: 0,
        charPositions: [],
        chars: [],
        spaceWidth: 0,
        spacesIndex: []
      };
      firstWord = true;
      layoutData.lines.push(currentLine);
      layoutData.height += font.lineHeight;
    };
    const scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    for (let i2 = 0; i2 < chars.length + 1; i2++) {
      let char;
      const isEnd = i2 === chars.length;
      if (!isEnd) {
        char = chars[i2];
      }
      const charData = font.chars[char] || font.chars[" "];
      const isSpace = /(?:\s)/.test(char);
      const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
      if (isWordBreak) {
        const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
        if (addWordToNextLine) {
          nextLine();
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        } else {
          currentWord.start = currentLine.width;
          nextWord(currentWord);
          if (!isEnd) {
            currentLine.charPositions.push(0);
          }
        }
        if (char === "\r" || char === "\n") {
          if (currentLine.width !== 0) {
            nextLine();
          }
        } else if (!isEnd) {
          const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
          currentLine.width += spaceWidth;
          currentLine.spaceWidth = spaceWidth;
          currentLine.spacesIndex.push(currentLine.charPositions.length);
          currentLine.chars.push(char);
        }
      } else {
        const kerning = charData.kerning[previousChar] || 0;
        const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
        currentWord.positions[currentWord.index++] = currentWord.width + kerning;
        currentWord.chars.push(char);
        currentWord.width += nextCharWidth;
      }
      previousChar = char;
    }
    nextLine();
    if (style.align === "center") {
      alignCenter(layoutData);
    } else if (style.align === "right") {
      alignRight(layoutData);
    } else if (style.align === "justify") {
      alignJustify(layoutData);
    }
    return layoutData;
  }
  function alignCenter(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width / 2 - line.width / 2;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      const offset = measurementData.width - line.width;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        line.charPositions[j2] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
      const line = measurementData.lines[i2];
      let indy = 0;
      let spaceIndex = line.spacesIndex[indy++];
      let offset = 0;
      const totalSpaces = line.spacesIndex.length;
      const newSpaceWidth = (width - line.width) / totalSpaces;
      const spaceWidth = newSpaceWidth;
      for (let j2 = 0; j2 < line.charPositions.length; j2++) {
        if (j2 === spaceIndex) {
          spaceIndex = line.spacesIndex[indy++];
          offset += spaceWidth;
        }
        line.charPositions[j2] += offset;
      }
    }
  }
  var init_getBitmapTextLayout = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/BitmapFontManager.mjs
  var fontCount, BitmapFontManagerClass, BitmapFontManager;
  var init_BitmapFontManager = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
      init_Cache2();
      init_deprecation2();
      init_warn();
      init_TextStyle2();
      init_DynamicBitmapFont();
      init_getBitmapTextLayout();
      init_resolveCharacters2();
      fontCount = 0;
      BitmapFontManagerClass = class {
        constructor() {
          this.ALPHA = [["a", "z"], ["A", "Z"], " "];
          this.NUMERIC = [["0", "9"]];
          this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
          this.ASCII = [[" ", "~"]];
          this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: false
          };
        }
        getFont(text, style) {
          let fontFamilyKey = `${style.fontFamily}-bitmap`;
          let overrideFill = true;
          if (style._fill.fill && !style._stroke) {
            fontFamilyKey += style._fill.fill.styleKey;
            overrideFill = false;
          } else if (style._stroke || style.dropShadow) {
            let key = style.styleKey;
            key = key.substring(0, key.lastIndexOf("-"));
            fontFamilyKey = `${key}-bitmap`;
            overrideFill = false;
          }
          if (!Cache2.has(fontFamilyKey)) {
            const fnt = new DynamicBitmapFont({
              style,
              overrideFill,
              overrideSize: true,
              ...this.defaultOptions
            });
            fontCount++;
            if (fontCount > 50) {
              warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
            }
            fnt.once("destroy", () => {
              fontCount--;
              Cache2.remove(fontFamilyKey);
            });
            Cache2.set(
              fontFamilyKey,
              fnt
            );
          }
          const dynamicFont = Cache2.get(fontFamilyKey);
          dynamicFont.ensureCharacters?.(text);
          return dynamicFont;
        }
        getLayout(text, style, trimEnd = true) {
          const bitmapFont = this.getFont(text, style);
          return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);
        }
        measureText(text, style, trimEnd = true) {
          return this.getLayout(text, style, trimEnd);
        }
        install(...args) {
          let options = args[0];
          if (typeof options === "string") {
            options = {
              name: options,
              style: args[1],
              chars: args[2]?.chars,
              resolution: args[2]?.resolution,
              padding: args[2]?.padding,
              skipKerning: args[2]?.skipKerning
            };
            deprecation2(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
          }
          const name = options?.name;
          if (!name) {
            throw new Error("[BitmapFontManager] Property `name` is required.");
          }
          options = { ...this.defaultOptions, ...options };
          const textStyle = options.style;
          const style = textStyle instanceof TextStyle2 ? textStyle : new TextStyle2(textStyle);
          const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
          const font = new DynamicBitmapFont({
            style,
            overrideFill,
            skipKerning: options.skipKerning,
            padding: options.padding,
            resolution: options.resolution,
            overrideSize: false
          });
          const flatChars = resolveCharacters2(options.chars);
          font.ensureCharacters(flatChars.join(""));
          Cache2.set(`${name}-bitmap`, font);
          font.once("destroy", () => Cache2.remove(`${name}-bitmap`));
          return font;
        }
        uninstall(name) {
          const cacheKey = `${name}-bitmap`;
          const font = Cache2.get(cacheKey);
          if (font) {
            Cache2.remove(cacheKey);
            font.destroy();
          }
        }
      };
      BitmapFontManager = new BitmapFontManagerClass();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/BitmapTextPipe.mjs
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }
  var BitmapTextPipe;
  var init_BitmapTextPipe = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
      init_Cache2();
      init_Extensions();
      init_PoolGroup();
      init_Graphics2();
      init_SdfShader();
      init_BitmapFontManager();
      init_getBitmapTextLayout();
      BitmapTextPipe = class {
        constructor(renderer) {
          this._gpuBitmapText = {};
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
        }
        validateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
        }
        addRenderable(bitmapText, instructionSet) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          if (bitmapText._didTextUpdate) {
            bitmapText._didTextUpdate = false;
            this._updateContext(bitmapText, graphicsRenderable);
          }
          this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        destroyRenderable(bitmapText) {
          bitmapText.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableByUid(bitmapText.uid);
        }
        _destroyRenderableByUid(renderableUid) {
          const context3 = this._gpuBitmapText[renderableUid].context;
          if (context3.customShader) {
            BigPool.return(context3.customShader);
            context3.customShader = null;
          }
          BigPool.return(this._gpuBitmapText[renderableUid]);
          this._gpuBitmapText[renderableUid] = null;
        }
        updateRenderable(bitmapText) {
          const graphicsRenderable = this._getGpuBitmapText(bitmapText);
          syncWithProxy(bitmapText, graphicsRenderable);
          this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
          if (graphicsRenderable.context.customShader) {
            this._updateDistanceField(bitmapText);
          }
        }
        _updateContext(bitmapText, proxyGraphics) {
          const { context: context3 } = proxyGraphics;
          const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
          context3.clear();
          if (bitmapFont.distanceField.type !== "none") {
            if (!context3.customShader) {
              context3.customShader = BigPool.get(SdfShader);
            }
          }
          const chars = Array.from(bitmapText.text);
          const style = bitmapText._style;
          let currentY = bitmapFont.baseLineOffset;
          const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
          let index = 0;
          const padding = style.padding;
          const scale = bitmapTextLayout.scale;
          let tx = bitmapTextLayout.width;
          let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
          if (style._stroke) {
            tx += style._stroke.width / scale;
            ty += style._stroke.width / scale;
          }
          context3.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
          const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
          for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
            const line = bitmapTextLayout.lines[i2];
            for (let j2 = 0; j2 < line.charPositions.length; j2++) {
              const char = chars[index++];
              const charData = bitmapFont.chars[char];
              if (charData?.texture) {
                context3.texture(
                  charData.texture,
                  tint ? tint : "black",
                  Math.round(line.charPositions[j2] + charData.xOffset),
                  Math.round(currentY + charData.yOffset)
                );
              }
            }
            currentY += bitmapFont.lineHeight;
          }
        }
        _getGpuBitmapText(bitmapText) {
          return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
        }
        initGpuText(bitmapText) {
          const proxyRenderable = BigPool.get(Graphics2);
          this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
          this._updateContext(bitmapText, proxyRenderable);
          bitmapText.on("destroyed", this._destroyRenderableBound);
          return this._gpuBitmapText[bitmapText.uid];
        }
        _updateDistanceField(bitmapText) {
          const context3 = this._getGpuBitmapText(bitmapText).context;
          const fontFamily = bitmapText._style.fontFamily;
          const dynamicFont = Cache2.get(`${fontFamily}-bitmap`);
          const { a: a2, b: b2, c: c2, d: d2 } = bitmapText.groupTransform;
          const dx = Math.sqrt(a2 * a2 + b2 * b2);
          const dy = Math.sqrt(c2 * c2 + d2 * d2);
          const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
          const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
          const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
          context3.customShader.resources.localUniforms.uniforms.uDistance = distance;
        }
        destroy() {
          for (const uid4 in this._gpuBitmapText) {
            this._destroyRenderableByUid(uid4);
          }
          this._gpuBitmapText = null;
          this._renderer = null;
        }
      };
      BitmapTextPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "bitmapText"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/init.mjs
  var init_init9 = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/init.mjs"() {
      init_Extensions();
      init_BitmapTextPipe();
      extensions3.add(BitmapTextPipe);
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/HTMLTextPipe.mjs
  var HTMLTextPipe;
  var init_HTMLTextPipe = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/HTMLTextPipe.mjs"() {
      init_Extensions();
      init_Texture2();
      init_updateQuadBounds();
      init_PoolGroup();
      init_BatchableSprite();
      HTMLTextPipe = class {
        constructor(renderer) {
          this._gpuText = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
          this._renderer.runners.resolutionChange.add(this);
        }
        resolutionChange() {
          for (const i2 in this._gpuText) {
            const gpuText = this._gpuText[i2];
            if (!gpuText)
              continue;
            const text = gpuText.batchableSprite.renderable;
            if (text._autoResolution) {
              text._resolution = this._renderer.resolution;
              text.onViewUpdate();
            }
          }
        }
        validateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const newKey = htmlText._getKey();
          if (gpuText.textureNeedsUploading) {
            gpuText.textureNeedsUploading = false;
            return true;
          }
          if (gpuText.currentKey !== newKey) {
            return true;
          }
          return false;
        }
        addRenderable(htmlText, instructionSet) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
        }
        updateRenderable(htmlText) {
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (htmlText._didTextUpdate) {
            this._updateText(htmlText);
          }
          batchableSprite._batcher.updateElement(batchableSprite);
        }
        destroyRenderable(htmlText) {
          htmlText.off("destroyed", this._destroyRenderableBound);
          this._destroyRenderableById(htmlText.uid);
        }
        _destroyRenderableById(htmlTextUid) {
          const gpuText = this._gpuText[htmlTextUid];
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          BigPool.return(gpuText.batchableSprite);
          this._gpuText[htmlTextUid] = null;
        }
        _updateText(htmlText) {
          const newKey = htmlText._getKey();
          const gpuText = this._getGpuText(htmlText);
          const batchableSprite = gpuText.batchableSprite;
          if (gpuText.currentKey !== newKey) {
            this._updateGpuText(htmlText).catch((e2) => {
              console.error(e2);
            });
          }
          htmlText._didTextUpdate = false;
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        async _updateGpuText(htmlText) {
          htmlText._didTextUpdate = false;
          const gpuText = this._getGpuText(htmlText);
          if (gpuText.generatingTexture)
            return;
          const newKey = htmlText._getKey();
          this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
          gpuText.generatingTexture = true;
          gpuText.currentKey = newKey;
          const resolution = htmlText.resolution ?? this._renderer.resolution;
          const texture = await this._renderer.htmlText.getManagedTexture(
            htmlText.text,
            resolution,
            htmlText._style,
            htmlText._getKey()
          );
          const batchableSprite = gpuText.batchableSprite;
          batchableSprite.texture = gpuText.texture = texture;
          gpuText.generatingTexture = false;
          gpuText.textureNeedsUploading = true;
          htmlText.onViewUpdate();
          const padding = htmlText._style.padding;
          updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
        }
        _getGpuText(htmlText) {
          return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
        }
        initGpuText(htmlText) {
          const gpuTextData = {
            texture: Texture2.EMPTY,
            currentKey: "--",
            batchableSprite: BigPool.get(BatchableSprite),
            textureNeedsUploading: false,
            generatingTexture: false
          };
          const batchableSprite = gpuTextData.batchableSprite;
          batchableSprite.renderable = htmlText;
          batchableSprite.transform = htmlText.groupTransform;
          batchableSprite.texture = Texture2.EMPTY;
          batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
          batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
          htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
          this._gpuText[htmlText.uid] = gpuTextData;
          htmlText.on("destroyed", this._destroyRenderableBound);
          return gpuTextData;
        }
        destroy() {
          for (const i2 in this._gpuText) {
            this._destroyRenderableById(i2);
          }
          this._gpuText = null;
          this._renderer = null;
        }
      };
      HTMLTextPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "htmlText"
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/isSafari.mjs
  function isSafari() {
    const { userAgent } = DOMAdapter.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  var init_isSafari = __esm({
    "node_modules/pixi-v8/lib/utils/browser/isSafari.mjs"() {
      init_adapter2();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/HTMLTextRenderData.mjs
  var nssvg, nsxhtml, HTMLTextRenderData;
  var init_HTMLTextRenderData = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/HTMLTextRenderData.mjs"() {
      "use strict";
      nssvg = "http://www.w3.org/2000/svg";
      nsxhtml = "http://www.w3.org/1999/xhtml";
      HTMLTextRenderData = class {
        constructor() {
          this.svgRoot = document.createElementNS(nssvg, "svg");
          this.foreignObject = document.createElementNS(nssvg, "foreignObject");
          this.domElement = document.createElementNS(nsxhtml, "div");
          this.styleElement = document.createElementNS(nsxhtml, "style");
          this.image = new Image();
          const { foreignObject, svgRoot, styleElement, domElement } = this;
          foreignObject.setAttribute("width", "10000");
          foreignObject.setAttribute("height", "10000");
          foreignObject.style.overflow = "hidden";
          svgRoot.appendChild(foreignObject);
          foreignObject.appendChild(styleElement);
          foreignObject.appendChild(domElement);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/textStyleToCSS.mjs
  function textStyleToCSS(style) {
    const stroke = style._stroke;
    const fill = style._fill;
    const cssStyleString = [
      `color: ${Color2.shared.setValue(fill.color).toHex()}`,
      `font-size: ${style.fontSize}px`,
      `font-family: ${style.fontFamily}`,
      `font-weight: ${style.fontWeight}`,
      `font-style: ${style.fontStyle}`,
      `font-variant: ${style.fontVariant}`,
      `letter-spacing: ${style.letterSpacing}px`,
      `text-align: ${style.align}`,
      `padding: ${style.padding}px`,
      `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
      ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
      ...style.wordWrap ? [
        `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${style.wordWrapWidth}px`
      ] : [],
      ...stroke ? [strokeToCSS(stroke)] : [],
      ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
      ...style.cssOverrides
    ].join(";");
    const cssStyles = [`div { ${cssStyleString} }`];
    tagStyleToCSS(style.tagStyles, cssStyles);
    return cssStyles.join(" ");
  }
  function dropShadowToCSS(dropShadowStyle) {
    const color = Color2.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
    const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
    const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
    const position = `${x2}px ${y2}px`;
    if (dropShadowStyle.blur > 0) {
      return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  function strokeToCSS(stroke) {
    return [
      `-webkit-text-stroke-width: ${stroke.width}px`,
      `-webkit-text-stroke-color: ${Color2.shared.setValue(stroke.color).toHex()}`,
      `text-stroke-width: ${stroke.width}px`,
      `text-stroke-color: ${Color2.shared.setValue(stroke.color).toHex()}`,
      "paint-order: stroke"
    ].join(";");
  }
  function tagStyleToCSS(tagStyles, out2) {
    for (const i2 in tagStyles) {
      const tagStyle = tagStyles[i2];
      const cssTagStyle = [];
      for (const j2 in tagStyle) {
        if (transform[j2]) {
          cssTagStyle.push(transform[j2](tagStyle[j2]));
        } else if (templates[j2]) {
          cssTagStyle.push(templates[j2].replace("{{VALUE}}", tagStyle[j2]));
        }
      }
      out2.push(`${i2} { ${cssTagStyle.join(";")} }`);
    }
  }
  var templates, transform;
  var init_textStyleToCSS = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/textStyleToCSS.mjs"() {
      init_Color2();
      templates = {
        fontSize: `font-size: {{VALUE}}px`,
        fontFamily: `font-family: {{VALUE}}`,
        fontWeight: `font-weight: {{VALUE}}`,
        fontStyle: `font-style: {{VALUE}}`,
        fontVariant: `font-variant: {{VALUE}}`,
        letterSpacing: `letter-spacing: {{VALUE}}px`,
        align: `text-align: {{VALUE}}`,
        padding: `padding: {{VALUE}}px`,
        whiteSpace: `white-space: {{VALUE}}`,
        lineHeight: `line-height: {{VALUE}}px`,
        wordWrapWidth: `max-width: {{VALUE}}px`
      };
      transform = {
        fill: (value) => `color: ${Color2.shared.setValue(value).toHex()}`,
        breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
        stroke: strokeToCSS,
        dropShadow: dropShadowToCSS
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/HtmlTextStyle.mjs
  var HTMLTextStyle2;
  var init_HtmlTextStyle = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/HtmlTextStyle.mjs"() {
      init_warn();
      init_TextStyle2();
      init_generateTextStyleKey();
      init_textStyleToCSS();
      HTMLTextStyle2 = class extends TextStyle2 {
        constructor(options = {}) {
          super(options);
          this._cssOverrides = [];
          this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
          this.tagStyles = options.tagStyles ?? {};
        }
        set cssOverrides(value) {
          this._cssOverrides = value instanceof Array ? value : [value];
          this.update();
        }
        get cssOverrides() {
          return this._cssOverrides;
        }
        _generateKey() {
          this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
          return this._styleKey;
        }
        update() {
          this._cssStyle = null;
          super.update();
        }
        clone() {
          return new HTMLTextStyle2({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides
          });
        }
        get cssStyle() {
          if (!this._cssStyle) {
            this._cssStyle = textStyleToCSS(this);
          }
          return this._cssStyle;
        }
        addOverride(...value) {
          const toAdd = value.filter((v2) => !this.cssOverrides.includes(v2));
          if (toAdd.length > 0) {
            this.cssOverrides.push(...toAdd);
            this.update();
          }
        }
        removeOverride(...value) {
          const toRemove = value.filter((v2) => this.cssOverrides.includes(v2));
          if (toRemove.length > 0) {
            this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
            this.update();
          }
        }
        set fill(value) {
          if (typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
          }
          super.fill = value;
        }
        set stroke(value) {
          if (value && typeof value !== "string" && typeof value !== "number") {
            warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
          }
          super.stroke = value;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/extractFontFamilies.mjs
  function extractFontFamilies(text, style) {
    const fontFamily = style.fontFamily;
    const fontFamilies = [];
    const dedupe = {};
    const regex = /font-family:([^;"\s]+)/g;
    const matches = text.match(regex);
    function addFontFamily(fontFamily2) {
      if (!dedupe[fontFamily2]) {
        fontFamilies.push(fontFamily2);
        dedupe[fontFamily2] = true;
      }
    }
    if (Array.isArray(fontFamily)) {
      for (let i2 = 0; i2 < fontFamily.length; i2++) {
        addFontFamily(fontFamily[i2]);
      }
    } else {
      addFontFamily(fontFamily);
    }
    if (matches) {
      matches.forEach((match) => {
        const fontFamily2 = match.split(":")[1].trim();
        addFontFamily(fontFamily2);
      });
    }
    for (const i2 in style.tagStyles) {
      const fontFamily2 = style.tagStyles[i2].fontFamily;
      addFontFamily(fontFamily2);
    }
    return fontFamilies;
  }
  var init_extractFontFamilies = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/loadFontAsBase64.mjs
  async function loadFontAsBase64(url2) {
    const response = await DOMAdapter.get().fetch(url2);
    const blob = await response.blob();
    const reader = new FileReader();
    const dataSrc = await new Promise((resolve2, reject) => {
      reader.onloadend = () => resolve2(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    return dataSrc;
  }
  var init_loadFontAsBase64 = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
      init_adapter2();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/loadFontCSS.mjs
  async function loadFontCSS(style, url2) {
    const dataSrc = await loadFontAsBase64(url2);
    return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
  }
  var init_loadFontCSS = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/loadFontCSS.mjs"() {
      init_loadFontAsBase64();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/getFontCss.mjs
  async function getFontCss(fontFamilies, style, defaultOptions) {
    const fontPromises = fontFamilies.filter((fontFamily) => Cache2.has(`${fontFamily}-and-url`)).map((fontFamily, i2) => {
      if (!FontStylePromiseCache.has(fontFamily)) {
        const { url: url2 } = Cache2.get(`${fontFamily}-and-url`);
        if (i2 === 0) {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: style.fontWeight,
            fontStyle: style.fontStyle,
            fontFamily
          }, url2));
        } else {
          FontStylePromiseCache.set(fontFamily, loadFontCSS({
            fontWeight: defaultOptions.fontWeight,
            fontStyle: defaultOptions.fontStyle,
            fontFamily
          }, url2));
        }
      }
      return FontStylePromiseCache.get(fontFamily);
    });
    return (await Promise.all(fontPromises)).join("\n");
  }
  var FontStylePromiseCache;
  var init_getFontCss = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/getFontCss.mjs"() {
      init_Cache2();
      init_loadFontCSS();
      FontStylePromiseCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/getSVGUrl.mjs
  function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
    const { domElement, styleElement, svgRoot } = htmlTextData;
    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
    domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
    styleElement.textContent = fontCSS;
    const { width, height } = htmlTextData.image;
    svgRoot.setAttribute("width", width.toString());
    svgRoot.setAttribute("height", height.toString());
    return new XMLSerializer().serializeToString(svgRoot);
  }
  var init_getSVGUrl = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/getSVGUrl.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
  function getTemporaryCanvasFromImage(image, resolution) {
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      image.width,
      image.height,
      resolution
    );
    const { context: context3 } = canvasAndContext;
    context3.clearRect(0, 0, image.width, image.height);
    context3.drawImage(image, 0, 0);
    CanvasPool.returnCanvasAndContext(canvasAndContext);
    return canvasAndContext.canvas;
  }
  var init_getTemporaryCanvasFromImage = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
      init_CanvasPool();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/loadSVGImage.mjs
  function loadSVGImage(image, url2, delay) {
    return new Promise(async (resolve2) => {
      if (delay) {
        await new Promise((resolve22) => setTimeout(resolve22, 100));
      }
      image.onload = () => {
        resolve2();
      };
      image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url2)}`;
      image.crossOrigin = "anonymous";
    });
  }
  var init_loadSVGImage = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/loadSVGImage.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/utils/measureHtmlText.mjs
  function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
    htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
    const { domElement, styleElement, svgRoot } = htmlTextRenderData;
    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
    domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
    if (fontStyleCSS) {
      styleElement.textContent = fontStyleCSS;
    }
    document.body.appendChild(svgRoot);
    const contentBounds = domElement.getBoundingClientRect();
    svgRoot.remove();
    const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;
    const doublePadding = style.padding * 2;
    return {
      width: contentBounds.width - doublePadding,
      height: contentBounds.height + descenderPadding - doublePadding
    };
  }
  var tempHTMLTextRenderData;
  var init_measureHtmlText = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/utils/measureHtmlText.mjs"() {
      init_CanvasTextMetrics();
      init_HTMLTextRenderData();
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/HTMLTextSystem.mjs
  var HTMLTextSystem;
  var init_HTMLTextSystem = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/HTMLTextSystem.mjs"() {
      init_Extensions();
      init_TexturePool();
      init_types2();
      init_isSafari();
      init_warn();
      init_PoolGroup();
      init_getPo2TextureFromSource();
      init_HTMLTextRenderData();
      init_HtmlTextStyle();
      init_extractFontFamilies();
      init_getFontCss();
      init_getSVGUrl();
      init_getTemporaryCanvasFromImage();
      init_loadSVGImage();
      init_measureHtmlText();
      HTMLTextSystem = class {
        constructor(renderer) {
          this._activeTextures = {};
          this._renderer = renderer;
          this._createCanvas = renderer.type === RendererType.WEBGPU;
        }
        getTexture(options) {
          return this._buildTexturePromise(
            options.text,
            options.resolution,
            options.style
          );
        }
        getManagedTexture(text, resolution, style, textKey) {
          if (this._activeTextures[textKey]) {
            this._increaseReferenceCount(textKey);
            return this._activeTextures[textKey].promise;
          }
          const promise3 = this._buildTexturePromise(text, resolution, style).then((texture) => {
            this._activeTextures[textKey].texture = texture;
            return texture;
          });
          this._activeTextures[textKey] = {
            texture: null,
            promise: promise3,
            usageCount: 1
          };
          return promise3;
        }
        async _buildTexturePromise(text, resolution, style) {
          const htmlTextData = BigPool.get(HTMLTextRenderData);
          const fontFamilies = extractFontFamilies(text, style);
          const fontCSS = await getFontCss(
            fontFamilies,
            style,
            HTMLTextStyle2.defaultTextStyle
          );
          const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
          const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
          const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
          const image = htmlTextData.image;
          const uvSafeOffset = 2;
          image.width = (width | 0) + uvSafeOffset;
          image.height = (height | 0) + uvSafeOffset;
          const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
          await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
          let resource = image;
          if (this._createCanvas) {
            resource = getTemporaryCanvasFromImage(image, resolution);
          }
          const texture = getPo2TextureFromSource(
            resource,
            image.width - uvSafeOffset,
            image.height - uvSafeOffset,
            resolution
          );
          if (this._createCanvas) {
            this._renderer.texture.initSource(texture.source);
          }
          BigPool.return(htmlTextData);
          return texture;
        }
        _increaseReferenceCount(textKey) {
          this._activeTextures[textKey].usageCount++;
        }
        decreaseReferenceCount(textKey) {
          const activeTexture = this._activeTextures[textKey];
          if (!activeTexture)
            return;
          activeTexture.usageCount--;
          if (activeTexture.usageCount === 0) {
            if (activeTexture.texture) {
              this._cleanUp(activeTexture);
            } else {
              activeTexture.promise.then((texture) => {
                activeTexture.texture = texture;
                this._cleanUp(activeTexture);
              }).catch(() => {
                warn("HTMLTextSystem: Failed to clean texture");
              });
            }
            this._activeTextures[textKey] = null;
          }
        }
        _cleanUp(activeTexture) {
          TexturePool.returnTexture(activeTexture.texture);
          activeTexture.texture.source.resource = null;
          activeTexture.texture.source.uploadMethodId = "unknown";
        }
        getReferenceCount(textKey) {
          return this._activeTextures[textKey].usageCount;
        }
        destroy() {
          this._activeTextures = null;
        }
      };
      HTMLTextSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "htmlText"
      };
      HTMLTextSystem.defaultFontOptions = {
        fontFamily: "Arial",
        fontStyle: "normal",
        fontWeight: "normal"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-html/init.mjs
  var init_init10 = __esm({
    "node_modules/pixi-v8/lib/scene/text-html/init.mjs"() {
      init_Extensions();
      init_HTMLTextPipe();
      init_HTMLTextSystem();
      extensions3.add(HTMLTextSystem);
      extensions3.add(HTMLTextPipe);
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/shared/MeshGeometry.mjs
  var _MeshGeometry, MeshGeometry2;
  var init_MeshGeometry2 = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/shared/MeshGeometry.mjs"() {
      init_Buffer2();
      init_const10();
      init_Geometry2();
      init_deprecation2();
      _MeshGeometry = class _MeshGeometry2 extends Geometry2 {
        constructor(...args) {
          let options = args[0] ?? {};
          if (options instanceof Float32Array) {
            deprecation2(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
            options = {
              positions: options,
              uvs: args[1],
              indices: args[2]
            };
          }
          options = { ..._MeshGeometry2.defaultOptions, ...options };
          const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          const indices2 = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
          const shrinkToFit = options.shrinkBuffersToFit;
          const positionBuffer = new Buffer3({
            data: positions,
            label: "attribute-mesh-positions",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const uvBuffer = new Buffer3({
            data: uvs,
            label: "attribute-mesh-uvs",
            shrinkToFit,
            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
          });
          const indexBuffer = new Buffer3({
            data: indices2,
            label: "index-mesh-buffer",
            shrinkToFit,
            usage: BufferUsage.INDEX | BufferUsage.COPY_DST
          });
          super({
            attributes: {
              aPosition: {
                buffer: positionBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              },
              aUV: {
                buffer: uvBuffer,
                format: "float32x2",
                stride: 2 * 4,
                offset: 0
              }
            },
            indexBuffer,
            topology: options.topology
          });
          this.batchMode = "auto";
        }
        get positions() {
          return this.attributes.aPosition.buffer.data;
        }
        set positions(value) {
          this.attributes.aPosition.buffer.data = value;
        }
        get uvs() {
          return this.attributes.aUV.buffer.data;
        }
        set uvs(value) {
          this.attributes.aUV.buffer.data = value;
        }
        get indices() {
          return this.indexBuffer.data;
        }
        set indices(value) {
          this.indexBuffer.data = value;
        }
      };
      _MeshGeometry.defaultOptions = {
        topology: "triangle-list",
        shrinkBuffersToFit: false
      };
      MeshGeometry2 = _MeshGeometry;
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
  var localUniformBit, localUniformBitGroup2, localUniformBitGl;
  var init_localUniformBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
      "use strict";
      localUniformBit = {
        name: "local-uniform-bit",
        vertex: {
          header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
          main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
          end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
      };
      localUniformBitGroup2 = {
        ...localUniformBit,
        vertex: {
          ...localUniformBit.vertex,
          header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
        }
      };
      localUniformBitGl = {
        name: "local-uniform-bit",
        vertex: {
          header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
          main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
          end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/shader/tilingBit.mjs
  var tilingBit, tilingBitGl;
  var init_tilingBit = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
      "use strict";
      tilingBit = {
        name: "tiling-bit",
        vertex: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        },
        fragment: {
          header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
          main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        }
      };
      tilingBitGl = {
        name: "tiling-bit",
        vertex: {
          header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,
          main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        },
        fragment: {
          header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
          main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
  var gpuProgram2, glProgram2, TilingSpriteShader;
  var init_TilingSpriteShader = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
      init_Matrix2();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader2();
      init_UniformGroup2();
      init_Texture2();
      init_tilingBit();
      TilingSpriteShader = class extends Shader2 {
        constructor() {
          gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBit,
              tilingBit,
              roundPixelsBit
            ]
          }));
          glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
            name: "tiling-sprite-shader",
            bits: [
              localUniformBitGl,
              tilingBitGl,
              roundPixelsBitGl
            ]
          }));
          const tilingUniforms = new UniformGroup2({
            uMapCoord: { value: new Matrix2(), type: "mat3x3<f32>" },
            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
            uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
            uTextureTransform: { value: new Matrix2(), type: "mat3x3<f32>" },
            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
          });
          super({
            glProgram: glProgram2,
            gpuProgram: gpuProgram2,
            resources: {
              localUniforms: new UniformGroup2({
                uTransformMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
                uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
                uRound: { value: 0, type: "f32" }
              }),
              tilingUniforms,
              uTexture: Texture2.EMPTY.source,
              uSampler: Texture2.EMPTY.source.style
            }
          });
        }
        updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
          const tilingUniforms = this.resources.tilingUniforms;
          const textureWidth = texture.width;
          const textureHeight = texture.height;
          const textureMatrix = texture.textureMatrix;
          const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
          uTextureTransform.set(
            matrix.a * textureWidth / width,
            matrix.b * textureWidth / height,
            matrix.c * textureHeight / width,
            matrix.d * textureHeight / height,
            matrix.tx / width,
            matrix.ty / height
          );
          uTextureTransform.invert();
          tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
          tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
          tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
          tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
          tilingUniforms.uniforms.uSizeAnchor[0] = width;
          tilingUniforms.uniforms.uSizeAnchor[1] = height;
          tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
          tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
          if (texture) {
            this.resources.uTexture = texture.source;
            this.resources.uSampler = texture.source.style;
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
  var QuadGeometry;
  var init_QuadGeometry = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
      init_MeshGeometry2();
      QuadGeometry = class extends MeshGeometry2 {
        constructor() {
          super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/utils/setPositions.mjs
  function setPositions(tilingSprite, positions) {
    const anchorX = tilingSprite.anchor.x;
    const anchorY = tilingSprite.anchor.y;
    positions[0] = -anchorX * tilingSprite.width;
    positions[1] = -anchorY * tilingSprite.height;
    positions[2] = (1 - anchorX) * tilingSprite.width;
    positions[3] = -anchorY * tilingSprite.height;
    positions[4] = (1 - anchorX) * tilingSprite.width;
    positions[5] = (1 - anchorY) * tilingSprite.height;
    positions[6] = -anchorX * tilingSprite.width;
    positions[7] = (1 - anchorY) * tilingSprite.height;
  }
  var init_setPositions = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/utils/applyMatrix.mjs
  function applyMatrix(array, stride, offset, matrix) {
    let index = 0;
    const size = array.length / (stride || 2);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    offset *= stride;
    while (index < size) {
      const x2 = array[offset];
      const y2 = array[offset + 1];
      array[offset] = a2 * x2 + c2 * y2 + tx;
      array[offset + 1] = b2 * x2 + d2 * y2 + ty;
      offset += stride;
      index++;
    }
  }
  var init_applyMatrix = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/utils/setUvs.mjs
  function setUvs(tilingSprite, uvs) {
    const texture = tilingSprite.texture;
    const width = texture.frame.width;
    const height = texture.frame.height;
    let anchorX = 0;
    let anchorY = 0;
    if (tilingSprite._applyAnchorToTexture) {
      anchorX = tilingSprite.anchor.x;
      anchorY = tilingSprite.anchor.y;
    }
    uvs[0] = uvs[6] = -anchorX;
    uvs[2] = uvs[4] = 1 - anchorX;
    uvs[1] = uvs[3] = -anchorY;
    uvs[5] = uvs[7] = 1 - anchorY;
    const textureMatrix = Matrix2.shared;
    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
    textureMatrix.tx /= tilingSprite.width;
    textureMatrix.ty /= tilingSprite.height;
    textureMatrix.invert();
    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
    applyMatrix(uvs, 2, 0, textureMatrix);
  }
  var init_setUvs = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
      init_Matrix2();
      init_applyMatrix();
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/TilingSpritePipe.mjs
  var sharedQuad, TilingSpritePipe;
  var init_TilingSpritePipe = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
      init_Extensions();
      init_getAdjustedBlendModeBlend();
      init_State2();
      init_types2();
      init_colorToUniform();
      init_BatchableMesh();
      init_MeshGeometry2();
      init_TilingSpriteShader();
      init_QuadGeometry();
      init_setPositions();
      init_setUvs();
      sharedQuad = new QuadGeometry();
      TilingSpritePipe = class {
        constructor(renderer) {
          this._state = State2.default2d;
          this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
        }
        validateRenderable(renderable) {
          const tilingSpriteData = this._getTilingSpriteData(renderable);
          const couldBatch = tilingSpriteData.canBatch;
          this._updateCanBatch(renderable);
          const canBatch = tilingSpriteData.canBatch;
          if (canBatch && canBatch === couldBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source) {
              return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
            }
          }
          return couldBatch !== canBatch;
        }
        addRenderable(tilingSprite, instructionSet) {
          const batcher = this._renderer.renderPipes.batch;
          this._updateCanBatch(tilingSprite);
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { geometry, canBatch } = tilingSpriteData;
          if (canBatch) {
            tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
            const batchableMesh = tilingSpriteData.batchableMesh;
            if (tilingSprite._didTilingSpriteUpdate) {
              tilingSprite._didTilingSpriteUpdate = false;
              this._updateBatchableMesh(tilingSprite);
              batchableMesh.geometry = geometry;
              batchableMesh.renderable = tilingSprite;
              batchableMesh.transform = tilingSprite.groupTransform;
              batchableMesh.texture = tilingSprite._texture;
            }
            batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
            batcher.addToBatch(batchableMesh, instructionSet);
          } else {
            batcher.break(instructionSet);
            tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
            this.updateRenderable(tilingSprite);
            instructionSet.add(tilingSprite);
          }
        }
        execute(tilingSprite) {
          const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
          shader.groups[0] = this._renderer.globalUniforms.bindGroup;
          const localUniforms = shader.resources.localUniforms.uniforms;
          localUniforms.uTransformMatrix = tilingSprite.groupTransform;
          localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
          color32BitToUniform(
            tilingSprite.groupColorAlpha,
            localUniforms.uColor,
            0
          );
          this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
          this._renderer.encoder.draw({
            geometry: sharedQuad,
            shader,
            state: this._state
          });
        }
        updateRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          const { canBatch } = tilingSpriteData;
          if (canBatch) {
            const { batchableMesh } = tilingSpriteData;
            if (tilingSprite._didTilingSpriteUpdate)
              this._updateBatchableMesh(tilingSprite);
            batchableMesh._batcher.updateElement(batchableMesh);
          } else if (tilingSprite._didTilingSpriteUpdate) {
            const { shader } = tilingSpriteData;
            shader.updateUniforms(
              tilingSprite.width,
              tilingSprite.height,
              tilingSprite._tileTransform.matrix,
              tilingSprite.anchor.x,
              tilingSprite.anchor.y,
              tilingSprite.texture
            );
          }
          tilingSprite._didTilingSpriteUpdate = false;
        }
        destroyRenderable(tilingSprite) {
          const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
          tilingSpriteData.batchableMesh = null;
          tilingSpriteData.shader?.destroy();
          this._tilingSpriteDataHash[tilingSprite.uid] = null;
          tilingSprite.off("destroyed", this._destroyRenderableBound);
        }
        _getTilingSpriteData(renderable) {
          return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
        }
        _initTilingSpriteData(tilingSprite) {
          const geometry = new MeshGeometry2({
            indices: sharedQuad.indices,
            positions: sharedQuad.positions.slice(),
            uvs: sharedQuad.uvs.slice()
          });
          this._tilingSpriteDataHash[tilingSprite.uid] = {
            canBatch: true,
            renderable: tilingSprite,
            geometry
          };
          tilingSprite.on("destroyed", this._destroyRenderableBound);
          return this._tilingSpriteDataHash[tilingSprite.uid];
        }
        _updateBatchableMesh(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const { geometry } = renderableData;
          const style = tilingSprite.texture.source.style;
          if (style.addressMode !== "repeat") {
            style.addressMode = "repeat";
            style.update();
          }
          setUvs(tilingSprite, geometry.uvs);
          setPositions(tilingSprite, geometry.positions);
        }
        destroy() {
          for (const i2 in this._tilingSpriteDataHash) {
            this.destroyRenderable(this._tilingSpriteDataHash[i2].renderable);
          }
          this._tilingSpriteDataHash = null;
          this._renderer = null;
        }
        _updateCanBatch(tilingSprite) {
          const renderableData = this._getTilingSpriteData(tilingSprite);
          const texture = tilingSprite.texture;
          let _nonPowOf2wrapping = true;
          if (this._renderer.type === RendererType.WEBGL) {
            _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
          }
          renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
          return renderableData.canBatch;
        }
      };
      TilingSpritePipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "tilingSprite"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-tiling/init.mjs
  var init_init11 = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-tiling/init.mjs"() {
      init_Extensions();
      init_TilingSpritePipe();
      extensions3.add(TilingSpritePipe);
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh-plane/PlaneGeometry.mjs
  var _PlaneGeometry, PlaneGeometry2;
  var init_PlaneGeometry2 = __esm({
    "node_modules/pixi-v8/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
      init_deprecation2();
      init_MeshGeometry2();
      _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry2 {
        constructor(...args) {
          super({});
          let options = args[0] ?? {};
          if (typeof options === "number") {
            deprecation2(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
            options = {
              width: options,
              height: args[1],
              verticesX: args[2],
              verticesY: args[3]
            };
          }
          this.build(options);
        }
        build(options) {
          options = { ..._PlaneGeometry2.defaultOptions, ...options };
          this.verticesX = this.verticesX ?? options.verticesX;
          this.verticesY = this.verticesY ?? options.verticesY;
          this.width = this.width ?? options.width;
          this.height = this.height ?? options.height;
          const total = this.verticesX * this.verticesY;
          const verts = [];
          const uvs = [];
          const indices2 = [];
          const verticesX = this.verticesX - 1;
          const verticesY = this.verticesY - 1;
          const sizeX = this.width / verticesX;
          const sizeY = this.height / verticesY;
          for (let i2 = 0; i2 < total; i2++) {
            const x2 = i2 % this.verticesX;
            const y2 = i2 / this.verticesX | 0;
            verts.push(x2 * sizeX, y2 * sizeY);
            uvs.push(x2 / verticesX, y2 / verticesY);
          }
          const totalSub = verticesX * verticesY;
          for (let i2 = 0; i2 < totalSub; i2++) {
            const xpos = i2 % verticesX;
            const ypos = i2 / verticesX | 0;
            const value = ypos * this.verticesX + xpos;
            const value2 = ypos * this.verticesX + xpos + 1;
            const value3 = (ypos + 1) * this.verticesX + xpos;
            const value4 = (ypos + 1) * this.verticesX + xpos + 1;
            indices2.push(
              value,
              value2,
              value3,
              value2,
              value4,
              value3
            );
          }
          this.buffers[0].data = new Float32Array(verts);
          this.buffers[1].data = new Float32Array(uvs);
          this.indexBuffer.data = new Uint32Array(indices2);
          this.buffers[0].update();
          this.buffers[1].update();
          this.indexBuffer.update();
        }
      };
      _PlaneGeometry.defaultOptions = {
        width: 100,
        height: 100,
        verticesX: 10,
        verticesY: 10
      };
      PlaneGeometry2 = _PlaneGeometry;
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
  var _NineSliceGeometry, NineSliceGeometry;
  var init_NineSliceGeometry = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
      init_PlaneGeometry2();
      _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry2 {
        constructor(options = {}) {
          options = { ..._NineSliceGeometry2.defaultOptions, ...options };
          super({
            width: options.width,
            height: options.height,
            verticesX: 4,
            verticesY: 4
          });
          this.update(options);
        }
        update(options) {
          this.width = options.width ?? this.width;
          this.height = options.height ?? this.height;
          this._originalWidth = options.originalWidth ?? this._originalWidth;
          this._originalHeight = options.originalHeight ?? this._originalHeight;
          this._leftWidth = options.leftWidth ?? this._leftWidth;
          this._rightWidth = options.rightWidth ?? this._rightWidth;
          this._topHeight = options.topHeight ?? this._topHeight;
          this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
          this.updateUvs();
          this.updatePositions();
        }
        updatePositions() {
          const positions = this.positions;
          const w2 = this._leftWidth + this._rightWidth;
          const scaleW = this.width > w2 ? 1 : this.width / w2;
          const h2 = this._topHeight + this._bottomHeight;
          const scaleH = this.height > h2 ? 1 : this.height / h2;
          const scale = Math.min(scaleW, scaleH);
          positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;
          positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;
          positions[25] = positions[27] = positions[29] = positions[31] = this.height;
          positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;
          positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;
          positions[6] = positions[14] = positions[22] = positions[30] = this.width;
          this.getBuffer("aPosition").update();
        }
        updateUvs() {
          const uvs = this.uvs;
          uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
          uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
          uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
          uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
          const _uvw = 1 / this._originalWidth;
          const _uvh = 1 / this._originalHeight;
          uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
          uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
          uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
          uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
          this.getBuffer("aUV").update();
        }
      };
      _NineSliceGeometry.defaultOptions = {
        width: 100,
        height: 100,
        leftWidth: 10,
        topHeight: 10,
        rightWidth: 10,
        bottomHeight: 10,
        originalWidth: 100,
        originalHeight: 100
      };
      NineSliceGeometry = _NineSliceGeometry;
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
  var NineSliceSpritePipe;
  var init_NineSliceSpritePipe = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableMesh();
      init_NineSliceGeometry();
      NineSliceSpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableMesh = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableMesh.geometry);
          BigPool.return(batchableMesh);
          this._gpuSpriteHash[sprite.uid] = null;
          sprite.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          sprite._didSpriteUpdate = false;
          batchableSprite.geometry.update(sprite);
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableMesh = BigPool.get(BatchableMesh);
          batchableMesh.geometry = BigPool.get(NineSliceGeometry);
          batchableMesh.renderable = sprite;
          batchableMesh.transform = sprite.groupTransform;
          batchableMesh.texture = sprite._texture;
          batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          sprite._didSpriteUpdate = true;
          this._gpuSpriteHash[sprite.uid] = batchableMesh;
          sprite.on("destroyed", this._destroyRenderableBound);
          return batchableMesh;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            const batchableMesh = this._gpuSpriteHash[i2];
            batchableMesh.geometry.destroy();
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      NineSliceSpritePipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "nineSliceSprite"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite-nine-slice/init.mjs
  var init_init12 = __esm({
    "node_modules/pixi-v8/lib/scene/sprite-nine-slice/init.mjs"() {
      init_Extensions();
      init_NineSliceSpritePipe();
      extensions3.add(NineSliceSpritePipe);
    }
  });

  // node_modules/pixi-v8/lib/filters/FilterPipe.mjs
  var FilterPipe;
  var init_FilterPipe = __esm({
    "node_modules/pixi-v8/lib/filters/FilterPipe.mjs"() {
      init_Extensions();
      FilterPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        push(filterEffect, container, instructionSet) {
          const renderPipes3 = this._renderer.renderPipes;
          renderPipes3.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            canBundle: false,
            action: "pushFilter",
            container,
            filterEffect
          });
        }
        pop(_filterEffect, _container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        execute(instruction) {
          if (instruction.action === "pushFilter") {
            this._renderer.filter.push(instruction);
          } else if (instruction.action === "popFilter") {
            this._renderer.filter.pop();
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      FilterPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getFastGlobalBounds.mjs
  function getFastGlobalBounds(target, bounds) {
    bounds.clear();
    _getGlobalBoundsRecursive(target, bounds);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    if (!target.renderGroup) {
      bounds.applyMatrix(target.parentRenderGroup.worldTransform);
    } else {
      bounds.applyMatrix(target.renderGroup.localTransform);
    }
    return bounds;
  }
  function _getGlobalBoundsRecursive(target, bounds) {
    if (target.localDisplayStatus !== 7 || !target.measurable) {
      return;
    }
    const manageEffects = !!target.effects.length;
    let localBounds = bounds;
    if (target.renderGroup || manageEffects) {
      localBounds = boundsPool.get().clear();
    }
    if (target.boundsArea) {
      bounds.addRect(target.boundsArea, target.worldTransform);
    } else {
      if (target.renderPipeId) {
        const viewBounds = target.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          target.groupTransform
        );
      }
      const children = target.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        _getGlobalBoundsRecursive(children[i2], localBounds);
      }
    }
    if (manageEffects) {
      let advanced = false;
      for (let i2 = 0; i2 < target.effects.length; i2++) {
        if (target.effects[i2].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(target.parentRenderGroup.worldTransform);
          }
          target.effects[i2].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix7).invert());
        bounds.addBounds(localBounds, target.relativeGroupTransform);
      }
      bounds.addBounds(localBounds);
      boundsPool.return(localBounds);
    } else if (target.renderGroup) {
      bounds.addBounds(localBounds, target.relativeGroupTransform);
      boundsPool.return(localBounds);
    }
  }
  var tempMatrix7;
  var init_getFastGlobalBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getFastGlobalBounds.mjs"() {
      init_Matrix2();
      init_matrixAndBoundsPool();
      tempMatrix7 = new Matrix2();
    }
  });

  // node_modules/pixi-v8/lib/scene/container/bounds/getRenderableBounds.mjs
  function getGlobalRenderableBounds(renderables, bounds) {
    bounds.clear();
    const tempMatrix9 = bounds.matrix;
    for (let i2 = 0; i2 < renderables.length; i2++) {
      const renderable = renderables[i2];
      if (renderable.globalDisplayStatus < 7) {
        continue;
      }
      bounds.matrix = renderable.worldTransform;
      renderable.addBounds(bounds);
    }
    bounds.matrix = tempMatrix9;
    return bounds;
  }
  var init_getRenderableBounds = __esm({
    "node_modules/pixi-v8/lib/scene/container/bounds/getRenderableBounds.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/filters/FilterSystem.mjs
  var quadGeometry, FilterSystem2;
  var init_FilterSystem2 = __esm({
    "node_modules/pixi-v8/lib/filters/FilterSystem.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_Point2();
      init_BindGroup();
      init_Geometry2();
      init_UniformGroup2();
      init_Texture2();
      init_TexturePool();
      init_types2();
      init_Bounds2();
      init_getFastGlobalBounds();
      init_getRenderableBounds();
      init_warn();
      quadGeometry = new Geometry2({
        attributes: {
          aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
          }
        },
        indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
      });
      FilterSystem2 = class {
        constructor(renderer) {
          this._filterStackIndex = 0;
          this._filterStack = [];
          this._filterGlobalUniforms = new UniformGroup2({
            uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
            uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
            uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
          });
          this._globalFilterBindGroup = new BindGroup({});
          this.renderer = renderer;
        }
        get activeBackTexture() {
          return this._activeFilterData?.backTexture;
        }
        push(instruction) {
          const renderer = this.renderer;
          const filters2 = instruction.filterEffect.filters;
          if (!this._filterStack[this._filterStackIndex]) {
            this._filterStack[this._filterStackIndex] = this._getFilterData();
          }
          const filterData = this._filterStack[this._filterStackIndex];
          this._filterStackIndex++;
          if (filters2.length === 0) {
            filterData.skip = true;
            return;
          }
          const bounds = filterData.bounds;
          if (instruction.renderables) {
            getGlobalRenderableBounds(instruction.renderables, bounds);
          } else if (instruction.filterEffect.filterArea) {
            bounds.clear();
            bounds.addRect(instruction.filterEffect.filterArea);
            bounds.applyMatrix(instruction.container.worldTransform);
          } else {
            getFastGlobalBounds(instruction.container, bounds);
          }
          const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
          let resolution = Infinity;
          let padding = 0;
          let antialias = true;
          let blendRequired = false;
          let enabled = false;
          for (let i2 = 0; i2 < filters2.length; i2++) {
            const filter = filters2[i2];
            resolution = Math.min(resolution, filter.resolution === "inherit" ? colorTextureSource._resolution : filter.resolution);
            padding += filter.padding;
            if (filter.antialias === "off") {
              antialias = false;
            } else if (filter.antialias === "inherit") {
              antialias && (antialias = colorTextureSource.antialias);
            }
            const isCompatible = !!(filter.compatibleRenderers & renderer.type);
            if (!isCompatible) {
              enabled = false;
              break;
            }
            if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
              warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
              enabled = false;
              break;
            }
            enabled = filter.enabled || enabled;
            blendRequired = blendRequired || filter.blendRequired;
          }
          if (!enabled) {
            filterData.skip = true;
            return;
          }
          const viewPort = renderer.renderTarget.rootViewPort;
          bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).ceil().scale(1 / resolution).pad(padding | 0);
          if (!bounds.isPositive) {
            filterData.skip = true;
            return;
          }
          filterData.skip = false;
          filterData.bounds = bounds;
          filterData.blendRequired = blendRequired;
          filterData.container = instruction.container;
          filterData.filterEffect = instruction.filterEffect;
          filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
          filterData.inputTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            resolution,
            antialias
          );
          renderer.renderTarget.bind(filterData.inputTexture, true);
          renderer.globalUniforms.push({
            offset: bounds
          });
        }
        pop() {
          const renderer = this.renderer;
          this._filterStackIndex--;
          const filterData = this._filterStack[this._filterStackIndex];
          if (filterData.skip) {
            return;
          }
          this._activeFilterData = filterData;
          const inputTexture = filterData.inputTexture;
          const bounds = filterData.bounds;
          let backTexture = Texture2.EMPTY;
          renderer.renderTarget.finishRenderPass();
          if (filterData.blendRequired) {
            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
          }
          filterData.backTexture = backTexture;
          const filters2 = filterData.filterEffect.filters;
          this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
          this._globalFilterBindGroup.setResource(backTexture.source, 3);
          renderer.globalUniforms.pop();
          if (filters2.length === 1) {
            filters2[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(inputTexture);
          } else {
            let flip = filterData.inputTexture;
            let flop = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              flip.source._resolution,
              false
            );
            let i2 = 0;
            for (i2 = 0; i2 < filters2.length - 1; ++i2) {
              const filter = filters2[i2];
              filter.apply(this, flip, flop, true);
              const t2 = flip;
              flip = flop;
              flop = t2;
            }
            filters2[i2].apply(this, flip, filterData.previousRenderSurface, false);
            TexturePool.returnTexture(flip);
            TexturePool.returnTexture(flop);
          }
          if (filterData.blendRequired) {
            TexturePool.returnTexture(backTexture);
          }
        }
        getBackTexture(lastRenderSurface, bounds, previousBounds) {
          const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
          const backTexture = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            backgroundResolution,
            false
          );
          let x2 = bounds.minX;
          let y2 = bounds.minY;
          if (previousBounds) {
            x2 -= previousBounds.minX;
            y2 -= previousBounds.minY;
          }
          x2 = Math.floor(x2 * backgroundResolution);
          y2 = Math.floor(y2 * backgroundResolution);
          const width = Math.ceil(bounds.width * backgroundResolution);
          const height = Math.ceil(bounds.height * backgroundResolution);
          this.renderer.renderTarget.copyToTexture(
            lastRenderSurface,
            backTexture,
            { x: x2, y: y2 },
            { width, height },
            { x: 0, y: 0 }
          );
          return backTexture;
        }
        applyFilter(filter, input, output, clear) {
          const renderer = this.renderer;
          const filterData = this._filterStack[this._filterStackIndex];
          const bounds = filterData.bounds;
          const offset = Point2.shared;
          const previousRenderSurface = filterData.previousRenderSurface;
          const isFinalTarget = previousRenderSurface === output;
          let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
          let currentIndex = this._filterStackIndex - 1;
          while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
            --currentIndex;
          }
          if (currentIndex > 0) {
            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
          }
          const filterUniforms = this._filterGlobalUniforms;
          const uniforms = filterUniforms.uniforms;
          const outputFrame = uniforms.uOutputFrame;
          const inputSize = uniforms.uInputSize;
          const inputPixel = uniforms.uInputPixel;
          const inputClamp = uniforms.uInputClamp;
          const globalFrame = uniforms.uGlobalFrame;
          const outputTexture = uniforms.uOutputTexture;
          if (isFinalTarget) {
            let lastIndex = this._filterStackIndex;
            while (lastIndex > 0) {
              lastIndex--;
              const filterData2 = this._filterStack[this._filterStackIndex - 1];
              if (!filterData2.skip) {
                offset.x = filterData2.bounds.minX;
                offset.y = filterData2.bounds.minY;
                break;
              }
            }
            outputFrame[0] = bounds.minX - offset.x;
            outputFrame[1] = bounds.minY - offset.y;
          } else {
            outputFrame[0] = 0;
            outputFrame[1] = 0;
          }
          outputFrame[2] = input.frame.width;
          outputFrame[3] = input.frame.height;
          inputSize[0] = input.source.width;
          inputSize[1] = input.source.height;
          inputSize[2] = 1 / inputSize[0];
          inputSize[3] = 1 / inputSize[1];
          inputPixel[0] = input.source.pixelWidth;
          inputPixel[1] = input.source.pixelHeight;
          inputPixel[2] = 1 / inputPixel[0];
          inputPixel[3] = 1 / inputPixel[1];
          inputClamp[0] = 0.5 * inputPixel[2];
          inputClamp[1] = 0.5 * inputPixel[3];
          inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
          inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
          const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
          globalFrame[0] = offset.x * resolution;
          globalFrame[1] = offset.y * resolution;
          globalFrame[2] = rootTexture.source.width * resolution;
          globalFrame[3] = rootTexture.source.height * resolution;
          const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
          renderer.renderTarget.bind(output, !!clear);
          if (output instanceof Texture2) {
            outputTexture[0] = output.frame.width;
            outputTexture[1] = output.frame.height;
          } else {
            outputTexture[0] = renderTarget.width;
            outputTexture[1] = renderTarget.height;
          }
          outputTexture[2] = renderTarget.isRoot ? -1 : 1;
          filterUniforms.update();
          if (renderer.renderPipes.uniformBatch) {
            const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
            this._globalFilterBindGroup.setResource(batchUniforms, 0);
          } else {
            this._globalFilterBindGroup.setResource(filterUniforms, 0);
          }
          this._globalFilterBindGroup.setResource(input.source, 1);
          this._globalFilterBindGroup.setResource(input.source.style, 2);
          filter.groups[0] = this._globalFilterBindGroup;
          renderer.encoder.draw({
            geometry: quadGeometry,
            shader: filter,
            state: filter._state,
            topology: "triangle-list"
          });
          if (renderer.type === RendererType.WEBGL) {
            renderer.renderTarget.finishRenderPass();
          }
        }
        _getFilterData() {
          return {
            skip: false,
            inputTexture: null,
            bounds: new Bounds2(),
            container: null,
            filterEffect: null,
            blendRequired: false,
            previousRenderSurface: null
          };
        }
        calculateSpriteMatrix(outputMatrix, sprite) {
          const data = this._activeFilterData;
          const mappedMatrix = outputMatrix.set(
            data.inputTexture._source.width,
            0,
            0,
            data.inputTexture._source.height,
            data.bounds.minX,
            data.bounds.minY
          );
          const worldTransform = sprite.worldTransform.copyTo(Matrix2.shared);
          worldTransform.invert();
          mappedMatrix.prepend(worldTransform);
          mappedMatrix.scale(
            1 / sprite.texture.frame.width,
            1 / sprite.texture.frame.height
          );
          mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
          return mappedMatrix;
        }
      };
      FilterSystem2.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "filter"
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/init.mjs
  var init_init13 = __esm({
    "node_modules/pixi-v8/lib/filters/init.mjs"() {
      init_Extensions();
      init_FilterPipe();
      init_FilterSystem2();
      extensions3.add(FilterSystem2);
      extensions3.add(FilterPipe);
    }
  });

  // node_modules/pixi-v8/lib/environment-browser/browserAll.mjs
  var browserAll_exports = {};
  var init_browserAll = __esm({
    "node_modules/pixi-v8/lib/environment-browser/browserAll.mjs"() {
      init_init();
      init_init2();
      init_init3();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
    }
  });

  // node_modules/pixi-v8/lib/environment-browser/browserExt.mjs
  var browserExt;
  var init_browserExt = __esm({
    "node_modules/pixi-v8/lib/environment-browser/browserExt.mjs"() {
      init_Extensions();
      browserExt = {
        extension: {
          type: ExtensionType2.Environment,
          name: "browser",
          priority: -1
        },
        test: () => true,
        load: async () => {
          await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/environment-webworker/webworkerAll.mjs
  var webworkerAll_exports = {};
  var init_webworkerAll = __esm({
    "node_modules/pixi-v8/lib/environment-webworker/webworkerAll.mjs"() {
      init_init2();
      init_init4();
      init_init5();
      init_init6();
      init_init7();
      init_init8();
      init_init9();
      init_init10();
      init_init11();
      init_init12();
      init_init13();
    }
  });

  // node_modules/pixi-v8/lib/environment-webworker/webworkerExt.mjs
  var webworkerExt;
  var init_webworkerExt = __esm({
    "node_modules/pixi-v8/lib/environment-webworker/webworkerExt.mjs"() {
      init_Extensions();
      webworkerExt = {
        extension: {
          type: ExtensionType2.Environment,
          name: "webworker",
          priority: 0
        },
        test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
        load: async () => {
          await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/filters/Filter.mjs
  var _Filter3, Filter2;
  var init_Filter2 = __esm({
    "node_modules/pixi-v8/lib/filters/Filter.mjs"() {
      init_GlProgram();
      init_GpuProgram();
      init_Shader2();
      init_State2();
      _Filter3 = class _Filter4 extends Shader2 {
        constructor(options) {
          options = { ..._Filter4.defaultOptions, ...options };
          super(options);
          this.enabled = true;
          this._state = State2.for2d();
          this.blendMode = options.blendMode;
          this.padding = options.padding;
          if (typeof options.antialias === "boolean") {
            this.antialias = options.antialias ? "on" : "off";
          } else {
            this.antialias = options.antialias;
          }
          this.resolution = options.resolution;
          this.blendRequired = options.blendRequired;
          this.addResource("uTexture", 0, 1);
        }
        apply(filterManager, input, output, clearMode) {
          filterManager.applyFilter(this, input, output, clearMode);
        }
        get blendMode() {
          return this._state.blendMode;
        }
        set blendMode(value) {
          this._state.blendMode = value;
        }
        static from(options) {
          const { gpu, gl, ...rest } = options;
          let gpuProgram3;
          let glProgram3;
          if (gpu) {
            gpuProgram3 = GpuProgram.from(gpu);
          }
          if (gl) {
            glProgram3 = GlProgram.from(gl);
          }
          return new _Filter4({
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            ...rest
          });
        }
      };
      _Filter3.defaultOptions = {
        blendMode: "normal",
        resolution: 1,
        padding: 0,
        antialias: "off",
        blendRequired: false
      };
      Filter2 = _Filter3;
    }
  });

  // node_modules/pixi-v8/lib/environment/autoDetectEnvironment.mjs
  async function loadEnvironmentExtensions(skip) {
    if (skip)
      return;
    for (let i2 = 0; i2 < environments.length; i2++) {
      const env = environments[i2];
      if (env.value.test()) {
        await env.value.load();
        return;
      }
    }
  }
  var environments;
  var init_autoDetectEnvironment = __esm({
    "node_modules/pixi-v8/lib/environment/autoDetectEnvironment.mjs"() {
      init_Extensions();
      environments = [];
      extensions3.handleByNamedList(ExtensionType2.Environment, environments);
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/unsafeEvalSupported.mjs
  function unsafeEvalSupported2() {
    if (typeof unsafeEval2 === "boolean") {
      return unsafeEval2;
    }
    try {
      const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
      unsafeEval2 = func({ a: "b" }, "a", "b") === true;
    } catch (e2) {
      unsafeEval2 = false;
    }
    return unsafeEval2;
  }
  var unsafeEval2;
  var init_unsafeEvalSupported2 = __esm({
    "node_modules/pixi-v8/lib/utils/browser/unsafeEvalSupported.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/const.mjs
  var CLEAR;
  var init_const13 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/const.mjs"() {
      "use strict";
      CLEAR = /* @__PURE__ */ ((CLEAR2) => {
        CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
        CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
        CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
        CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
        CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
        CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
        CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
        CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
        return CLEAR2;
      })(CLEAR || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/system/SystemRunner.mjs
  var SystemRunner;
  var init_SystemRunner = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
      "use strict";
      SystemRunner = class {
        constructor(name) {
          this.items = [];
          this._name = name;
        }
        emit(a0, a1, a2, a3, a4, a5, a6, a7) {
          const { name, items } = this;
          for (let i2 = 0, len = items.length; i2 < len; i2++) {
            items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
          }
          return this;
        }
        add(item) {
          if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
          }
          return this;
        }
        remove(item) {
          const index = this.items.indexOf(item);
          if (index !== -1) {
            this.items.splice(index, 1);
          }
          return this;
        }
        contains(item) {
          return this.items.indexOf(item) !== -1;
        }
        removeAll() {
          this.items.length = 0;
          return this;
        }
        destroy() {
          this.removeAll();
          this.items = null;
          this._name = null;
        }
        get empty() {
          return this.items.length === 0;
        }
        get name() {
          return this._name;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
  var defaultRunners, _AbstractRenderer, AbstractRenderer;
  var init_AbstractRenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
      init_Color2();
      init_autoDetectEnvironment();
      init_Container2();
      init_unsafeEvalSupported2();
      init_deprecation2();
      init_const13();
      init_SystemRunner();
      init_eventemitter3();
      defaultRunners = [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "renderEnd",
        "renderStart",
        "render",
        "update",
        "postrender",
        "prerender"
      ];
      _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
        constructor(config) {
          super();
          this.runners = /* @__PURE__ */ Object.create(null);
          this.renderPipes = /* @__PURE__ */ Object.create(null);
          this._initOptions = {};
          this._systemsHash = /* @__PURE__ */ Object.create(null);
          this.type = config.type;
          this.name = config.name;
          this.config = config;
          const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
          this._addRunners(...combinedRunners);
          this._unsafeEvalCheck();
        }
        async init(options = {}) {
          const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
          await loadEnvironmentExtensions(skip);
          this._addSystems(this.config.systems);
          this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
          for (const systemName in this._systemsHash) {
            const system = this._systemsHash[systemName];
            const defaultSystemOptions = system.constructor.defaultOptions;
            options = { ...defaultSystemOptions, ...options };
          }
          options = { ..._AbstractRenderer2.defaultOptions, ...options };
          this._roundPixels = options.roundPixels ? 1 : 0;
          for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
            await this.runners.init.items[i2].init(options);
          }
          this._initOptions = options;
        }
        render(args, deprecated) {
          let options = args;
          if (options instanceof Container2) {
            options = { container: options };
            if (deprecated) {
              deprecation2(v8_0_0, "passing a second argument is deprecated, please use render options instead");
              options.target = deprecated.renderTexture;
            }
          }
          options.target || (options.target = this.view.renderTarget);
          if (options.target === this.view.renderTarget) {
            this._lastObjectRendered = options.container;
            options.clearColor = this.background.colorRgba;
          }
          if (options.clearColor) {
            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
            options.clearColor = isRGBAArray ? options.clearColor : Color2.shared.setValue(options.clearColor).toArray();
          }
          if (!options.transform) {
            options.container.updateLocalTransform();
            options.transform = options.container.localTransform;
          }
          this.runners.prerender.emit(options);
          this.runners.renderStart.emit(options);
          this.runners.render.emit(options);
          this.runners.renderEnd.emit(options);
          this.runners.postrender.emit(options);
        }
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          const previousResolution = this.view.resolution;
          this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
          if (resolution !== void 0 && resolution !== previousResolution) {
            this.runners.resolutionChange.emit(resolution);
          }
        }
        clear(options = {}) {
          const renderer = this;
          options.target || (options.target = renderer.renderTarget.renderTarget);
          options.clearColor || (options.clearColor = this.background.colorRgba);
          options.clear ?? (options.clear = CLEAR.ALL);
          const { clear, clearColor, target } = options;
          Color2.shared.setValue(clearColor ?? this.background.colorRgba);
          renderer.renderTarget.clear(target, clear, Color2.shared.toArray());
        }
        get resolution() {
          return this.view.resolution;
        }
        set resolution(value) {
          this.view.resolution = value;
          this.runners.resolutionChange.emit(value);
        }
        get width() {
          return this.view.texture.frame.width;
        }
        get height() {
          return this.view.texture.frame.height;
        }
        get canvas() {
          return this.view.canvas;
        }
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        get renderingToScreen() {
          const renderer = this;
          return renderer.renderTarget.renderingToScreen;
        }
        get screen() {
          return this.view.screen;
        }
        _addRunners(...runnerIds) {
          runnerIds.forEach((runnerId) => {
            this.runners[runnerId] = new SystemRunner(runnerId);
          });
        }
        _addSystems(systems3) {
          let i2;
          for (i2 in systems3) {
            const val = systems3[i2];
            this._addSystem(val.value, val.name);
          }
        }
        _addSystem(ClassRef, name) {
          const system = new ClassRef(this);
          if (this[name]) {
            throw new Error(`Whoops! The name "${name}" is already in use`);
          }
          this[name] = system;
          this._systemsHash[name] = system;
          for (const i2 in this.runners) {
            this.runners[i2].add(system);
          }
          return this;
        }
        _addPipes(pipes, pipeAdaptors) {
          const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
            acc[adaptor.name] = adaptor.value;
            return acc;
          }, {});
          pipes.forEach((pipe) => {
            const PipeClass = pipe.value;
            const name = pipe.name;
            const Adaptor = adaptors[name];
            this.renderPipes[name] = new PipeClass(
              this,
              Adaptor ? new Adaptor() : null
            );
          });
        }
        destroy(options = false) {
          this.runners.destroy.items.reverse();
          this.runners.destroy.emit(options);
          Object.values(this.runners).forEach((runner) => {
            runner.destroy();
          });
          this._systemsHash = null;
          this.renderPipes = null;
        }
        generateTexture(options) {
          return this.textureGenerator.generateTexture(options);
        }
        get roundPixels() {
          return !!this._roundPixels;
        }
        _unsafeEvalCheck() {
          if (!unsafeEvalSupported2()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
      };
      _AbstractRenderer.defaultOptions = {
        resolution: 1,
        failIfMajorPerformanceCaveat: false,
        roundPixels: false
      };
      AbstractRenderer = _AbstractRenderer;
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/isWebGLSupported.mjs
  function isWebGLSupported2(failIfMajorPerformanceCaveat) {
    if (_isWebGLSupported !== void 0)
      return _isWebGLSupported;
    _isWebGLSupported = (() => {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!DOMAdapter.get().getWebGLRenderingContext()) {
          return false;
        }
        const canvas = DOMAdapter.get().createCanvas();
        let gl = canvas.getContext("webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGLSupported;
  }
  var _isWebGLSupported;
  var init_isWebGLSupported2 = __esm({
    "node_modules/pixi-v8/lib/utils/browser/isWebGLSupported.mjs"() {
      init_adapter2();
      init_AbstractRenderer();
    }
  });

  // node_modules/pixi-v8/lib/utils/browser/isWebGPUSupported.mjs
  async function isWebGPUSupported(options = {}) {
    if (_isWebGPUSupported !== void 0)
      return _isWebGPUSupported;
    _isWebGPUSupported = await (async () => {
      const gpu = DOMAdapter.get().getNavigator().gpu;
      if (!gpu) {
        return false;
      }
      try {
        const adapter = await gpu.requestAdapter(options);
        await adapter.requestDevice();
        return true;
      } catch (e2) {
        return false;
      }
    })();
    return _isWebGPUSupported;
  }
  var _isWebGPUSupported;
  var init_isWebGPUSupported = __esm({
    "node_modules/pixi-v8/lib/utils/browser/isWebGPUSupported.mjs"() {
      init_adapter2();
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
  var GpuGraphicsAdaptor;
  var init_GpuGraphicsAdaptor = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_maxRecommendedTextures2();
      init_getTextureBatchBindGroup();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_Shader2();
      init_UniformGroup2();
      GpuGraphicsAdaptor = class {
        init() {
          const localUniforms = new UniformGroup2({
            uTransformMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "graphics",
            bits: [
              colorBit,
              generateTextureBatchBit(getMaxTexturesPerBatch()),
              localUniformBitGroup2,
              roundPixelsBit
            ]
          });
          this.shader = new Shader2({
            gpuProgram: gpuProgram3,
            resources: {
              localUniforms
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context3 = renderable.context;
          const shader = context3.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context3);
          const encoder = renderer.encoder;
          encoder.setPipelineFromGeometryProgramAndState(
            batcher.geometry,
            shader.gpuProgram,
            graphicsPipe.state
          );
          encoder.setGeometry(batcher.geometry, shader.gpuProgram);
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
          const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
          encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            shader.groups[1] = batch.bindGroup;
            if (!batch.gpuBindGroup) {
              const textureBatch = batch.textures;
              batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
              batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
                batch.bindGroup,
                shader.gpuProgram,
                1
              );
            }
            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GpuGraphicsAdaptor.extension = {
        type: [
          ExtensionType2.WebGPUPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/textureBit.mjs
  var textureBit, textureBitGl;
  var init_textureBit = __esm({
    "node_modules/pixi-v8/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
      "use strict";
      textureBit = {
        name: "texture-bit",
        vertex: {
          header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
          main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
          header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,
          main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        }
      };
      textureBitGl = {
        name: "texture-bit",
        vertex: {
          header: `
            uniform mat3 uTextureMatrix;
        `,
          main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
          header: `
        uniform sampler2D uTexture;

         
        `,
          main: `
            outColor = texture(uTexture, vUV);
        `
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
  var GpuMeshAdapter;
  var init_GpuMeshAdapter = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader2();
      init_Texture2();
      init_warn();
      GpuMeshAdapter = class {
        init() {
          const gpuProgram3 = compileHighShaderGpuProgram({
            name: "mesh",
            bits: [
              localUniformBit,
              textureBit,
              roundPixelsBit
            ]
          });
          this._shader = new Shader2({
            gpuProgram: gpuProgram3,
            resources: {
              uTexture: Texture2.EMPTY._source,
              uSampler: Texture2.EMPTY._source.style,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix2() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
          } else if (!shader.gpuProgram) {
            warn("Mesh shader has no gpuProgram", mesh.shader);
            return;
          }
          const gpuProgram3 = shader.gpuProgram;
          if (gpuProgram3.autoAssignGlobalUniforms) {
            shader.groups[0] = renderer.globalUniforms.bindGroup;
          }
          if (gpuProgram3.autoAssignLocalUniforms) {
            const localUniforms = meshPipe.localUniforms;
            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
          }
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GpuMeshAdapter.extension = {
        type: [
          ExtensionType2.WebGPUPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
  var tempState, GpuBatchAdaptor;
  var init_GpuBatchAdaptor = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
      init_Extensions();
      init_State2();
      init_getTextureBatchBindGroup();
      tempState = State2.for2d();
      GpuBatchAdaptor = class {
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          const program = shader.gpuProgram;
          this._shader = shader;
          this._geometry = geometry;
          encoder.setGeometry(geometry, program);
          tempState.blendMode = "normal";
          renderer.pipeline.getPipeline(
            geometry,
            program,
            tempState
          );
          const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
          encoder.resetBindGroup(1);
          encoder.setBindGroup(0, globalUniformsBindGroup, program);
        }
        execute(batchPipe, batch) {
          const program = this._shader.gpuProgram;
          const renderer = batchPipe.renderer;
          const encoder = renderer.encoder;
          if (!batch.bindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          }
          tempState.blendMode = batch.blendMode;
          const gpuBindGroup = renderer.bindGroup.getBindGroup(
            batch.bindGroup,
            program,
            1
          );
          const pipeline = renderer.pipeline.getPipeline(
            this._geometry,
            program,
            tempState
          );
          batch.bindGroup._touch(renderer.textureGC.count);
          encoder.setPipeline(pipeline);
          encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      };
      GpuBatchAdaptor.extension = {
        type: [
          ExtensionType2.WebGPUPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/CustomRenderPipe.mjs
  var CustomRenderPipe;
  var init_CustomRenderPipe = __esm({
    "node_modules/pixi-v8/lib/scene/container/CustomRenderPipe.mjs"() {
      init_Extensions();
      CustomRenderPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderable(container, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(container);
        }
        execute(container) {
          if (!container.isRenderable)
            return;
          container.render(this._renderer);
        }
        destroy() {
          this._renderer = null;
        }
      };
      CustomRenderPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "customRender"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/executeInstructions.mjs
  function executeInstructions(renderGroup, renderer) {
    const instructionSet = renderGroup.instructionSet;
    const instructions = instructionSet.instructions;
    for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
      const instruction = instructions[i2];
      renderer[instruction.renderPipeId].execute(instruction);
    }
  }
  var init_executeInstructions = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/executeInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/RenderGroupPipe.mjs
  var RenderGroupPipe;
  var init_RenderGroupPipe = __esm({
    "node_modules/pixi-v8/lib/scene/container/RenderGroupPipe.mjs"() {
      init_Extensions();
      init_executeInstructions();
      RenderGroupPipe = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        addRenderGroup(renderGroup, instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(renderGroup);
        }
        execute(renderGroup) {
          if (!renderGroup.isRenderable)
            return;
          this._renderer.globalUniforms.push({
            worldTransformMatrix: renderGroup.worldTransform,
            worldColor: renderGroup.worldColorAlpha
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.globalUniforms.pop();
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/buildInstructions.mjs
  function buildInstructions(renderGroup, rendererOrPipes) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    const renderPipes3 = renderer.renderPipes;
    renderPipes3.batch.buildStart(instructionSet);
    renderPipes3.blendMode.buildStart();
    renderPipes3.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    collectAllRenderablesAdvanced(root, instructionSet, renderer, true);
    renderPipes3.batch.buildEnd(instructionSet);
    renderPipes3.blendMode.buildEnd(instructionSet);
  }
  function collectAllRenderables(container, instructionSet, rendererOrPipes) {
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    if (container.globalDisplayStatus < 7 || !container.includeInBuild)
      return;
    if (container.sortableChildren) {
      container.sortChildren();
    }
    if (container.isSimple) {
      collectAllRenderablesSimple(container, instructionSet, renderer);
    } else {
      collectAllRenderablesAdvanced(container, instructionSet, renderer, false);
    }
  }
  function collectAllRenderablesSimple(container, instructionSet, renderer) {
    if (container.renderPipeId) {
      const { renderPipes: renderPipes3, renderableGC } = renderer;
      renderPipes3.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);
      container.didViewUpdate = false;
      const rp = renderPipes3;
      rp[container.renderPipeId].addRenderable(container, instructionSet);
      renderableGC.addRenderable(container, instructionSet);
    }
    if (!container.renderGroup) {
      const children = container.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        collectAllRenderables(children[i2], instructionSet, renderer);
      }
    }
  }
  function collectAllRenderablesAdvanced(container, instructionSet, renderer, isRoot) {
    const { renderPipes: renderPipes3, renderableGC } = renderer;
    if (!isRoot && container.renderGroup) {
      renderPipes3.renderGroup.addRenderGroup(container.renderGroup, instructionSet);
    } else {
      for (let i2 = 0; i2 < container.effects.length; i2++) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.push(effect, container, instructionSet);
      }
      const renderPipeId = container.renderPipeId;
      if (renderPipeId) {
        renderPipes3.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);
        container.didViewUpdate = false;
        const pipe = renderPipes3[renderPipeId];
        pipe.addRenderable(container, instructionSet);
        renderableGC.addRenderable(container, instructionSet);
      }
      const children = container.children;
      if (children.length) {
        for (let i2 = 0; i2 < children.length; i2++) {
          collectAllRenderables(children[i2], instructionSet, renderer);
        }
      }
      for (let i2 = container.effects.length - 1; i2 >= 0; i2--) {
        const effect = container.effects[i2];
        const pipe = renderPipes3[effect.pipe];
        pipe.pop(effect, container, instructionSet);
      }
    }
  }
  var init_buildInstructions = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/buildInstructions.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/clearList.mjs
  function clearList(list, index) {
    index || (index = 0);
    for (let j2 = index; j2 < list.length; j2++) {
      if (list[j2]) {
        list[j2] = null;
      } else {
        break;
      }
    }
  }
  var init_clearList = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/clearList.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/collectRenderGroups.mjs
  function collectRenderGroups(renderGroup, out2 = []) {
    out2.push(renderGroup);
    for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
      collectRenderGroups(renderGroup.renderGroupChildren[i2], out2);
    }
    return out2;
  }
  var init_collectRenderGroups = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/collectRenderGroups.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/mixHexColors.mjs
  function mixHexColors(color1, color2, ratio) {
    const r1 = color1 >> 16 & 255;
    const g1 = color1 >> 8 & 255;
    const b1 = color1 & 255;
    const r2 = color2 >> 16 & 255;
    const g2 = color2 >> 8 & 255;
    const b2 = color2 & 255;
    const r3 = r1 + (r2 - r1) * ratio;
    const g3 = g1 + (g2 - g1) * ratio;
    const b3 = b1 + (b2 - b1) * ratio;
    return (r3 << 16) + (g3 << 8) + b3;
  }
  var init_mixHexColors = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/mixHexColors.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/mixColors.mjs
  function mixColors(localBGRColor, parentBGRColor) {
    if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
      return localBGRColor + parentBGRColor - WHITE_BGR;
    }
    return mixHexColors(localBGRColor, parentBGRColor, 0.5);
  }
  var WHITE_BGR;
  var init_mixColors = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/mixColors.mjs"() {
      init_mixHexColors();
      WHITE_BGR = 16777215;
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/updateRenderGroupTransforms.mjs
  function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
    updateRenderGroupTransform(renderGroup);
    const childrenToUpdate = renderGroup.childrenToUpdate;
    const updateTick = renderGroup.updateTick++;
    for (const j2 in childrenToUpdate) {
      const renderGroupDepth = Number(j2);
      const childrenAtDepth = childrenToUpdate[j2];
      const list = childrenAtDepth.list;
      const index = childrenAtDepth.index;
      for (let i2 = 0; i2 < index; i2++) {
        const child = list[i2];
        if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
          updateTransformAndChildren(child, updateTick, 0);
        }
      }
      clearList(list, index);
      childrenAtDepth.index = 0;
    }
    if (updateChildRenderGroups) {
      for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
        updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
      }
    }
  }
  function updateRenderGroupTransform(renderGroup) {
    const root = renderGroup.root;
    let worldAlpha;
    if (renderGroup.renderGroupParent) {
      const renderGroupParent = renderGroup.renderGroupParent;
      renderGroup.worldTransform.appendFrom(
        root.relativeGroupTransform,
        renderGroupParent.worldTransform
      );
      renderGroup.worldColor = mixColors(
        root.groupColor,
        renderGroupParent.worldColor
      );
      worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
    } else {
      renderGroup.worldTransform.copyFrom(root.localTransform);
      renderGroup.worldColor = root.localColor;
      worldAlpha = root.localAlpha;
    }
    worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
    renderGroup.worldAlpha = worldAlpha;
    renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
  }
  function updateTransformAndChildren(container, updateTick, updateFlags) {
    if (updateTick === container.updateTick)
      return;
    container.updateTick = updateTick;
    container.didChange = false;
    const localTransform = container.localTransform;
    container.updateLocalTransform();
    const parent = container.parent;
    if (parent && !parent.renderGroup) {
      updateFlags = updateFlags | container._updateFlags;
      container.relativeGroupTransform.appendFrom(
        localTransform,
        parent.relativeGroupTransform
      );
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, parent, updateFlags);
      }
    } else {
      updateFlags = container._updateFlags;
      container.relativeGroupTransform.copyFrom(localTransform);
      if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
        updateColorBlendVisibility(container, tempContainer, updateFlags);
      }
    }
    if (!container.renderGroup) {
      const children = container.children;
      const length = children.length;
      for (let i2 = 0; i2 < length; i2++) {
        updateTransformAndChildren(children[i2], updateTick, updateFlags);
      }
      const renderGroup = container.parentRenderGroup;
      if (container.renderPipeId && !renderGroup.structureDidChange) {
        renderGroup.updateRenderable(container);
      }
    }
  }
  function updateColorBlendVisibility(container, parent, updateFlags) {
    if (updateFlags & UPDATE_COLOR) {
      container.groupColor = mixColors(
        container.localColor,
        parent.groupColor
      );
      let groupAlpha = container.localAlpha * parent.groupAlpha;
      groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
      container.groupAlpha = groupAlpha;
      container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
    }
    if (updateFlags & UPDATE_BLEND) {
      container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
    }
    if (updateFlags & UPDATE_VISIBLE) {
      container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
    }
    container._updateFlags = 0;
  }
  var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
  var init_updateRenderGroupTransforms = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
      init_Container2();
      init_clearList();
      init_mixColors();
      tempContainer = new Container2();
      UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
    }
  });

  // node_modules/pixi-v8/lib/scene/container/utils/validateRenderables.mjs
  function validateRenderables(renderGroup, renderPipes3) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    let rebuildRequired = false;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      const renderable = container;
      const pipe = renderPipes3[renderable.renderPipeId];
      rebuildRequired = pipe.validateRenderable(container);
      if (rebuildRequired) {
        break;
      }
    }
    renderGroup.structureDidChange = rebuildRequired;
    return rebuildRequired;
  }
  var init_validateRenderables = __esm({
    "node_modules/pixi-v8/lib/scene/container/utils/validateRenderables.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/scene/container/RenderGroupSystem.mjs
  function updateRenderables(renderGroup) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    for (let i2 = 0; i2 < index; i2++) {
      const container = list[i2];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
    clearList(list, index);
  }
  var tempMatrix8, RenderGroupSystem;
  var init_RenderGroupSystem = __esm({
    "node_modules/pixi-v8/lib/scene/container/RenderGroupSystem.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_buildInstructions();
      init_clearList();
      init_collectRenderGroups();
      init_executeInstructions();
      init_updateRenderGroupTransforms();
      init_validateRenderables();
      tempMatrix8 = new Matrix2();
      RenderGroupSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        render({ container, transform: transform2 }) {
          container.isRenderGroup = true;
          const parent = container.parent;
          const renderGroupParent = container.renderGroup.renderGroupParent;
          container.parent = null;
          container.renderGroup.renderGroupParent = null;
          const renderer = this._renderer;
          const renderGroups = collectRenderGroups(container.renderGroup, []);
          let originalLocalTransform = tempMatrix8;
          if (transform2) {
            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
            container.renderGroup.localTransform.copyFrom(transform2);
          }
          const renderPipes3 = renderer.renderPipes;
          for (let i2 = 0; i2 < renderGroups.length; i2++) {
            const renderGroup = renderGroups[i2];
            renderGroup.runOnRender();
            renderGroup.instructionSet.renderPipes = renderPipes3;
            if (!renderGroup.structureDidChange) {
              validateRenderables(renderGroup, renderPipes3);
            } else {
              clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
            }
            updateRenderGroupTransforms(renderGroup);
            if (renderGroup.structureDidChange) {
              renderGroup.structureDidChange = false;
              buildInstructions(renderGroup, renderer);
            } else {
              updateRenderables(renderGroup);
            }
            renderGroup.childrenRenderablesToUpdate.index = 0;
            renderer.renderPipes.batch.upload(renderGroup.instructionSet);
          }
          renderer.globalUniforms.start({
            worldTransformMatrix: transform2 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
            worldColor: container.renderGroup.worldColorAlpha
          });
          executeInstructions(container.renderGroup, renderPipes3);
          if (renderPipes3.uniformBatch) {
            renderPipes3.uniformBatch.renderEnd();
          }
          if (transform2) {
            container.renderGroup.localTransform.copyFrom(originalLocalTransform);
          }
          container.parent = parent;
          container.renderGroup.renderGroupParent = renderGroupParent;
        }
        destroy() {
          this._renderer = null;
        }
      };
      RenderGroupSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "renderGroup"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/sprite/SpritePipe.mjs
  var SpritePipe;
  var init_SpritePipe = __esm({
    "node_modules/pixi-v8/lib/scene/sprite/SpritePipe.mjs"() {
      init_Extensions();
      init_PoolGroup();
      init_BatchableSprite();
      SpritePipe = class {
        constructor(renderer) {
          this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
          this._destroyRenderableBound = this.destroyRenderable.bind(this);
          this._renderer = renderer;
        }
        addRenderable(sprite, instructionSet) {
          const gpuSprite = this._getGpuSprite(sprite);
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
        }
        updateRenderable(sprite) {
          const gpuSprite = this._gpuSpriteHash[sprite.uid];
          if (sprite._didSpriteUpdate)
            this._updateBatchableSprite(sprite, gpuSprite);
          gpuSprite._batcher.updateElement(gpuSprite);
        }
        validateRenderable(sprite) {
          const texture = sprite._texture;
          const gpuSprite = this._getGpuSprite(sprite);
          if (gpuSprite.texture._source !== texture._source) {
            return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);
          }
          return false;
        }
        destroyRenderable(sprite) {
          const batchableSprite = this._gpuSpriteHash[sprite.uid];
          BigPool.return(batchableSprite);
          this._gpuSpriteHash[sprite.uid] = null;
          sprite.off("destroyed", this._destroyRenderableBound);
        }
        _updateBatchableSprite(sprite, batchableSprite) {
          sprite._didSpriteUpdate = false;
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.texture = sprite._texture;
        }
        _getGpuSprite(sprite) {
          return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
        }
        _initGPUSprite(sprite) {
          const batchableSprite = BigPool.get(BatchableSprite);
          batchableSprite.renderable = sprite;
          batchableSprite.transform = sprite.groupTransform;
          batchableSprite.texture = sprite._texture;
          batchableSprite.bounds = sprite.bounds;
          batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
          this._gpuSpriteHash[sprite.uid] = batchableSprite;
          sprite._didSpriteUpdate = false;
          sprite.on("destroyed", this._destroyRenderableBound);
          return batchableSprite;
        }
        destroy() {
          for (const i2 in this._gpuSpriteHash) {
            BigPool.return(this._gpuSpriteHash[i2]);
          }
          this._gpuSpriteHash = null;
          this._renderer = null;
        }
      };
      SpritePipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "sprite"
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/const.mjs
  var VERSION;
  var init_const14 = __esm({
    "node_modules/pixi-v8/lib/utils/const.mjs"() {
      init_eventemitter3();
      VERSION = "8.4.1";
    }
  });

  // node_modules/pixi-v8/lib/utils/global/globalHooks.mjs
  var ApplicationInitHook, RendererInitHook;
  var init_globalHooks = __esm({
    "node_modules/pixi-v8/lib/utils/global/globalHooks.mjs"() {
      init_Extensions();
      init_const14();
      ApplicationInitHook = class {
        static init() {
          globalThis.__PIXI_APP_INIT__?.(this, VERSION);
        }
        static destroy() {
        }
      };
      ApplicationInitHook.extension = ExtensionType2.Application;
      RendererInitHook = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        init() {
          globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
        }
        destroy() {
          this._renderer = null;
        }
      };
      RendererInitHook.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "initHook",
        priority: -10
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/shared/BatcherPipe.mjs
  var _BatcherPipe, BatcherPipe;
  var init_BatcherPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
      init_Extensions();
      init_State2();
      init_DefaultBatcher();
      _BatcherPipe = class _BatcherPipe2 {
        constructor(renderer, adaptor) {
          this.state = State2.for2d();
          this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
          this._activeBatches = /* @__PURE__ */ Object.create(null);
          this.renderer = renderer;
          this._adaptor = adaptor;
          this._adaptor.init?.(this);
        }
        static getBatcher(name) {
          return new this._availableBatchers[name]();
        }
        buildStart(instructionSet) {
          let batchers = this._batchersByInstructionSet[instructionSet.uid];
          if (!batchers) {
            batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
            batchers.default || (batchers.default = new DefaultBatcher());
          }
          this._activeBatches = batchers;
          this._activeBatch = this._activeBatches.default;
          for (const i2 in this._activeBatches) {
            this._activeBatches[i2].begin();
          }
        }
        addToBatch(batchableObject, instructionSet) {
          if (this._activeBatch.name !== batchableObject.batcherName) {
            this._activeBatch.break(instructionSet);
            let batch = this._activeBatches[batchableObject.batcherName];
            if (!batch) {
              batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
              batch.begin();
            }
            this._activeBatch = batch;
          }
          this._activeBatch.add(batchableObject);
        }
        break(instructionSet) {
          this._activeBatch.break(instructionSet);
        }
        buildEnd(instructionSet) {
          this._activeBatch.break(instructionSet);
          const batches = this._activeBatches;
          for (const i2 in batches) {
            const batch = batches[i2];
            const geometry = batch.geometry;
            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
          }
        }
        upload(instructionSet) {
          const batchers = this._batchersByInstructionSet[instructionSet.uid];
          for (const i2 in batchers) {
            const batcher = batchers[i2];
            const geometry = batcher.geometry;
            if (batcher.dirty) {
              batcher.dirty = false;
              geometry.buffers[0].update(batcher.attributeSize * 4);
            }
          }
        }
        execute(batch) {
          if (batch.action === "startBatch") {
            const batcher = batch.batcher;
            const geometry = batcher.geometry;
            const shader = batcher.shader;
            this._adaptor.start(this, geometry, shader);
          }
          this._adaptor.execute(this, batch);
        }
        destroy() {
          this.state = null;
          this.renderer = null;
          this._adaptor = null;
          for (const i2 in this._activeBatches) {
            this._activeBatches[i2].destroy();
          }
          this._activeBatches = null;
        }
      };
      _BatcherPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "batch"
      };
      _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
      BatcherPipe = _BatcherPipe;
      extensions3.handleByMap(ExtensionType2.Batcher, BatcherPipe._availableBatchers);
      extensions3.add(DefaultBatcher);
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/mask.frag.mjs
  var fragment9;
  var init_mask_frag = __esm({
    "node_modules/pixi-v8/lib/filters/mask/mask.frag.mjs"() {
      fragment9 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha; \n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * uAlpha * clip);\n\n    finalColor = original;\n}\n";
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/mask.vert.mjs
  var vertex6;
  var init_mask_vert = __esm({
    "node_modules/pixi-v8/lib/filters/mask/mask.vert.mjs"() {
      vertex6 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/mask.wgsl.mjs
  var source;
  var init_mask_wgsl = __esm({
    "node_modules/pixi-v8/lib/filters/mask/mask.wgsl.mjs"() {
      source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb, source.a) * a;\n}";
    }
  });

  // node_modules/pixi-v8/lib/filters/mask/MaskFilter.mjs
  var MaskFilter;
  var init_MaskFilter = __esm({
    "node_modules/pixi-v8/lib/filters/mask/MaskFilter.mjs"() {
      init_Matrix2();
      init_GlProgram();
      init_GpuProgram();
      init_UniformGroup2();
      init_TextureMatrix2();
      init_Filter2();
      init_mask_frag();
      init_mask_vert();
      init_mask_wgsl();
      MaskFilter = class extends Filter2 {
        constructor(options) {
          const { sprite, ...rest } = options;
          const textureMatrix = new TextureMatrix2(sprite.texture);
          const filterUniforms = new UniformGroup2({
            uFilterMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
            uAlpha: { value: 1, type: "f32" }
          });
          const gpuProgram3 = GpuProgram.from({
            vertex: {
              source,
              entryPoint: "mainVertex"
            },
            fragment: {
              source,
              entryPoint: "mainFragment"
            }
          });
          const glProgram3 = GlProgram.from({
            vertex: vertex6,
            fragment: fragment9,
            name: "mask-filter"
          });
          super({
            ...rest,
            gpuProgram: gpuProgram3,
            glProgram: glProgram3,
            resources: {
              filterUniforms,
              uMaskTexture: sprite.texture.source
            }
          });
          this.sprite = sprite;
          this._textureMatrix = textureMatrix;
        }
        apply(filterManager, input, output, clearMode) {
          this._textureMatrix.texture = this.sprite.texture;
          filterManager.calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.uFilterMatrix,
            this.sprite
          ).prepend(this._textureMatrix.mapCoord);
          this.resources.uMaskTexture = this.sprite.texture.source;
          filterManager.applyFilter(this, input, output, clearMode);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
  var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
  var init_AlphaMaskPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_MaskFilter();
      init_Bounds2();
      init_getGlobalBounds();
      init_buildInstructions();
      init_Sprite2();
      init_PoolGroup();
      init_Texture2();
      init_TexturePool();
      init_types2();
      tempBounds3 = new Bounds2();
      AlphaMaskEffect = class extends FilterEffect {
        constructor() {
          super();
          this.filters = [new MaskFilter({
            sprite: new Sprite2(Texture2.EMPTY),
            resolution: "inherit",
            antialias: "inherit"
          })];
        }
        get sprite() {
          return this.filters[0].sprite;
        }
        set sprite(value) {
          this.filters[0].sprite = value;
        }
      };
      AlphaMaskPipe = class {
        constructor(renderer) {
          this._activeMaskStage = [];
          this._renderer = renderer;
        }
        push(mask, maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskBegin",
            mask,
            canBundle: false,
            maskedContainer
          });
          if (mask.renderMaskToTexture) {
            const maskContainer = mask.mask;
            maskContainer.includeInBuild = true;
            collectAllRenderables(
              maskContainer,
              instructionSet,
              renderer
            );
            maskContainer.includeInBuild = false;
          }
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask,
            maskedContainer,
            canBundle: false
          });
        }
        pop(mask, _maskedContainer, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask,
            canBundle: false
          });
        }
        execute(instruction) {
          const renderer = this._renderer;
          const renderMask = instruction.mask.renderMaskToTexture;
          if (instruction.action === "pushMaskBegin") {
            const filterEffect = BigPool.get(AlphaMaskEffect);
            if (renderMask) {
              instruction.mask.mask.measurable = true;
              const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
              instruction.mask.mask.measurable = false;
              bounds.ceil();
              const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
              const filterTexture = TexturePool.getOptimalTexture(
                bounds.width,
                bounds.height,
                colorTextureSource._resolution,
                colorTextureSource.antialias
              );
              renderer.renderTarget.push(filterTexture, true);
              renderer.globalUniforms.push({
                offset: bounds,
                worldColor: 4294967295
              });
              const sprite = filterEffect.sprite;
              sprite.texture = filterTexture;
              sprite.worldTransform.tx = bounds.minX;
              sprite.worldTransform.ty = bounds.minY;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer,
                filterTexture
              });
            } else {
              filterEffect.sprite = instruction.mask.mask;
              this._activeMaskStage.push({
                filterEffect,
                maskedContainer: instruction.maskedContainer
              });
            }
          } else if (instruction.action === "pushMaskEnd") {
            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
            if (renderMask) {
              if (renderer.type === RendererType.WEBGL) {
                renderer.renderTarget.finishRenderPass();
              }
              renderer.renderTarget.pop();
              renderer.globalUniforms.pop();
            }
            renderer.filter.push({
              renderPipeId: "filter",
              action: "pushFilter",
              container: maskData.maskedContainer,
              filterEffect: maskData.filterEffect,
              canBundle: false
            });
          } else if (instruction.action === "popMaskEnd") {
            renderer.filter.pop();
            const maskData = this._activeMaskStage.pop();
            if (renderMask) {
              TexturePool.returnTexture(maskData.filterTexture);
            }
            BigPool.return(maskData.filterEffect);
          }
        }
        destroy() {
          this._renderer = null;
          this._activeMaskStage = null;
        }
      };
      AlphaMaskPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "alphaMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/color/ColorMaskPipe.mjs
  var ColorMaskPipe;
  var init_ColorMaskPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
      init_Extensions();
      ColorMaskPipe = class {
        constructor(renderer) {
          this._colorStack = [];
          this._colorStackIndex = 0;
          this._currentColor = 0;
          this._renderer = renderer;
        }
        buildStart() {
          this._colorStack[0] = 15;
          this._colorStackIndex = 1;
          this._currentColor = 15;
        }
        push(mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
          const currentColor = this._colorStack[this._colorStackIndex];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
          this._colorStackIndex++;
        }
        pop(_mask, _container, instructionSet) {
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          const colorStack = this._colorStack;
          this._colorStackIndex--;
          const currentColor = colorStack[this._colorStackIndex - 1];
          if (currentColor !== this._currentColor) {
            this._currentColor = currentColor;
            instructionSet.add({
              renderPipeId: "colorMask",
              colorMask: currentColor,
              canBundle: false
            });
          }
        }
        execute(instruction) {
          const renderer = this._renderer;
          renderer.colorMask.setMask(instruction.colorMask);
        }
        destroy() {
          this._colorStack = null;
        }
      };
      ColorMaskPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMaskPipe.mjs
  var StencilMaskPipe;
  var init_StencilMaskPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
      init_Extensions();
      init_buildInstructions();
      init_const13();
      init_const9();
      StencilMaskPipe = class {
        constructor(renderer) {
          this._maskStackHash = {};
          this._maskHash = /* @__PURE__ */ new WeakMap();
          this._renderer = renderer;
        }
        push(mask, _container, instructionSet) {
          var _a;
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask,
            canBundle: false
          });
          const maskContainer = effect.mask;
          maskContainer.includeInBuild = true;
          if (!this._maskHash.has(effect)) {
            this._maskHash.set(effect, {
              instructionsStart: 0,
              instructionsLength: 0
            });
          }
          const maskData = this._maskHash.get(effect);
          maskData.instructionsStart = instructionSet.instructionSize;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer
          );
          maskContainer.includeInBuild = false;
          renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask,
            canBundle: false
          });
          const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
          maskData.instructionsLength = instructionsLength;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
        }
        pop(mask, _container, instructionSet) {
          const effect = mask;
          const renderer = this._renderer;
          renderer.renderPipes.batch.break(instructionSet);
          renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            canBundle: false
          });
          const maskData = this._maskHash.get(mask);
          for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
          }
          instructionSet.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: false
          });
        }
        execute(instruction) {
          var _a;
          const renderer = this._renderer;
          const renderTargetUid = renderer.renderTarget.renderTarget.uid;
          let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
          if (instruction.action === "pushMaskBegin") {
            renderer.renderTarget.ensureDepthStencil();
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
            maskStackIndex++;
            renderer.colorMask.setMask(0);
          } else if (instruction.action === "pushMaskEnd") {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            renderer.colorMask.setMask(15);
          } else if (instruction.action === "popMaskBegin") {
            renderer.colorMask.setMask(0);
            if (maskStackIndex !== 0) {
              renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
            } else {
              renderer.renderTarget.clear(null, CLEAR.STENCIL);
              renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
            }
            maskStackIndex--;
          } else if (instruction.action === "popMaskEnd") {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
            renderer.colorMask.setMask(15);
          }
          this._maskStackHash[renderTargetUid] = maskStackIndex;
        }
        destroy() {
          this._renderer = null;
          this._maskStackHash = null;
          this._maskHash = null;
        }
      };
      StencilMaskPipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "stencilMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
  var _BackgroundSystem, BackgroundSystem2;
  var init_BackgroundSystem2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
      init_Color2();
      init_Extensions();
      _BackgroundSystem = class _BackgroundSystem2 {
        constructor() {
          this.clearBeforeRender = true;
          this._backgroundColor = new Color2(0);
          this.color = this._backgroundColor;
          this.alpha = 1;
        }
        init(options) {
          options = { ..._BackgroundSystem2.defaultOptions, ...options };
          this.clearBeforeRender = options.clearBeforeRender;
          this.color = options.background || options.backgroundColor || this._backgroundColor;
          this.alpha = options.backgroundAlpha;
          this._backgroundColor.setAlpha(options.backgroundAlpha);
        }
        get color() {
          return this._backgroundColor;
        }
        set color(value) {
          this._backgroundColor.setValue(value);
        }
        get alpha() {
          return this._backgroundColor.alpha;
        }
        set alpha(value) {
          this._backgroundColor.setAlpha(value);
        }
        get colorRgba() {
          return this._backgroundColor.toArray();
        }
        destroy() {
        }
      };
      _BackgroundSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "background",
        priority: 0
      };
      _BackgroundSystem.defaultOptions = {
        backgroundAlpha: 1,
        backgroundColor: 0,
        clearBeforeRender: true
      };
      BackgroundSystem2 = _BackgroundSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
  var BLEND_MODE_FILTERS, BlendModePipe;
  var init_BlendModePipe = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
      init_Extensions();
      init_FilterEffect();
      init_warn();
      BLEND_MODE_FILTERS = {};
      extensions3.handle(ExtensionType2.BlendMode, (value) => {
        if (!value.name) {
          throw new Error("BlendMode extension must have a name property");
        }
        BLEND_MODE_FILTERS[value.name] = value.ref;
      }, (value) => {
        delete BLEND_MODE_FILTERS[value.name];
      });
      BlendModePipe = class {
        constructor(renderer) {
          this._isAdvanced = false;
          this._filterHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        setBlendMode(renderable, blendMode, instructionSet) {
          if (this._activeBlendMode === blendMode) {
            if (this._isAdvanced)
              this._renderableList.push(renderable);
            return;
          }
          this._activeBlendMode = blendMode;
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
          this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
          if (this._isAdvanced) {
            this._beginAdvancedBlendMode(instructionSet);
            this._renderableList.push(renderable);
          }
        }
        _beginAdvancedBlendMode(instructionSet) {
          this._renderer.renderPipes.batch.break(instructionSet);
          const blendMode = this._activeBlendMode;
          if (!BLEND_MODE_FILTERS[blendMode]) {
            warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return;
          }
          let filterEffect = this._filterHash[blendMode];
          if (!filterEffect) {
            filterEffect = this._filterHash[blendMode] = new FilterEffect();
            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
          }
          const instruction = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect,
            canBundle: false
          };
          this._renderableList = instruction.renderables;
          instructionSet.add(instruction);
        }
        _endAdvancedBlendMode(instructionSet) {
          this._renderableList = null;
          this._renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: false
          });
        }
        buildStart() {
          this._isAdvanced = false;
        }
        buildEnd(instructionSet) {
          if (this._isAdvanced) {
            this._endAdvancedBlendMode(instructionSet);
          }
        }
        destroy() {
          this._renderer = null;
          this._renderableList = null;
          for (const i2 in this._filterHash) {
            this._filterHash[i2].destroy();
          }
          this._filterHash = null;
        }
      };
      BlendModePipe.extension = {
        type: [
          ExtensionType2.WebGLPipes,
          ExtensionType2.WebGPUPipes,
          ExtensionType2.CanvasPipes
        ],
        name: "blendMode"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
  var imageTypes, _ExtractSystem, ExtractSystem;
  var init_ExtractSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
      init_Extensions();
      init_Container2();
      init_Texture2();
      imageTypes = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
      };
      _ExtractSystem = class _ExtractSystem2 {
        constructor(renderer) {
          this._renderer = renderer;
        }
        _normalizeOptions(options, defaults = {}) {
          if (options instanceof Container2 || options instanceof Texture2) {
            return {
              target: options,
              ...defaults
            };
          }
          return {
            ...defaults,
            ...options
          };
        }
        async image(options) {
          const image = new Image();
          image.src = await this.base64(options);
          return image;
        }
        async base64(options) {
          options = this._normalizeOptions(
            options,
            _ExtractSystem2.defaultImageOptions
          );
          const { format: format2, quality } = options;
          const canvas = this.canvas(options);
          if (canvas.toBlob !== void 0) {
            return new Promise((resolve2, reject) => {
              canvas.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const reader = new FileReader();
                reader.onload = () => resolve2(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              }, imageTypes[format2], quality);
            });
          }
          if (canvas.toDataURL !== void 0) {
            return canvas.toDataURL(imageTypes[format2], quality);
          }
          if (canvas.convertToBlob !== void 0) {
            const blob = await canvas.convertToBlob({ type: imageTypes[format2], quality });
            return new Promise((resolve2, reject) => {
              const reader = new FileReader();
              reader.onload = () => resolve2(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            });
          }
          throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
        }
        canvas(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          if (target instanceof Texture2) {
            return renderer.texture.generateCanvas(target);
          }
          const texture = renderer.textureGenerator.generateTexture(options);
          const canvas = renderer.texture.generateCanvas(texture);
          texture.destroy();
          return canvas;
        }
        pixels(options) {
          options = this._normalizeOptions(options);
          const target = options.target;
          const renderer = this._renderer;
          const texture = target instanceof Texture2 ? target : renderer.textureGenerator.generateTexture(options);
          const pixelInfo = renderer.texture.getPixels(texture);
          if (target instanceof Container2) {
            texture.destroy();
          }
          return pixelInfo;
        }
        texture(options) {
          options = this._normalizeOptions(options);
          if (options.target instanceof Texture2)
            return options.target;
          return this._renderer.textureGenerator.generateTexture(options);
        }
        download(options) {
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const link = document.createElement("a");
          link.download = options.filename ?? "image.png";
          link.href = canvas.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        log(options) {
          const width = options.width ?? 200;
          options = this._normalizeOptions(options);
          const canvas = this.canvas(options);
          const base64 = canvas.toDataURL();
          console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
          const style = [
            "font-size: 1px;",
            `padding: ${width}px ${300}px;`,
            `background: url(${base64}) no-repeat;`,
            "background-size: contain;"
          ].join(" ");
          console.log("%c ", style);
        }
        destroy() {
          this._renderer = null;
        }
      };
      _ExtractSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "extract"
      };
      _ExtractSystem.defaultImageOptions = {
        format: "png",
        quality: 1
      };
      ExtractSystem = _ExtractSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/RenderTexture.mjs
  var RenderTexture2;
  var init_RenderTexture2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
      init_TextureSource();
      init_Texture2();
      RenderTexture2 = class extends Texture2 {
        static create(options) {
          return new RenderTexture2({
            source: new TextureSource(options)
          });
        }
        resize(width, height, resolution) {
          this.source.resize(width, height, resolution);
          return this;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
  var tempRect4, tempBounds4, noColor, GenerateTextureSystem2;
  var init_GenerateTextureSystem2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
      init_Color2();
      init_Extensions();
      init_Matrix2();
      init_Rectangle2();
      init_Bounds2();
      init_getLocalBounds();
      init_Container2();
      init_RenderTexture2();
      tempRect4 = new Rectangle2();
      tempBounds4 = new Bounds2();
      noColor = [0, 0, 0, 0];
      GenerateTextureSystem2 = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        generateTexture(options) {
          if (options instanceof Container2) {
            options = {
              target: options,
              frame: void 0,
              textureSourceOptions: {},
              resolution: void 0
            };
          }
          const resolution = options.resolution || this._renderer.resolution;
          const antialias = options.antialias || this._renderer.view.antialias;
          const container = options.target;
          let clearColor = options.clearColor;
          if (clearColor) {
            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
            clearColor = isRGBAArray ? clearColor : Color2.shared.setValue(clearColor).toArray();
          } else {
            clearColor = noColor;
          }
          const region = options.frame?.copyTo(tempRect4) || getLocalBounds(container, tempBounds4).rectangle;
          region.width = Math.max(region.width, 1 / resolution) | 0;
          region.height = Math.max(region.height, 1 / resolution) | 0;
          const target = RenderTexture2.create({
            ...options.textureSourceOptions,
            width: region.width,
            height: region.height,
            resolution,
            antialias
          });
          const transform2 = Matrix2.shared.translate(-region.x, -region.y);
          this._renderer.render({
            container,
            transform: transform2,
            target,
            clearColor
          });
          target.source.updateMipmaps();
          return target;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GenerateTextureSystem2.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "textureGenerator"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
  var GlobalUniformSystem;
  var init_GlobalUniformSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_Point2();
      init_colorToUniform();
      init_BindGroup();
      init_types2();
      init_UniformGroup2();
      GlobalUniformSystem = class {
        constructor(renderer) {
          this._stackIndex = 0;
          this._globalUniformDataStack = [];
          this._uniformsPool = [];
          this._activeUniforms = [];
          this._bindGroupPool = [];
          this._activeBindGroups = [];
          this._renderer = renderer;
        }
        reset() {
          this._stackIndex = 0;
          for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
            this._uniformsPool.push(this._activeUniforms[i2]);
          }
          for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
            this._bindGroupPool.push(this._activeBindGroups[i2]);
          }
          this._activeUniforms.length = 0;
          this._activeBindGroups.length = 0;
        }
        start(options) {
          this.reset();
          this.push(options);
        }
        bind({
          size,
          projectionMatrix,
          worldTransformMatrix,
          worldColor,
          offset
        }) {
          const renderTarget = this._renderer.renderTarget.renderTarget;
          const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
            projectionData: renderTarget,
            worldTransformMatrix: new Matrix2(),
            worldColor: 4294967295,
            offset: new Point2()
          };
          const globalUniformData = {
            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
            resolution: size || renderTarget.size,
            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
            worldColor: worldColor || currentGlobalUniformData.worldColor,
            offset: offset || currentGlobalUniformData.offset,
            bindGroup: null
          };
          const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
          this._activeUniforms.push(uniformGroup);
          const uniforms = uniformGroup.uniforms;
          uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
          uniforms.uResolution = globalUniformData.resolution;
          uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
          uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
          uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
          color32BitToUniform(
            globalUniformData.worldColor,
            uniforms.uWorldColorAlpha,
            0
          );
          uniformGroup.update();
          let bindGroup;
          if (this._renderer.renderPipes.uniformBatch) {
            bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
          } else {
            bindGroup = this._bindGroupPool.pop() || new BindGroup();
            this._activeBindGroups.push(bindGroup);
            bindGroup.setResource(uniformGroup, 0);
          }
          globalUniformData.bindGroup = bindGroup;
          this._currentGlobalUniformData = globalUniformData;
        }
        push(options) {
          this.bind(options);
          this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
        }
        pop() {
          this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
          if (this._renderer.type === RendererType.WEBGL) {
            this._currentGlobalUniformData.bindGroup.resources[0].update();
          }
        }
        get bindGroup() {
          return this._currentGlobalUniformData.bindGroup;
        }
        get uniformGroup() {
          return this._currentGlobalUniformData.bindGroup.resources[0];
        }
        _createUniforms() {
          const globalUniforms = new UniformGroup2({
            uProjectionMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uWorldTransformMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
            uResolution: { value: [0, 0], type: "vec2<f32>" }
          }, {
            isStatic: true
          });
          return globalUniforms;
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlobalUniformSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "globalUniforms"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/SchedulerSystem.mjs
  var uid3, SchedulerSystem;
  var init_SchedulerSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
      init_Extensions();
      init_Ticker2();
      uid3 = 1;
      SchedulerSystem = class {
        constructor() {
          this._tasks = [];
        }
        init() {
          Ticker2.system.add(this._update, this);
        }
        repeat(func, duration) {
          const id = uid3++;
          this._tasks.push({
            func,
            duration,
            start: performance.now(),
            last: performance.now(),
            repeat: true,
            id
          });
          return id;
        }
        cancel(id) {
          for (let i2 = 0; i2 < this._tasks.length; i2++) {
            if (this._tasks[i2].id === id) {
              this._tasks.splice(i2, 1);
              return;
            }
          }
        }
        _update() {
          const now = performance.now();
          for (let i2 = 0; i2 < this._tasks.length; i2++) {
            const task = this._tasks[i2];
            if (now - task.last >= task.duration) {
              const elapsed = now - task.start;
              task.func(elapsed);
              task.last = now;
            }
          }
        }
        destroy() {
          Ticker2.system.remove(this._update, this);
          this._tasks.length = 0;
        }
      };
      SchedulerSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "scheduler",
        priority: 0
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/sayHello.mjs
  function sayHello2(type) {
    if (saidHello) {
      return;
    }
    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const args = [
        `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
        "background: #E72264; padding:5px 0;",
        "background: #6CA2EA; padding:5px 0;",
        "background: #B5D33D; padding:5px 0;",
        "background: #FED23F; padding:5px 0;",
        "color: #FFFFFF; background: #E72264; padding:5px 0;",
        "color: #E72264; background: #FFFFFF; padding:5px 0;"
      ];
      globalThis.console.log(...args);
    } else if (globalThis.console) {
      globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
    }
    saidHello = true;
  }
  var saidHello;
  var init_sayHello = __esm({
    "node_modules/pixi-v8/lib/utils/sayHello.mjs"() {
      init_adapter2();
      init_const14();
      saidHello = false;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/startup/HelloSystem.mjs
  var HelloSystem;
  var init_HelloSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
      init_Extensions();
      init_sayHello();
      init_types2();
      HelloSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        init(options) {
          if (options.hello) {
            let name = this._renderer.name;
            if (this._renderer.type === RendererType.WEBGL) {
              name += ` ${this._renderer.context.webGLVersion}`;
            }
            sayHello2(name);
          }
        }
      };
      HelloSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "hello",
        priority: -2
      };
      HelloSystem.defaultOptions = {
        hello: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
  var _RenderableGCSystem, RenderableGCSystem;
  var init_RenderableGCSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
      init_Extensions();
      _RenderableGCSystem = class _RenderableGCSystem2 {
        constructor(renderer) {
          this._managedRenderables = [];
          this._renderer = renderer;
        }
        init(options) {
          options = { ..._RenderableGCSystem2.defaultOptions, ...options };
          this.maxUnusedTime = options.renderableGCMaxUnusedTime;
          this._frequency = options.renderableGCFrequency;
          this.enabled = options.renderableGCActive;
        }
        get enabled() {
          return !!this._handler;
        }
        set enabled(value) {
          if (this.enabled === value)
            return;
          if (value) {
            this._handler = this._renderer.scheduler.repeat(
              () => this.run(),
              this._frequency
            );
          } else {
            this._renderer.scheduler.cancel(this._handler);
          }
        }
        prerender() {
          this._now = performance.now();
        }
        addRenderable(renderable, instructionSet) {
          if (!this.enabled)
            return;
          renderable._lastUsed = this._now;
          if (renderable._lastInstructionTick === -1) {
            this._managedRenderables.push(renderable);
            renderable.once("destroyed", this._removeRenderable, this);
          }
          renderable._lastInstructionTick = instructionSet.tick;
        }
        run() {
          const now = performance.now();
          const managedRenderables = this._managedRenderables;
          const renderPipes3 = this._renderer.renderPipes;
          let offset = 0;
          for (let i2 = 0; i2 < managedRenderables.length; i2++) {
            const renderable = managedRenderables[i2];
            if (renderable === null) {
              offset++;
              continue;
            }
            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
            const currentIndex = renderGroup?.instructionSet?.tick ?? -1;
            if (renderable._lastInstructionTick !== currentIndex && now - renderable._lastUsed > this.maxUnusedTime) {
              if (!renderable.destroyed) {
                const rp = renderPipes3;
                rp[renderable.renderPipeId].destroyRenderable(renderable);
              }
              renderable._lastInstructionTick = -1;
              offset++;
              renderable.off("destroyed", this._removeRenderable, this);
            } else {
              managedRenderables[i2 - offset] = renderable;
            }
          }
          managedRenderables.length = managedRenderables.length - offset;
        }
        destroy() {
          this.enabled = false;
          this._renderer = null;
          this._managedRenderables.length = 0;
        }
        _removeRenderable(renderable) {
          const index = this._managedRenderables.indexOf(renderable);
          if (index >= 0) {
            renderable.off("destroyed", this._removeRenderable, this);
            this._managedRenderables[index] = null;
          }
        }
      };
      _RenderableGCSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "renderableGC"
      };
      _RenderableGCSystem.defaultOptions = {
        renderableGCActive: true,
        renderableGCMaxUnusedTime: 6e4,
        renderableGCFrequency: 3e4
      };
      RenderableGCSystem = _RenderableGCSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
  var _TextureGCSystem3, TextureGCSystem2;
  var init_TextureGCSystem2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
      init_Extensions();
      _TextureGCSystem3 = class _TextureGCSystem4 {
        constructor(renderer) {
          this._renderer = renderer;
          this.count = 0;
          this.checkCount = 0;
        }
        init(options) {
          options = { ..._TextureGCSystem4.defaultOptions, ...options };
          this.checkCountMax = options.textureGCCheckCountMax;
          this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
          this.active = options.textureGCActive;
        }
        postrender() {
          if (!this._renderer.renderingToScreen) {
            return;
          }
          this.count++;
          if (!this.active)
            return;
          this.checkCount++;
          if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
          }
        }
        run() {
          const managedTextures = this._renderer.texture.managedTextures;
          for (let i2 = 0; i2 < managedTextures.length; i2++) {
            const texture = managedTextures[i2];
            if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
              texture._touched = -1;
              texture.unload();
            }
          }
        }
        destroy() {
          this._renderer = null;
        }
      };
      _TextureGCSystem3.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem
        ],
        name: "textureGC"
      };
      _TextureGCSystem3.defaultOptions = {
        textureGCActive: true,
        textureGCAMaxIdle: null,
        textureGCMaxIdle: 60 * 60,
        textureGCCheckCountMax: 600
      };
      TextureGCSystem2 = _TextureGCSystem3;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
  var _RenderTarget, RenderTarget;
  var init_RenderTarget = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
      init_uid2();
      init_TextureSource();
      init_Texture2();
      _RenderTarget = class _RenderTarget2 {
        constructor(descriptor = {}) {
          this.uid = uid2("renderTarget");
          this.colorTextures = [];
          this.dirtyId = 0;
          this.isRoot = false;
          this._size = new Float32Array(2);
          this._managedColorTextures = false;
          descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
          this.stencil = descriptor.stencil;
          this.depth = descriptor.depth;
          this.isRoot = descriptor.isRoot;
          if (typeof descriptor.colorTextures === "number") {
            this._managedColorTextures = true;
            for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
              this.colorTextures.push(
                new TextureSource({
                  width: descriptor.width,
                  height: descriptor.height,
                  resolution: descriptor.resolution,
                  antialias: descriptor.antialias
                })
              );
            }
          } else {
            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
            const colorSource = this.colorTexture.source;
            this.resize(colorSource.width, colorSource.height, colorSource._resolution);
          }
          this.colorTexture.source.on("resize", this.onSourceResize, this);
          if (descriptor.depthStencilTexture || this.stencil) {
            if (descriptor.depthStencilTexture instanceof Texture2 || descriptor.depthStencilTexture instanceof TextureSource) {
              this.depthStencilTexture = descriptor.depthStencilTexture.source;
            } else {
              this.ensureDepthStencilTexture();
            }
          }
        }
        get size() {
          const _size = this._size;
          _size[0] = this.pixelWidth;
          _size[1] = this.pixelHeight;
          return _size;
        }
        get width() {
          return this.colorTexture.source.width;
        }
        get height() {
          return this.colorTexture.source.height;
        }
        get pixelWidth() {
          return this.colorTexture.source.pixelWidth;
        }
        get pixelHeight() {
          return this.colorTexture.source.pixelHeight;
        }
        get resolution() {
          return this.colorTexture.source._resolution;
        }
        get colorTexture() {
          return this.colorTextures[0];
        }
        onSourceResize(source2) {
          this.resize(source2.width, source2.height, source2._resolution, true);
        }
        ensureDepthStencilTexture() {
          if (!this.depthStencilTexture) {
            this.depthStencilTexture = new TextureSource({
              width: this.width,
              height: this.height,
              resolution: this.resolution,
              format: "depth24plus-stencil8",
              autoGenerateMipmaps: false,
              antialias: false,
              mipLevelCount: 1
            });
          }
        }
        resize(width, height, resolution = this.resolution, skipColorTexture = false) {
          this.dirtyId++;
          this.colorTextures.forEach((colorTexture, i2) => {
            if (skipColorTexture && i2 === 0)
              return;
            colorTexture.source.resize(width, height, resolution);
          });
          if (this.depthStencilTexture) {
            this.depthStencilTexture.source.resize(width, height, resolution);
          }
        }
        destroy() {
          this.colorTexture.source.off("resize", this.onSourceResize, this);
          if (this._managedColorTextures) {
            this.colorTextures.forEach((texture) => {
              texture.destroy();
            });
          }
          if (this.depthStencilTexture) {
            this.depthStencilTexture.destroy();
            delete this.depthStencilTexture;
          }
        }
      };
      _RenderTarget.defaultOptions = {
        width: 0,
        height: 0,
        resolution: 1,
        colorTextures: 1,
        stencil: false,
        depth: false,
        antialias: false,
        isRoot: false
      };
      RenderTarget = _RenderTarget;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
  function getCanvasTexture(canvas, options) {
    if (!canvasCache.has(canvas)) {
      const texture = new Texture2({
        source: new CanvasSource({
          resource: canvas,
          ...options
        })
      });
      const onDestroy = () => {
        if (canvasCache.get(canvas) === texture) {
          canvasCache.delete(canvas);
        }
      };
      texture.once("destroy", onDestroy);
      texture.source.once("destroy", onDestroy);
      canvasCache.set(canvas, texture);
    }
    return canvasCache.get(canvas);
  }
  var canvasCache;
  var init_getCanvasTexture = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
      init_CanvasSource();
      init_Texture2();
      canvasCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/view/ViewSystem.mjs
  var _ViewSystem, ViewSystem2;
  var init_ViewSystem2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
      init_adapter2();
      init_Extensions();
      init_Rectangle2();
      init_deprecation2();
      init_RenderTarget();
      init_getCanvasTexture();
      _ViewSystem = class _ViewSystem2 {
        get autoDensity() {
          return this.texture.source.autoDensity;
        }
        set autoDensity(value) {
          this.texture.source.autoDensity = value;
        }
        get resolution() {
          return this.texture.source._resolution;
        }
        set resolution(value) {
          this.texture.source.resize(
            this.texture.source.width,
            this.texture.source.height,
            value
          );
        }
        init(options) {
          options = {
            ..._ViewSystem2.defaultOptions,
            ...options
          };
          if (options.view) {
            deprecation2(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
            options.canvas = options.view;
          }
          this.screen = new Rectangle2(0, 0, options.width, options.height);
          this.canvas = options.canvas || DOMAdapter.get().createCanvas();
          this.antialias = !!options.antialias;
          this.texture = getCanvasTexture(this.canvas, options);
          this.renderTarget = new RenderTarget({
            colorTextures: [this.texture],
            depth: !!options.depth,
            isRoot: true
          });
          this.texture.source.transparent = options.backgroundAlpha < 1;
          this.resolution = options.resolution;
        }
        resize(desiredScreenWidth, desiredScreenHeight, resolution) {
          this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
          this.screen.width = this.texture.frame.width;
          this.screen.height = this.texture.frame.height;
        }
        destroy(options = false) {
          const removeView = typeof options === "boolean" ? options : !!options?.removeView;
          if (removeView && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
        }
      };
      _ViewSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem,
          ExtensionType2.WebGPUSystem,
          ExtensionType2.CanvasSystem
        ],
        name: "view",
        priority: 0
      };
      _ViewSystem.defaultOptions = {
        width: 800,
        height: 600,
        autoDensity: false,
        antialias: false
      };
      ViewSystem2 = _ViewSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/system/SharedSystems.mjs
  var SharedSystems, SharedRenderPipes;
  var init_SharedSystems = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
      init_CustomRenderPipe();
      init_RenderGroupPipe();
      init_RenderGroupSystem();
      init_SpritePipe();
      init_globalHooks();
      init_BatcherPipe();
      init_AlphaMaskPipe();
      init_ColorMaskPipe();
      init_StencilMaskPipe();
      init_BackgroundSystem2();
      init_BlendModePipe();
      init_ExtractSystem();
      init_GenerateTextureSystem2();
      init_GlobalUniformSystem();
      init_SchedulerSystem();
      init_HelloSystem();
      init_RenderableGCSystem();
      init_TextureGCSystem2();
      init_ViewSystem2();
      SharedSystems = [
        BackgroundSystem2,
        GlobalUniformSystem,
        HelloSystem,
        ViewSystem2,
        RenderGroupSystem,
        TextureGCSystem2,
        GenerateTextureSystem2,
        ExtractSystem,
        RendererInitHook,
        RenderableGCSystem,
        SchedulerSystem
      ];
      SharedRenderPipes = [
        BlendModePipe,
        BatcherPipe,
        SpritePipe,
        RenderGroupPipe,
        AlphaMaskPipe,
        StencilMaskPipe,
        ColorMaskPipe,
        CustomRenderPipe
      ];
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/BindGroupSystem.mjs
  var BindGroupSystem;
  var init_BindGroupSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
      init_Extensions();
      BindGroupSystem = class {
        constructor(renderer) {
          this._hash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getBindGroup(bindGroup, program, groupIndex) {
          bindGroup._updateKey();
          const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
          return gpuBindGroup;
        }
        _createBindGroup(group, program, groupIndex) {
          const device = this._gpu.device;
          const groupLayout = program.layout[groupIndex];
          const entries = [];
          const renderer = this._renderer;
          for (const j2 in groupLayout) {
            const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
            let gpuResource;
            if (resource._resourceType === "uniformGroup") {
              const uniformGroup = resource;
              renderer.ubo.updateUniformGroup(uniformGroup);
              const buffer = uniformGroup.buffer;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "buffer") {
              const buffer = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(buffer),
                offset: 0,
                size: buffer.descriptor.size
              };
            } else if (resource._resourceType === "bufferResource") {
              const bufferResource = resource;
              gpuResource = {
                buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
                offset: bufferResource.offset,
                size: bufferResource.size
              };
            } else if (resource._resourceType === "textureSampler") {
              const sampler = resource;
              gpuResource = renderer.texture.getGpuSampler(sampler);
            } else if (resource._resourceType === "textureSource") {
              const texture = resource;
              gpuResource = renderer.texture.getGpuSource(texture).createView({});
            }
            entries.push({
              binding: groupLayout[j2],
              resource: gpuResource
            });
          }
          const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
          const gpuBindGroup = device.createBindGroup({
            layout,
            entries
          });
          this._hash[group._key] = gpuBindGroup;
          return gpuBindGroup;
        }
        destroy() {
          for (const key of Object.keys(this._hash)) {
            this._hash[key] = null;
          }
          this._hash = null;
          this._renderer = null;
        }
      };
      BindGroupSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "bindGroup"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
  var GpuBufferSystem;
  var init_GpuBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
      init_Extensions();
      init_fastCopy();
      GpuBufferSystem = class {
        constructor() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._managedBuffers = [];
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        getGPUBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        }
        updateBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
          const data = buffer.data;
          if (buffer._updateID && data) {
            buffer._updateID = 0;
            this._gpu.device.queue.writeBuffer(
              gpuBuffer,
              0,
              data.buffer,
              0,
              (buffer._updateSize || data.byteLength) + 3 & ~3
            );
          }
          return gpuBuffer;
        }
        destroyAll() {
          for (const id in this._gpuBuffers) {
            this._gpuBuffers[id].destroy();
          }
          this._gpuBuffers = {};
        }
        createGPUBuffer(buffer) {
          if (!this._gpuBuffers[buffer.uid]) {
            buffer.on("update", this.updateBuffer, this);
            buffer.on("change", this.onBufferChange, this);
            buffer.on("destroy", this.onBufferDestroy, this);
            this._managedBuffers.push(buffer);
          }
          const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
          buffer._updateID = 0;
          if (buffer.data) {
            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
            gpuBuffer.unmap();
          }
          this._gpuBuffers[buffer.uid] = gpuBuffer;
          return gpuBuffer;
        }
        onBufferChange(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer._updateID = 0;
          this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
        }
        onBufferDestroy(buffer) {
          this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
          this._destroyBuffer(buffer);
        }
        destroy() {
          this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
          this._managedBuffers = null;
          this._gpuBuffers = null;
        }
        _destroyBuffer(buffer) {
          const gpuBuffer = this._gpuBuffers[buffer.uid];
          gpuBuffer.destroy();
          buffer.off("update", this.updateBuffer, this);
          buffer.off("change", this.onBufferChange, this);
          buffer.off("destroy", this.onBufferDestroy, this);
          this._gpuBuffers[buffer.uid] = null;
        }
      };
      GpuBufferSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
  var GpuColorMaskSystem;
  var init_GpuColorMaskSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
      init_Extensions();
      GpuColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.pipeline.setColorMask(colorMask);
        }
        destroy() {
          this._renderer = null;
          this._colorMaskCache = null;
        }
      };
      GpuColorMaskSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
  var GpuDeviceSystem;
  var init_GpuDeviceSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
      init_adapter2();
      init_Extensions();
      GpuDeviceSystem = class {
        constructor(renderer) {
          this._renderer = renderer;
        }
        async init(options) {
          if (this._initPromise)
            return this._initPromise;
          this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {
            this.gpu = gpu;
            this._renderer.runners.contextChange.emit(this.gpu);
          });
          return this._initPromise;
        }
        contextChange(gpu) {
          this._renderer.gpu = gpu;
        }
        async _createDeviceAndAdaptor(options) {
          const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
            powerPreference: options.powerPreference,
            forceFallbackAdapter: options.forceFallbackAdapter
          });
          const requiredFeatures = [
            "texture-compression-bc",
            "texture-compression-astc",
            "texture-compression-etc2"
          ].filter((feature) => adapter.features.has(feature));
          const device = await adapter.requestDevice({
            requiredFeatures
          });
          return { adapter, device };
        }
        destroy() {
          this.gpu = null;
          this._renderer = null;
        }
      };
      GpuDeviceSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "device"
      };
      GpuDeviceSystem.defaultOptions = {
        powerPreference: void 0,
        forceFallbackAdapter: false
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
  var GpuEncoderSystem;
  var init_GpuEncoderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
      init_Extensions();
      GpuEncoderSystem = class {
        constructor(renderer) {
          this._boundBindGroup = /* @__PURE__ */ Object.create(null);
          this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        renderStart() {
          this.commandFinished = new Promise((resolve2) => {
            this._resolveCommandFinished = resolve2;
          });
          this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        }
        beginRenderPass(gpuRenderTarget) {
          this.endRenderPass();
          this._clearCache();
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
        }
        endRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
          }
          this.renderPassEncoder = null;
        }
        setViewport(viewport) {
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        }
        setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
          const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
          this.setPipeline(pipeline);
        }
        setPipeline(pipeline) {
          if (this._boundPipeline === pipeline)
            return;
          this._boundPipeline = pipeline;
          this.renderPassEncoder.setPipeline(pipeline);
        }
        _setVertexBuffer(index, buffer) {
          if (this._boundVertexBuffer[index] === buffer)
            return;
          this._boundVertexBuffer[index] = buffer;
          this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
        }
        _setIndexBuffer(buffer) {
          if (this._boundIndexBuffer === buffer)
            return;
          this._boundIndexBuffer = buffer;
          const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
          this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
        }
        resetBindGroup(index) {
          this._boundBindGroup[index] = null;
        }
        setBindGroup(index, bindGroup, program) {
          if (this._boundBindGroup[index] === bindGroup)
            return;
          this._boundBindGroup[index] = bindGroup;
          bindGroup._touch(this._renderer.textureGC.count);
          const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
          this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
        }
        setGeometry(geometry, program) {
          const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
          for (const i2 in buffersToBind) {
            this._setVertexBuffer(i2, geometry.attributes[buffersToBind[i2]].buffer);
          }
          if (geometry.indexBuffer) {
            this._setIndexBuffer(geometry.indexBuffer);
          }
        }
        _setShaderBindGroups(shader, skipSync) {
          for (const i2 in shader.groups) {
            const bindGroup = shader.groups[i2];
            if (!skipSync) {
              this._syncBindGroup(bindGroup);
            }
            this.setBindGroup(i2, bindGroup, shader.gpuProgram);
          }
        }
        _syncBindGroup(bindGroup) {
          for (const j2 in bindGroup.resources) {
            const resource = bindGroup.resources[j2];
            if (resource.isUniformGroup) {
              this._renderer.ubo.updateUniformGroup(resource);
            }
          }
        }
        draw(options) {
          const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
          this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
          this.setGeometry(geometry, shader.gpuProgram);
          this._setShaderBindGroups(shader, skipSync);
          if (geometry.indexBuffer) {
            this.renderPassEncoder.drawIndexed(
              size || geometry.indexBuffer.data.length,
              instanceCount || geometry.instanceCount,
              start || 0
            );
          } else {
            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);
          }
        }
        finishRenderPass() {
          if (this.renderPassEncoder) {
            this.renderPassEncoder.end();
            this.renderPassEncoder = null;
          }
        }
        postrender() {
          this.finishRenderPass();
          this._gpu.device.queue.submit([this.commandEncoder.finish()]);
          this._resolveCommandFinished();
          this.commandEncoder = null;
        }
        restoreRenderPass() {
          const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
            this._renderer.renderTarget.renderTarget,
            false,
            [0, 0, 0, 1]
          );
          this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
          const boundPipeline = this._boundPipeline;
          const boundVertexBuffer = { ...this._boundVertexBuffer };
          const boundIndexBuffer = this._boundIndexBuffer;
          const boundBindGroup = { ...this._boundBindGroup };
          this._clearCache();
          const viewport = this._renderer.renderTarget.viewport;
          this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          this.setPipeline(boundPipeline);
          for (const i2 in boundVertexBuffer) {
            this._setVertexBuffer(i2, boundVertexBuffer[i2]);
          }
          for (const i2 in boundBindGroup) {
            this.setBindGroup(i2, boundBindGroup[i2], null);
          }
          this._setIndexBuffer(boundIndexBuffer);
        }
        _clearCache() {
          for (let i2 = 0; i2 < 16; i2++) {
            this._boundBindGroup[i2] = null;
            this._boundVertexBuffer[i2] = null;
          }
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        destroy() {
          this._renderer = null;
          this._gpu = null;
          this._boundBindGroup = null;
          this._boundVertexBuffer = null;
          this._boundIndexBuffer = null;
          this._boundPipeline = null;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
      };
      GpuEncoderSystem.extension = {
        type: [ExtensionType2.WebGPUSystem],
        name: "encoder",
        priority: 1
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
  var GpuStencilSystem;
  var init_GpuStencilSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
      init_Extensions();
      init_const9();
      GpuStencilSystem = class {
        constructor(renderer) {
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(renderTarget) {
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this._activeRenderTarget = renderTarget;
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          const renderer = this._renderer;
          renderer.pipeline.setStencilMode(stencilMode);
          renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
        }
        destroy() {
          this._renderer.renderTarget.onRenderTargetChange.remove(this);
          this._renderer = null;
          this._activeRenderTarget = null;
          this._renderTargetStencilState = null;
        }
      };
      GpuStencilSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UboSystem.mjs
  var UboSystem;
  var init_UboSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
      init_unsafeEvalSupported2();
      init_Buffer2();
      init_const10();
      UboSystem = class {
        constructor(adaptor) {
          this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
          this._adaptor = adaptor;
          this._systemCheck();
        }
        _systemCheck() {
          if (!unsafeEvalSupported2()) {
            throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
          }
        }
        ensureUniformGroup(uniformGroup) {
          const uniformData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer3({
            data: new Float32Array(uniformData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
        }
        getUniformGroupData(uniformGroup) {
          return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
        }
        _initUniformGroup(uniformGroup) {
          const uniformGroupSignature = uniformGroup._signature;
          let uniformData = this._syncFunctionHash[uniformGroupSignature];
          if (!uniformData) {
            const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
            const layout = this._adaptor.createUboElements(elements);
            const syncFunction = this._generateUboSync(layout.uboElements);
            uniformData = this._syncFunctionHash[uniformGroupSignature] = {
              layout,
              syncFunction
            };
          }
          return this._syncFunctionHash[uniformGroupSignature];
        }
        _generateUboSync(uboElements) {
          return this._adaptor.generateUboSync(uboElements);
        }
        syncUniformGroup(uniformGroup, data, offset) {
          const uniformGroupData = this.getUniformGroupData(uniformGroup);
          uniformGroup.buffer || (uniformGroup.buffer = new Buffer3({
            data: new Float32Array(uniformGroupData.layout.size / 4),
            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
          }));
          data || (data = uniformGroup.buffer.data);
          offset || (offset = 0);
          uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);
          return true;
        }
        updateUniformGroup(uniformGroup) {
          if (uniformGroup.isStatic && !uniformGroup._dirtyId)
            return false;
          uniformGroup._dirtyId = 0;
          const synced = this.syncUniformGroup(uniformGroup);
          uniformGroup.buffer.update();
          return synced;
        }
        destroy() {
          this._syncFunctionHash = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
  function createUboElementsWGSL(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
      const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
      if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
        throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, align) * uboElement.data.size;
      }
      offset = Math.ceil(offset / align) * align;
      uboElement.size = size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_ALIGN_SIZE_DATA;
  var init_createUboElementsWGSL = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
      "use strict";
      WGSL_ALIGN_SIZE_DATA = {
        i32: { align: 4, size: 4 },
        u32: { align: 4, size: 4 },
        f32: { align: 4, size: 4 },
        f16: { align: 2, size: 2 },
        "vec2<i32>": { align: 8, size: 8 },
        "vec2<u32>": { align: 8, size: 8 },
        "vec2<f32>": { align: 8, size: 8 },
        "vec2<f16>": { align: 4, size: 4 },
        "vec3<i32>": { align: 16, size: 12 },
        "vec3<u32>": { align: 16, size: 12 },
        "vec3<f32>": { align: 16, size: 12 },
        "vec3<f16>": { align: 8, size: 6 },
        "vec4<i32>": { align: 16, size: 16 },
        "vec4<u32>": { align: 16, size: 16 },
        "vec4<f32>": { align: 16, size: 16 },
        "vec4<f16>": { align: 8, size: 8 },
        "mat2x2<f32>": { align: 8, size: 16 },
        "mat2x2<f16>": { align: 4, size: 8 },
        "mat3x2<f32>": { align: 8, size: 24 },
        "mat3x2<f16>": { align: 4, size: 12 },
        "mat4x2<f32>": { align: 8, size: 32 },
        "mat4x2<f16>": { align: 4, size: 16 },
        "mat2x3<f32>": { align: 16, size: 32 },
        "mat2x3<f16>": { align: 8, size: 16 },
        "mat3x3<f32>": { align: 16, size: 48 },
        "mat3x3<f16>": { align: 8, size: 24 },
        "mat4x3<f32>": { align: 16, size: 64 },
        "mat4x3<f16>": { align: 8, size: 32 },
        "mat2x4<f32>": { align: 16, size: 32 },
        "mat2x4<f16>": { align: 8, size: 16 },
        "mat3x4<f32>": { align: 16, size: 48 },
        "mat3x4<f16>": { align: 8, size: 24 },
        "mat4x4<f32>": { align: 16, size: 64 },
        "mat4x4<f16>": { align: 8, size: 32 }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
  var uniformParsers2;
  var init_uniformParsers2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
      "use strict";
      uniformParsers2 = [
        {
          type: "mat3x3<f32>",
          test: (data) => {
            const value = data.value;
            return value.a !== void 0;
          },
          ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
          uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
        },
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
        },
        {
          type: "vec2<f32>",
          test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
        },
        {
          type: "vec4<f32>",
          test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
        },
        {
          type: "vec3<f32>",
          test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
          ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
          uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
        }
      ];
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
  function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
    const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let prev = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      const name = uboElement.data.name;
      let parsed = false;
      let offset = 0;
      for (let j2 = 0; j2 < uniformParsers2.length; j2++) {
        const uniformParser = uniformParsers2[j2];
        if (uniformParser.test(uboElement.data)) {
          offset = uboElement.offset / 4;
          funcFragments.push(
            `name = "${name}";`,
            `offset += ${offset - prev};`,
            uniformParsers2[j2][parserCode] || uniformParsers2[j2].ubo
          );
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        if (uboElement.data.size > 1) {
          offset = uboElement.offset / 4;
          funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
        } else {
          const template = singleSettersMap[uboElement.data.type];
          offset = uboElement.offset / 4;
          funcFragments.push(
            `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
          );
        }
      }
      prev = offset;
    }
    const fragmentSrc = funcFragments.join("\n");
    return new Function(
      "uv",
      "data",
      "offset",
      fragmentSrc
    );
  }
  var init_createUboSyncFunction = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
      init_uniformParsers2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
  function loopMatrix(col, row) {
    const total = col * row;
    return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
  }
  var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
  var init_uboSyncFunctions = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
      "use strict";
      uboSyncFunctionsSTD40 = {
        f32: `
        data[offset] = v;`,
        i32: `
        data[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": loopMatrix(3, 2),
        "mat4x2<f32>": loopMatrix(4, 2),
        "mat2x3<f32>": loopMatrix(2, 3),
        "mat4x3<f32>": loopMatrix(4, 3),
        "mat2x4<f32>": loopMatrix(2, 4),
        "mat3x4<f32>": loopMatrix(3, 4)
      };
      uboSyncFunctionsWGSL = {
        ...uboSyncFunctionsSTD40,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
  function generateArraySyncWGSL(uboElement, offsetToAdd) {
    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
    const remainder = (align - size) / 4;
    return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
  }
  var init_generateArraySyncWGSL = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
      init_createUboElementsWGSL();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
  function createUboSyncFunctionWGSL(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboWgsl",
      generateArraySyncWGSL,
      uboSyncFunctionsWGSL
    );
  }
  var init_createUboSyncFunctionWGSL = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncWGSL();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUboSystem.mjs
  var GpuUboSystem;
  var init_GpuUboSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsWGSL();
      init_createUboSyncFunctionWGSL();
      GpuUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsWGSL,
            generateUboSync: createUboSyncFunctionWGSL
          });
        }
      };
      GpuUboSystem.extension = {
        type: [ExtensionType2.WebGPUSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/BufferResource.mjs
  var BufferResource2;
  var init_BufferResource2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
      init_eventemitter3();
      init_uid2();
      BufferResource2 = class extends eventemitter3_default {
        constructor({ buffer, offset, size }) {
          super();
          this.uid = uid2("buffer");
          this._resourceType = "bufferResource";
          this._touched = 0;
          this._resourceId = uid2("resource");
          this._bufferResource = true;
          this.destroyed = false;
          this.buffer = buffer;
          this.offset = offset | 0;
          this.size = size;
          this.buffer.on("change", this.onBufferChange, this);
        }
        onBufferChange() {
          this._resourceId = uid2("resource");
          this.emit("change", this);
        }
        destroy(destroyBuffer = false) {
          this.destroyed = true;
          if (destroyBuffer) {
            this.buffer.destroy();
          }
          this.emit("change", this);
          this.buffer = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
  var UboBatch;
  var init_UboBatch = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
      "use strict";
      UboBatch = class {
        constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
          this._minUniformOffsetAlignment = 256;
          this.byteIndex = 0;
          this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
          this.data = new Float32Array(65535);
        }
        clear() {
          this.byteIndex = 0;
        }
        addEmptyGroup(size) {
          if (size > this._minUniformOffsetAlignment / 4) {
            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
          }
          const start = this.byteIndex;
          let newSize = start + size * 4;
          newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
          if (newSize > this.data.length * 4) {
            throw new Error("UniformBufferBatch: ubo batch got too big");
          }
          this.byteIndex = newSize;
          return start;
        }
        addGroup(array) {
          const offset = this.addEmptyGroup(array.length);
          for (let i2 = 0; i2 < array.length; i2++) {
            this.data[offset / 4 + i2] = array[i2];
          }
          return offset;
        }
        destroy() {
          this._buffer.destroy();
          this._buffer = null;
          this.data = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
  var minUniformOffsetAlignment, GpuUniformBatchPipe;
  var init_GpuUniformBatchPipe = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
      init_Extensions();
      init_Buffer2();
      init_BufferResource2();
      init_const10();
      init_UboBatch();
      init_BindGroup();
      minUniformOffsetAlignment = 128;
      GpuUniformBatchPipe = class {
        constructor(renderer) {
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._buffers = [];
          this._bindGroups = [];
          this._bufferResources = [];
          this._renderer = renderer;
          this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
          const totalBuffers = 256 / minUniformOffsetAlignment;
          for (let i2 = 0; i2 < totalBuffers; i2++) {
            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
            if (i2 === 0)
              usage |= BufferUsage.COPY_SRC;
            this._buffers.push(new Buffer3({
              data: this._batchBuffer.data,
              usage
            }));
          }
        }
        renderEnd() {
          this._uploadBindGroups();
          this._resetBindGroups();
        }
        _resetBindGroups() {
          for (const i2 in this._bindGroupHash) {
            this._bindGroupHash[i2] = null;
          }
          this._batchBuffer.clear();
        }
        getUniformBindGroup(group, duplicate) {
          if (!duplicate && this._bindGroupHash[group.uid]) {
            return this._bindGroupHash[group.uid];
          }
          this._renderer.ubo.ensureUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addEmptyGroup(data.length);
          this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
          this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
          return this._bindGroupHash[group.uid];
        }
        getUboResource(group) {
          this._renderer.ubo.updateUniformGroup(group);
          const data = group.buffer.data;
          const offset = this._batchBuffer.addGroup(data);
          return this._getBufferResource(offset / minUniformOffsetAlignment);
        }
        getArrayBindGroup(data) {
          const offset = this._batchBuffer.addGroup(data);
          return this._getBindGroup(offset / minUniformOffsetAlignment);
        }
        getArrayBufferResource(data) {
          const offset = this._batchBuffer.addGroup(data);
          const index = offset / minUniformOffsetAlignment;
          return this._getBufferResource(index);
        }
        _getBufferResource(index) {
          if (!this._bufferResources[index]) {
            const buffer = this._buffers[index % 2];
            this._bufferResources[index] = new BufferResource2({
              buffer,
              offset: (index / 2 | 0) * 256,
              size: minUniformOffsetAlignment
            });
          }
          return this._bufferResources[index];
        }
        _getBindGroup(index) {
          if (!this._bindGroups[index]) {
            const bindGroup = new BindGroup({
              0: this._getBufferResource(index)
            });
            this._bindGroups[index] = bindGroup;
          }
          return this._bindGroups[index];
        }
        _uploadBindGroups() {
          const bufferSystem = this._renderer.buffer;
          const firstBuffer = this._buffers[0];
          firstBuffer.update(this._batchBuffer.byteIndex);
          bufferSystem.updateBuffer(firstBuffer);
          const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
          for (let i2 = 1; i2 < this._buffers.length; i2++) {
            const buffer = this._buffers[i2];
            commandEncoder.copyBufferToBuffer(
              bufferSystem.getGPUBuffer(firstBuffer),
              minUniformOffsetAlignment,
              bufferSystem.getGPUBuffer(buffer),
              0,
              this._batchBuffer.byteIndex
            );
          }
          this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        }
        destroy() {
          for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
            this._bindGroups[i2].destroy();
          }
          this._bindGroups = null;
          this._bindGroupHash = null;
          for (let i2 = 0; i2 < this._buffers.length; i2++) {
            this._buffers[i2].destroy();
          }
          this._buffers = null;
          for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
            this._bufferResources[i2].destroy();
          }
          this._bufferResources = null;
          this._batchBuffer.destroy();
          this._bindGroupHash = null;
          this._renderer = null;
        }
      };
      GpuUniformBatchPipe.extension = {
        type: [
          ExtensionType2.WebGPUPipes
        ],
        name: "uniformBatch"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
  function ensureAttributes(geometry, extractedData) {
    for (const i2 in geometry.attributes) {
      const attribute = geometry.attributes[i2];
      const attributeData = extractedData[i2];
      if (attributeData) {
        attribute.format ?? (attribute.format = attributeData.format);
        attribute.offset ?? (attribute.offset = attributeData.offset);
        attribute.instance ?? (attribute.instance = attributeData.instance);
      } else {
        warn(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
      }
    }
    ensureStartAndStride(geometry);
  }
  function ensureStartAndStride(geometry) {
    const { buffers, attributes } = geometry;
    const tempStride = {};
    const tempStart = {};
    for (const j2 in buffers) {
      const buffer = buffers[j2];
      tempStride[buffer.uid] = 0;
      tempStart[buffer.uid] = 0;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
    for (const j2 in attributes) {
      const attribute = attributes[j2];
      attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
      attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
      tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
    }
  }
  var init_ensureAttributes = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
      init_warn();
      init_getAttributeInfoFromFormat();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
  var GpuStencilModesToPixi;
  var init_GpuStencilModesToPixi = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
      init_const9();
      GpuStencilModesToPixi = [];
      GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
      GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
        stencilWriteMask: 0,
        stencilReadMask: 0
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
        stencilFront: {
          compare: "equal",
          passOp: "increment-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "increment-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
        stencilFront: {
          compare: "equal",
          passOp: "decrement-clamp"
        },
        stencilBack: {
          compare: "equal",
          passOp: "decrement-clamp"
        }
      };
      GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
        stencilWriteMask: 0,
        stencilFront: {
          compare: "equal",
          passOp: "keep"
        },
        stencilBack: {
          compare: "equal",
          passOp: "keep"
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
  function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
  }
  function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
  }
  var topologyStringToId, PipelineSystem;
  var init_PipelineSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_ensureAttributes();
      init_const9();
      init_createIdFromString();
      init_GpuStencilModesToPixi();
      topologyStringToId = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 2,
        "triangle-list": 3,
        "triangle-strip": 4
      };
      PipelineSystem = class {
        constructor(renderer) {
          this._moduleCache = /* @__PURE__ */ Object.create(null);
          this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
          this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
          this._pipeCache = /* @__PURE__ */ Object.create(null);
          this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
          this._colorMask = 15;
          this._multisampleCount = 1;
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.setStencilMode(STENCIL_MODES.DISABLED);
          this._updatePipeHash();
        }
        setMultisampleCount(multisampleCount) {
          if (this._multisampleCount === multisampleCount)
            return;
          this._multisampleCount = multisampleCount;
          this._updatePipeHash();
        }
        setRenderTarget(renderTarget) {
          this._multisampleCount = renderTarget.msaaSamples;
          this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
          this._updatePipeHash();
        }
        setColorMask(colorMask) {
          if (this._colorMask === colorMask)
            return;
          this._colorMask = colorMask;
          this._updatePipeHash();
        }
        setStencilMode(stencilMode) {
          if (this._stencilMode === stencilMode)
            return;
          this._stencilMode = stencilMode;
          this._stencilState = GpuStencilModesToPixi[stencilMode];
          this._updatePipeHash();
        }
        setPipeline(geometry, program, state, passEncoder) {
          const pipeline = this.getPipeline(geometry, program, state);
          passEncoder.setPipeline(pipeline);
        }
        getPipeline(geometry, program, state, topology) {
          if (!geometry._layoutKey) {
            ensureAttributes(geometry, program.attributeData);
            this._generateBufferKey(geometry);
          }
          topology = topology || geometry.topology;
          const key = getGraphicsStateKey(
            geometry._layoutKey,
            program._layoutKey,
            state.data,
            state._blendModeId,
            topologyStringToId[topology]
          );
          if (this._pipeCache[key])
            return this._pipeCache[key];
          this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
          return this._pipeCache[key];
        }
        _createPipeline(geometry, program, state, topology) {
          const device = this._gpu.device;
          const buffers = this._createVertexBufferLayouts(geometry, program);
          const blendModes = this._renderer.state.getColorTargets(state);
          blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
          const layout = this._renderer.shader.getProgramData(program).pipeline;
          const descriptor = {
            vertex: {
              module: this._getModule(program.vertex.source),
              entryPoint: program.vertex.entryPoint,
              buffers
            },
            fragment: {
              module: this._getModule(program.fragment.source),
              entryPoint: program.fragment.entryPoint,
              targets: blendModes
            },
            primitive: {
              topology,
              cullMode: state.cullMode
            },
            layout,
            multisample: {
              count: this._multisampleCount
            },
            label: `PIXI Pipeline`
          };
          if (this._depthStencilAttachment) {
            descriptor.depthStencil = {
              ...this._stencilState,
              format: "depth24plus-stencil8",
              depthWriteEnabled: state.depthTest,
              depthCompare: state.depthTest ? "less" : "always"
            };
          }
          const pipeline = device.createRenderPipeline(descriptor);
          return pipeline;
        }
        _getModule(code) {
          return this._moduleCache[code] || this._createModule(code);
        }
        _createModule(code) {
          const device = this._gpu.device;
          this._moduleCache[code] = device.createShaderModule({
            code
          });
          return this._moduleCache[code];
        }
        _generateBufferKey(geometry) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(geometry.attributes).sort();
          for (let i2 = 0; i2 < attributeKeys.length; i2++) {
            const attribute = geometry.attributes[attributeKeys[i2]];
            keyGen[index++] = attribute.offset;
            keyGen[index++] = attribute.format;
            keyGen[index++] = attribute.stride;
            keyGen[index++] = attribute.instance;
          }
          const stringKey = keyGen.join("|");
          geometry._layoutKey = createIdFromString(stringKey, "geometry");
          return geometry._layoutKey;
        }
        _generateAttributeLocationsKey(program) {
          const keyGen = [];
          let index = 0;
          const attributeKeys = Object.keys(program.attributeData).sort();
          for (let i2 = 0; i2 < attributeKeys.length; i2++) {
            const attribute = program.attributeData[attributeKeys[i2]];
            keyGen[index++] = attribute.location;
          }
          const stringKey = keyGen.join("|");
          program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
          return program._attributeLocationsKey;
        }
        getBufferNamesToBind(geometry, program) {
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bindingNamesCache[key])
            return this._bindingNamesCache[key];
          const data = this._createVertexBufferLayouts(geometry, program);
          const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
          const attributeData = program.attributeData;
          for (let i2 = 0; i2 < data.length; i2++) {
            for (const j2 in attributeData) {
              if (attributeData[j2].location === i2) {
                bufferNamesToBind[i2] = j2;
                break;
              }
            }
          }
          this._bindingNamesCache[key] = bufferNamesToBind;
          return bufferNamesToBind;
        }
        _createVertexBufferLayouts(geometry, program) {
          if (!program._attributeLocationsKey)
            this._generateAttributeLocationsKey(program);
          const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
          if (this._bufferLayoutsCache[key]) {
            return this._bufferLayoutsCache[key];
          }
          const vertexBuffersLayout = [];
          geometry.buffers.forEach((buffer) => {
            const bufferEntry = {
              arrayStride: 0,
              stepMode: "vertex",
              attributes: []
            };
            const bufferEntryAttributes = bufferEntry.attributes;
            for (const i2 in program.attributeData) {
              const attribute = geometry.attributes[i2];
              if ((attribute.divisor ?? 1) !== 1) {
                warn(`Attribute ${i2} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
              }
              if (attribute.buffer === buffer) {
                bufferEntry.arrayStride = attribute.stride;
                bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
                bufferEntryAttributes.push({
                  shaderLocation: program.attributeData[i2].location,
                  offset: attribute.offset,
                  format: attribute.format
                });
              }
            }
            if (bufferEntryAttributes.length) {
              vertexBuffersLayout.push(bufferEntry);
            }
          });
          this._bufferLayoutsCache[key] = vertexBuffersLayout;
          return vertexBuffersLayout;
        }
        _updatePipeHash() {
          const key = getGlobalStateKey(
            this._stencilMode,
            this._multisampleCount,
            this._colorMask,
            this._depthStencilAttachment
          );
          if (!this._pipeStateCaches[key]) {
            this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
          }
          this._pipeCache = this._pipeStateCaches[key];
        }
        destroy() {
          this._renderer = null;
          this._bufferLayoutsCache = null;
        }
      };
      PipelineSystem.extension = {
        type: [ExtensionType2.WebGPUSystem],
        name: "pipeline"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
  function calculateProjection(pm, x2, y2, width, height, flipY) {
    const sign2 = flipY ? 1 : -1;
    pm.identity();
    pm.a = 1 / width * 2;
    pm.d = sign2 * (1 / height * 2);
    pm.tx = -1 - x2 * pm.a;
    pm.ty = -sign2 - y2 * pm.d;
    return pm;
  }
  var init_calculateProjection = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
  function isRenderingToScreen(renderTarget) {
    const resource = renderTarget.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
  }
  var init_isRenderingToScreen = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
  var RenderTargetSystem;
  var init_RenderTargetSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
      init_Matrix2();
      init_Rectangle2();
      init_const13();
      init_calculateProjection();
      init_SystemRunner();
      init_CanvasSource();
      init_TextureSource();
      init_Texture2();
      init_getCanvasTexture();
      init_isRenderingToScreen();
      init_RenderTarget();
      RenderTargetSystem = class {
        constructor(renderer) {
          this.rootViewPort = new Rectangle2();
          this.viewport = new Rectangle2();
          this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
          this.projectionMatrix = new Matrix2();
          this.defaultClearColor = [0, 0, 0, 0];
          this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
          this._renderTargetStack = [];
          this._renderer = renderer;
        }
        finishRenderPass() {
          this.adaptor.finishRenderPass(this.renderTarget);
        }
        renderStart({
          target,
          clear,
          clearColor,
          frame
        }) {
          this._renderTargetStack.length = 0;
          this.push(
            target,
            clear,
            clearColor,
            frame
          );
          this.rootViewPort.copyFrom(this.viewport);
          this.rootRenderTarget = this.renderTarget;
          this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        }
        postrender() {
          this.adaptor.postrender?.(this.rootRenderTarget);
        }
        bind(renderSurface, clear = true, clearColor, frame) {
          const renderTarget = this.getRenderTarget(renderSurface);
          const didChange = this.renderTarget !== renderTarget;
          this.renderTarget = renderTarget;
          this.renderSurface = renderSurface;
          const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
          if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
            this.adaptor.resizeGpuRenderTarget(renderTarget);
            gpuRenderTarget.width = renderTarget.pixelWidth;
            gpuRenderTarget.height = renderTarget.pixelHeight;
          }
          const source2 = renderTarget.colorTexture;
          const viewport = this.viewport;
          const pixelWidth = source2.pixelWidth;
          const pixelHeight = source2.pixelHeight;
          if (!frame && renderSurface instanceof Texture2) {
            frame = renderSurface.frame;
          }
          if (frame) {
            const resolution = source2._resolution;
            viewport.x = frame.x * resolution + 0.5 | 0;
            viewport.y = frame.y * resolution + 0.5 | 0;
            viewport.width = frame.width * resolution + 0.5 | 0;
            viewport.height = frame.height * resolution + 0.5 | 0;
          } else {
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = pixelWidth;
            viewport.height = pixelHeight;
          }
          calculateProjection(
            this.projectionMatrix,
            0,
            0,
            viewport.width / source2.resolution,
            viewport.height / source2.resolution,
            !renderTarget.isRoot
          );
          this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
          if (didChange) {
            this.onRenderTargetChange.emit(renderTarget);
          }
          return renderTarget;
        }
        clear(target, clear = CLEAR.ALL, clearColor) {
          if (!clear)
            return;
          if (target) {
            target = this.getRenderTarget(target);
          }
          this.adaptor.clear(
            target || this.renderTarget,
            clear,
            clearColor,
            this.viewport
          );
        }
        contextChange() {
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
          const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
          this._renderTargetStack.push({
            renderTarget,
            frame
          });
          return renderTarget;
        }
        pop() {
          this._renderTargetStack.pop();
          const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
          this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
        }
        getRenderTarget(renderSurface) {
          if (renderSurface.isTexture) {
            renderSurface = renderSurface.source;
          }
          return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          if (originSrc.x < 0) {
            size.width += originSrc.x;
            originDest.x -= originSrc.x;
            originSrc.x = 0;
          }
          if (originSrc.y < 0) {
            size.height += originSrc.y;
            originDest.y -= originSrc.y;
            originSrc.y = 0;
          }
          const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
          size.width = Math.min(size.width, pixelWidth - originSrc.x);
          size.height = Math.min(size.height, pixelHeight - originSrc.y);
          return this.adaptor.copyToTexture(
            sourceRenderSurfaceTexture,
            destinationTexture,
            originSrc,
            size,
            originDest
          );
        }
        ensureDepthStencil() {
          if (!this.renderTarget.stencil) {
            this.renderTarget.stencil = true;
            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
          }
        }
        destroy() {
          this._renderer = null;
          this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
            if (renderTarget !== key) {
              renderTarget.destroy();
            }
          });
          this._renderSurfaceToRenderTargetHash.clear();
          this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        }
        _initRenderTarget(renderSurface) {
          let renderTarget = null;
          if (CanvasSource.test(renderSurface)) {
            renderSurface = getCanvasTexture(renderSurface).source;
          }
          if (renderSurface instanceof RenderTarget) {
            renderTarget = renderSurface;
          } else if (renderSurface instanceof TextureSource) {
            renderTarget = new RenderTarget({
              colorTextures: [renderSurface]
            });
            if (CanvasSource.test(renderSurface.source.resource)) {
              renderTarget.isRoot = true;
            }
            renderSurface.once("destroy", () => {
              renderTarget.destroy();
              this._renderSurfaceToRenderTargetHash.delete(renderSurface);
              const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
              if (gpuRenderTarget) {
                this._gpuRenderTargetHash[renderTarget.uid] = null;
                this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
              }
            });
          }
          this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
          return renderTarget;
        }
        getGpuRenderTarget(renderTarget) {
          return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
  var GpuRenderTarget;
  var init_GpuRenderTarget = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
      "use strict";
      GpuRenderTarget = class {
        constructor() {
          this.contexts = [];
          this.msaaTextures = [];
          this.msaaSamples = 1;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
  var GpuRenderTargetAdaptor;
  var init_GpuRenderTargetAdaptor = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
      init_const13();
      init_CanvasSource();
      init_TextureSource();
      init_GpuRenderTarget();
      GpuRenderTargetAdaptor = class {
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderer = this._renderer;
          const baseGpuTexture = this._getGpuColorTexture(
            sourceRenderSurfaceTexture
          );
          const backGpuTexture = renderer.texture.getGpuSource(
            destinationTexture.source
          );
          renderer.encoder.commandEncoder.copyTextureToTexture(
            {
              texture: baseGpuTexture,
              origin: originSrc
            },
            {
              texture: backGpuTexture,
              origin: originDest
            },
            size
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
          gpuRenderTarget.descriptor = descriptor;
          this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
          this._renderer.encoder.beginRenderPass(gpuRenderTarget);
          this._renderer.encoder.setViewport(viewport);
        }
        finishRenderPass() {
          this._renderer.encoder.endRenderPass();
        }
        _getGpuColorTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (gpuRenderTarget.contexts[0]) {
            return gpuRenderTarget.contexts[0].getCurrentTexture();
          }
          return this._renderer.texture.getGpuSource(
            renderTarget.colorTextures[0].source
          );
        }
        getDescriptor(renderTarget, clear, clearValue) {
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const renderTargetSystem = this._renderTargetSystem;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          const colorAttachments = renderTarget.colorTextures.map(
            (texture, i2) => {
              const context3 = gpuRenderTarget.contexts[i2];
              let view;
              let resolveTarget;
              if (context3) {
                const currentTexture = context3.getCurrentTexture();
                const canvasTextureView = currentTexture.createView();
                view = canvasTextureView;
              } else {
                view = this._renderer.texture.getGpuSource(texture).createView({
                  mipLevelCount: 1
                });
              }
              if (gpuRenderTarget.msaaTextures[i2]) {
                resolveTarget = view;
                view = this._renderer.texture.getTextureView(
                  gpuRenderTarget.msaaTextures[i2]
                );
              }
              const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
              clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
              return {
                view,
                resolveTarget,
                clearValue,
                storeOp: "store",
                loadOp
              };
            }
          );
          let depthStencilAttachment;
          if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
            renderTarget.ensureDepthStencilTexture();
            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
          }
          if (renderTarget.depthStencilTexture) {
            const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
            const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
            depthStencilAttachment = {
              view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
              stencilStoreOp: "store",
              stencilLoadOp,
              depthClearValue: 1,
              depthLoadOp,
              depthStoreOp: "store"
            };
          }
          const descriptor = {
            colorAttachments,
            depthStencilAttachment
          };
          return descriptor;
        }
        clear(renderTarget, clear = true, clearColor, viewport) {
          if (!clear)
            return;
          const { gpu, encoder } = this._renderer;
          const device = gpu.device;
          const standAlone = encoder.commandEncoder === null;
          if (standAlone) {
            const commandEncoder = device.createCommandEncoder();
            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
            passEncoder.end();
            const gpuCommands = commandEncoder.finish();
            device.queue.submit([gpuCommands]);
          } else {
            this.startRenderPass(renderTarget, clear, clearColor, viewport);
          }
        }
        initGpuRenderTarget(renderTarget) {
          renderTarget.isRoot = true;
          const gpuRenderTarget = new GpuRenderTarget();
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (CanvasSource.test(colorTexture.resource)) {
              const context3 = colorTexture.resource.getContext(
                "webgpu"
              );
              const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
              try {
                context3.configure({
                  device: this._renderer.gpu.device,
                  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                  format: "bgra8unorm",
                  alphaMode
                });
              } catch (e2) {
                console.error(e2);
              }
              gpuRenderTarget.contexts[i2] = context3;
            }
            gpuRenderTarget.msaa = colorTexture.source.antialias;
            if (colorTexture.source.antialias) {
              const msaaTexture = new TextureSource({
                width: 0,
                height: 0,
                sampleCount: 4
              });
              gpuRenderTarget.msaaTextures[i2] = msaaTexture;
            }
          });
          if (gpuRenderTarget.msaa) {
            gpuRenderTarget.msaaSamples = 4;
            if (renderTarget.depthStencilTexture) {
              renderTarget.depthStencilTexture.source.sampleCount = 4;
            }
          }
          return gpuRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          gpuRenderTarget.contexts.forEach((context3) => {
            context3.unconfigure();
          });
          gpuRenderTarget.msaaTextures.forEach((texture) => {
            texture.destroy();
          });
          gpuRenderTarget.msaaTextures.length = 0;
          gpuRenderTarget.contexts.length = 0;
        }
        ensureDepthStencilTexture(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        resizeGpuRenderTarget(renderTarget) {
          const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.width;
          gpuRenderTarget.height = renderTarget.height;
          if (gpuRenderTarget.msaa) {
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const msaaTexture = gpuRenderTarget.msaaTextures[i2];
              msaaTexture?.resize(
                colorTexture.source.width,
                colorTexture.source.height,
                colorTexture.source._resolution
              );
            });
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
  var GpuRenderTargetSystem;
  var init_GpuRenderTargetSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GpuRenderTargetAdaptor();
      GpuRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GpuRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GpuRenderTargetSystem.extension = {
        type: [ExtensionType2.WebGPUSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
  var GpuShaderSystem;
  var init_GpuShaderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
      init_Extensions();
      GpuShaderSystem = class {
        constructor() {
          this._gpuProgramData = /* @__PURE__ */ Object.create(null);
        }
        contextChange(gpu) {
          this._gpu = gpu;
          this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;
        }
        getProgramData(program) {
          return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
        }
        _createGPUProgramData(program) {
          const device = this._gpu.device;
          const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
          const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
          this._gpuProgramData[program._layoutKey] = {
            bindGroups,
            pipeline: device.createPipelineLayout(pipelineLayoutDesc)
          };
          return this._gpuProgramData[program._layoutKey];
        }
        destroy() {
          this._gpu = null;
          this._gpuProgramData = null;
        }
      };
      GpuShaderSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
  var GpuBlendModesToPixi;
  var init_GpuBlendModesToPixi = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
      "use strict";
      GpuBlendModesToPixi = {};
      GpuBlendModesToPixi.normal = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.add = {
        alpha: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.multiply = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "dst",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.screen = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.overlay = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.none = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "zero",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["normal-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["add-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one",
          operation: "add"
        }
      };
      GpuBlendModesToPixi["screen-npm"] = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "src-alpha",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.erase = {
        alpha: {
          srcFactor: "zero",
          dstFactor: "one-minus-src-alpha",
          operation: "add"
        },
        color: {
          srcFactor: "zero",
          dstFactor: "one-minus-src",
          operation: "add"
        }
      };
      GpuBlendModesToPixi.min = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "min"
        }
      };
      GpuBlendModesToPixi.max = {
        alpha: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        },
        color: {
          srcFactor: "one",
          dstFactor: "one",
          operation: "max"
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
  var GpuStateSystem;
  var init_GpuStateSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
      init_Extensions();
      init_State2();
      init_GpuBlendModesToPixi();
      GpuStateSystem = class {
        constructor() {
          this.defaultState = new State2();
          this.defaultState.blend = true;
        }
        contextChange(gpu) {
          this.gpu = gpu;
        }
        getColorTargets(state) {
          const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
          return [
            {
              format: "bgra8unorm",
              writeMask: 0,
              blend
            }
          ];
        }
        destroy() {
          this.gpu = null;
        }
      };
      GpuStateSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "state"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
  var gpuUploadBufferImageResource;
  var init_gpuUploadBufferImageResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
      "use strict";
      gpuUploadBufferImageResource = {
        type: "image",
        upload(source2, gpuTexture, gpu) {
          const resource = source2.resource;
          const total = (source2.pixelWidth | 0) * (source2.pixelHeight | 0);
          const bytesPerPixel = resource.byteLength / total;
          gpu.device.queue.writeTexture(
            { texture: gpuTexture },
            resource,
            {
              offset: 0,
              rowsPerImage: source2.pixelHeight,
              bytesPerRow: source2.pixelHeight * bytesPerPixel
            },
            {
              width: source2.pixelWidth,
              height: source2.pixelHeight,
              depthOrArrayLayers: 1
            }
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
  var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
  var init_gpuUploadCompressedTextureResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
      "use strict";
      blockDataMap = {
        "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
      };
      defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
      gpuUploadCompressedTextureResource = {
        type: "compressed",
        upload(source2, gpuTexture, gpu) {
          let mipWidth = source2.pixelWidth;
          let mipHeight = source2.pixelHeight;
          const blockData = blockDataMap[source2.format] || defaultBlockData;
          for (let i2 = 0; i2 < source2.resource.length; i2++) {
            const levelBuffer = source2.resource[i2];
            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
            gpu.device.queue.writeTexture(
              {
                texture: gpuTexture,
                mipLevel: i2
              },
              levelBuffer,
              {
                offset: 0,
                bytesPerRow
              },
              {
                width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
                height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
                depthOrArrayLayers: 1
              }
            );
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
  var gpuUploadImageResource;
  var init_gpuUploadImageSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
      "use strict";
      gpuUploadImageResource = {
        type: "image",
        upload(source2, gpuTexture, gpu) {
          const resource = source2.resource;
          if (!resource)
            return;
          const width = Math.min(gpuTexture.width, source2.resourceWidth || source2.pixelWidth);
          const height = Math.min(gpuTexture.height, source2.resourceHeight || source2.pixelHeight);
          const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
          gpu.device.queue.copyExternalImageToTexture(
            { source: resource },
            { texture: gpuTexture, premultipliedAlpha },
            {
              width,
              height
            }
          );
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
  var gpuUploadVideoResource;
  var init_gpuUploadVideoSource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
      init_gpuUploadImageSource();
      gpuUploadVideoResource = {
        type: "video",
        upload(source2, gpuTexture, gpu) {
          gpuUploadImageResource.upload(source2, gpuTexture, gpu);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
  var GpuMipmapGenerator;
  var init_GpuMipmapGenerator = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
      "use strict";
      GpuMipmapGenerator = class {
        constructor(device) {
          this.device = device;
          this.sampler = device.createSampler({ minFilter: "linear" });
          this.pipelines = {};
        }
        _getMipmapPipeline(format2) {
          let pipeline = this.pipelines[format2];
          if (!pipeline) {
            if (!this.mipmapShaderModule) {
              this.mipmapShaderModule = this.device.createShaderModule({
                code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              });
            }
            pipeline = this.device.createRenderPipeline({
              layout: "auto",
              vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
              },
              fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{ format: format2 }]
              }
            });
            this.pipelines[format2] = pipeline;
          }
          return pipeline;
        }
        generateMipmap(texture) {
          const pipeline = this._getMipmapPipeline(texture.format);
          if (texture.dimension === "3d" || texture.dimension === "1d") {
            throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
          }
          let mipTexture = texture;
          const arrayLayerCount = texture.depthOrArrayLayers || 1;
          const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
          if (!renderToSource) {
            const mipTextureDescriptor = {
              size: {
                width: Math.ceil(texture.width / 2),
                height: Math.ceil(texture.height / 2),
                depthOrArrayLayers: arrayLayerCount
              },
              format: texture.format,
              usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
              mipLevelCount: texture.mipLevelCount - 1
            };
            mipTexture = this.device.createTexture(mipTextureDescriptor);
          }
          const commandEncoder = this.device.createCommandEncoder({});
          const bindGroupLayout = pipeline.getBindGroupLayout(0);
          for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
            let srcView = texture.createView({
              baseMipLevel: 0,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            let dstMipLevel = renderToSource ? 1 : 0;
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              const dstView = mipTexture.createView({
                baseMipLevel: dstMipLevel++,
                mipLevelCount: 1,
                dimension: "2d",
                baseArrayLayer: arrayLayer,
                arrayLayerCount: 1
              });
              const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [{
                  view: dstView,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 }
                }]
              });
              const bindGroup = this.device.createBindGroup({
                layout: bindGroupLayout,
                entries: [{
                  binding: 0,
                  resource: this.sampler
                }, {
                  binding: 1,
                  resource: srcView
                }]
              });
              passEncoder.setPipeline(pipeline);
              passEncoder.setBindGroup(0, bindGroup);
              passEncoder.draw(3, 1, 0, 0);
              passEncoder.end();
              srcView = dstView;
            }
          }
          if (!renderToSource) {
            const mipLevelSize = {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            };
            for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
              commandEncoder.copyTextureToTexture({
                texture: mipTexture,
                mipLevel: i2 - 1
              }, {
                texture,
                mipLevel: i2
              }, mipLevelSize);
              mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
              mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
            }
          }
          this.device.queue.submit([commandEncoder.finish()]);
          if (!renderToSource) {
            mipTexture.destroy();
          }
          return texture;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
  var GpuTextureSystem;
  var init_GpuTextureSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
      init_adapter2();
      init_Extensions();
      init_UniformGroup2();
      init_CanvasPool();
      init_BindGroup();
      init_gpuUploadBufferImageResource();
      init_gpuUploadCompressedTextureResource();
      init_gpuUploadImageSource();
      init_gpuUploadVideoSource();
      init_GpuMipmapGenerator();
      GpuTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._gpuSources = /* @__PURE__ */ Object.create(null);
          this._gpuSamplers = /* @__PURE__ */ Object.create(null);
          this._bindGroupHash = /* @__PURE__ */ Object.create(null);
          this._textureViewHash = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: gpuUploadImageResource,
            buffer: gpuUploadBufferImageResource,
            video: gpuUploadVideoResource,
            compressed: gpuUploadCompressedTextureResource
          };
          this._renderer = renderer;
        }
        contextChange(gpu) {
          this._gpu = gpu;
        }
        initSource(source2) {
          if (source2.autoGenerateMipmaps) {
            const biggestDimension = Math.max(source2.pixelWidth, source2.pixelHeight);
            source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
          if (source2.uploadMethodId !== "compressed") {
            usage |= GPUTextureUsage.RENDER_ATTACHMENT;
            usage |= GPUTextureUsage.COPY_SRC;
          }
          const blockData = blockDataMap[source2.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
          const width = Math.ceil(source2.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
          const height = Math.ceil(source2.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
          const textureDescriptor = {
            label: source2.label,
            size: { width, height },
            format: source2.format,
            sampleCount: source2.sampleCount,
            mipLevelCount: source2.mipLevelCount,
            dimension: source2.dimension,
            usage
          };
          const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
          this._gpuSources[source2.uid] = gpuTexture;
          if (!this.managedTextures.includes(source2)) {
            source2.on("update", this.onSourceUpdate, this);
            source2.on("resize", this.onSourceResize, this);
            source2.on("destroy", this.onSourceDestroy, this);
            source2.on("unload", this.onSourceUnload, this);
            source2.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source2);
          }
          this.onSourceUpdate(source2);
          return gpuTexture;
        }
        onSourceUpdate(source2) {
          const gpuTexture = this.getGpuSource(source2);
          if (!gpuTexture)
            return;
          if (this._uploads[source2.uploadMethodId]) {
            this._uploads[source2.uploadMethodId].upload(source2, gpuTexture, this._gpu);
          }
          if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
            this.onUpdateMipmaps(source2);
          }
        }
        onSourceUnload(source2) {
          const gpuTexture = this._gpuSources[source2.uid];
          if (gpuTexture) {
            this._gpuSources[source2.uid] = null;
            gpuTexture.destroy();
          }
        }
        onUpdateMipmaps(source2) {
          if (!this._mipmapGenerator) {
            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
          }
          const gpuTexture = this.getGpuSource(source2);
          this._mipmapGenerator.generateMipmap(gpuTexture);
        }
        onSourceDestroy(source2) {
          source2.off("update", this.onSourceUpdate, this);
          source2.off("unload", this.onSourceUnload, this);
          source2.off("destroy", this.onSourceDestroy, this);
          source2.off("resize", this.onSourceResize, this);
          source2.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
          this.onSourceUnload(source2);
        }
        onSourceResize(source2) {
          const gpuTexture = this._gpuSources[source2.uid];
          if (!gpuTexture) {
            this.initSource(source2);
          } else if (gpuTexture.width !== source2.pixelWidth || gpuTexture.height !== source2.pixelHeight) {
            this._textureViewHash[source2.uid] = null;
            this._bindGroupHash[source2.uid] = null;
            this.onSourceUnload(source2);
            this.initSource(source2);
          }
        }
        _initSampler(sampler) {
          this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
          return this._gpuSamplers[sampler._resourceId];
        }
        getGpuSampler(sampler) {
          return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGpuSource(source2) {
          return this._gpuSources[source2.uid] || this.initSource(source2);
        }
        getTextureBindGroup(texture) {
          return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
        }
        _createTextureBindGroup(texture) {
          const source2 = texture.source;
          this._bindGroupHash[texture.uid] = new BindGroup({
            0: source2,
            1: source2.style,
            2: new UniformGroup2({
              uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
            })
          });
          return this._bindGroupHash[texture.uid];
        }
        getTextureView(texture) {
          const source2 = texture.source;
          return this._textureViewHash[source2.uid] ?? this._createTextureView(source2);
        }
        _createTextureView(texture) {
          this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
          return this._textureViewHash[texture.uid];
        }
        generateCanvas(texture) {
          const renderer = this._renderer;
          const commandEncoder = renderer.gpu.device.createCommandEncoder();
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = texture.source.pixelWidth;
          canvas.height = texture.source.pixelHeight;
          const context3 = canvas.getContext("webgpu");
          context3.configure({
            device: renderer.gpu.device,
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
          });
          commandEncoder.copyTextureToTexture({
            texture: renderer.texture.getGpuSource(texture.source),
            origin: {
              x: 0,
              y: 0
            }
          }, {
            texture: context3.getCurrentTexture()
          }, {
            width: canvas.width,
            height: canvas.height
          });
          renderer.gpu.device.queue.submit([commandEncoder.finish()]);
          return canvas;
        }
        getPixels(texture) {
          const webGPUCanvas = this.generateCanvas(texture);
          const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
          const context3 = canvasAndContext.context;
          context3.drawImage(webGPUCanvas, 0, 0);
          const { width, height } = webGPUCanvas;
          const imageData = context3.getImageData(0, 0, width, height);
          const pixels = new Uint8ClampedArray(imageData.data.buffer);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          return { pixels, width, height };
        }
        destroy() {
          this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
          this.managedTextures = null;
          for (const k2 of Object.keys(this._bindGroupHash)) {
            const key = Number(k2);
            const bindGroup = this._bindGroupHash[key];
            bindGroup?.destroy();
            this._bindGroupHash[key] = null;
          }
          this._gpu = null;
          this._mipmapGenerator = null;
          this._gpuSources = null;
          this._bindGroupHash = null;
          this._textureViewHash = null;
          this._gpuSamplers = null;
        }
      };
      GpuTextureSystem.extension = {
        type: [
          ExtensionType2.WebGPUSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gpu/WebGPURenderer.mjs
  var WebGPURenderer_exports = {};
  __export(WebGPURenderer_exports, {
    WebGPURenderer: () => WebGPURenderer
  });
  var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
  var init_WebGPURenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
      init_Extensions();
      init_GpuGraphicsAdaptor();
      init_GpuMeshAdapter();
      init_GpuBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_BindGroupSystem();
      init_GpuBufferSystem();
      init_GpuColorMaskSystem();
      init_GpuDeviceSystem();
      init_GpuEncoderSystem();
      init_GpuStencilSystem();
      init_GpuUboSystem();
      init_GpuUniformBatchPipe();
      init_PipelineSystem();
      init_GpuRenderTargetSystem();
      init_GpuShaderSystem();
      init_GpuStateSystem();
      init_GpuTextureSystem();
      DefaultWebGPUSystems = [
        ...SharedSystems,
        GpuUboSystem,
        GpuEncoderSystem,
        GpuDeviceSystem,
        GpuBufferSystem,
        GpuTextureSystem,
        GpuRenderTargetSystem,
        GpuShaderSystem,
        GpuStateSystem,
        PipelineSystem,
        GpuColorMaskSystem,
        GpuStencilSystem,
        BindGroupSystem
      ];
      DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
      DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
      systems = [];
      renderPipes = [];
      renderPipeAdaptors = [];
      extensions3.handleByNamedList(ExtensionType2.WebGPUSystem, systems);
      extensions3.handleByNamedList(ExtensionType2.WebGPUPipes, renderPipes);
      extensions3.handleByNamedList(ExtensionType2.WebGPUPipesAdaptor, renderPipeAdaptors);
      extensions3.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
      WebGPURenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgpu",
            type: RendererType.WEBGPU,
            systems,
            renderPipes,
            renderPipeAdaptors
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
  var GlGraphicsAdaptor;
  var init_GlGraphicsAdaptor = __esm({
    "node_modules/pixi-v8/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_maxRecommendedTextures2();
      init_compileHighShaderToProgram();
      init_colorBit();
      init_generateTextureBatchBit();
      init_localUniformBit();
      init_roundPixelsBit();
      init_getBatchSamplersUniformGroup();
      init_Shader2();
      init_UniformGroup2();
      GlGraphicsAdaptor = class {
        init() {
          const uniforms = new UniformGroup2({
            uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
            uTransformMatrix: { value: new Matrix2(), type: "mat3x3<f32>" },
            uRound: { value: 0, type: "f32" }
          });
          const maxTextures2 = getMaxTexturesPerBatch();
          const glProgram3 = compileHighShaderGlProgram({
            name: "graphics",
            bits: [
              colorBitGl,
              generateTextureBatchBitGl(maxTextures2),
              localUniformBitGl,
              roundPixelsBitGl
            ]
          });
          this.shader = new Shader2({
            glProgram: glProgram3,
            resources: {
              localUniforms: uniforms,
              batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
            }
          });
        }
        execute(graphicsPipe, renderable) {
          const context3 = renderable.context;
          const shader = context3.customShader || this.shader;
          const renderer = graphicsPipe.renderer;
          const contextSystem = renderer.graphicsContext;
          const {
            batcher,
            instructions
          } = contextSystem.getContextRenderData(context3);
          shader.groups[0] = renderer.globalUniforms.bindGroup;
          renderer.state.set(graphicsPipe.state);
          renderer.shader.bind(shader);
          renderer.geometry.bind(batcher.geometry, shader.glProgram);
          const batches = instructions.instructions;
          for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
            const batch = batches[i2];
            if (batch.size) {
              for (let j2 = 0; j2 < batch.textures.count; j2++) {
                renderer.texture.bind(batch.textures.textures[j2], j2);
              }
              renderer.geometry.draw("triangle-list", batch.size, batch.start);
            }
          }
        }
        destroy() {
          this.shader.destroy(true);
          this.shader = null;
        }
      };
      GlGraphicsAdaptor.extension = {
        type: [
          ExtensionType2.WebGLPipesAdaptor
        ],
        name: "graphics"
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/mesh/gl/GlMeshAdaptor.mjs
  var GlMeshAdaptor;
  var init_GlMeshAdaptor = __esm({
    "node_modules/pixi-v8/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
      init_Extensions();
      init_Matrix2();
      init_compileHighShaderToProgram();
      init_localUniformBit();
      init_roundPixelsBit();
      init_textureBit();
      init_Shader2();
      init_Texture2();
      init_warn();
      GlMeshAdaptor = class {
        init() {
          const glProgram3 = compileHighShaderGlProgram({
            name: "mesh",
            bits: [
              localUniformBitGl,
              textureBitGl,
              roundPixelsBitGl
            ]
          });
          this._shader = new Shader2({
            glProgram: glProgram3,
            resources: {
              uTexture: Texture2.EMPTY.source,
              textureUniforms: {
                uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix2() }
              }
            }
          });
        }
        execute(meshPipe, mesh) {
          const renderer = meshPipe.renderer;
          let shader = mesh._shader;
          if (!shader) {
            shader = this._shader;
            const texture = mesh.texture;
            const source2 = texture.source;
            shader.resources.uTexture = source2;
            shader.resources.uSampler = source2.style;
            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
          } else if (!shader.glProgram) {
            warn("Mesh shader has no glProgram", mesh.shader);
            return;
          }
          shader.groups[100] = renderer.globalUniforms.bindGroup;
          shader.groups[101] = meshPipe.localUniformsBindGroup;
          renderer.encoder.draw({
            geometry: mesh._geometry,
            shader,
            state: mesh.state
          });
        }
        destroy() {
          this._shader.destroy(true);
          this._shader = null;
        }
      };
      GlMeshAdaptor.extension = {
        type: [
          ExtensionType2.WebGLPipesAdaptor
        ],
        name: "mesh"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
  var GlBatchAdaptor;
  var init_GlBatchAdaptor = __esm({
    "node_modules/pixi-v8/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
      init_Extensions();
      init_State2();
      GlBatchAdaptor = class {
        constructor() {
          this._didUpload = false;
          this._tempState = State2.for2d();
        }
        init(batcherPipe) {
          batcherPipe.renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._didUpload = false;
        }
        start(batchPipe, geometry, shader) {
          const renderer = batchPipe.renderer;
          renderer.shader.bind(shader, this._didUpload);
          renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
          renderer.geometry.bind(geometry, shader.glProgram);
        }
        execute(batchPipe, batch) {
          const renderer = batchPipe.renderer;
          this._didUpload = true;
          this._tempState.blendMode = batch.blendMode;
          renderer.state.set(this._tempState);
          const textures = batch.textures.textures;
          for (let i2 = 0; i2 < batch.textures.count; i2++) {
            renderer.texture.bind(textures[i2], i2);
          }
          renderer.geometry.draw("triangle-list", batch.size, batch.start);
        }
      };
      GlBatchAdaptor.extension = {
        type: [
          ExtensionType2.WebGLPipesAdaptor
        ],
        name: "batch"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/const.mjs
  var BUFFER_TYPE2;
  var init_const15 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/const.mjs"() {
      "use strict";
      BUFFER_TYPE2 = /* @__PURE__ */ ((BUFFER_TYPE22) => {
        BUFFER_TYPE22[BUFFER_TYPE22["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        BUFFER_TYPE22[BUFFER_TYPE22["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        BUFFER_TYPE22[BUFFER_TYPE22["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        return BUFFER_TYPE22;
      })(BUFFER_TYPE2 || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
  var GlBuffer;
  var init_GlBuffer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
      "use strict";
      GlBuffer = class {
        constructor(buffer, type) {
          this.buffer = buffer || null;
          this.updateID = -1;
          this.byteLength = -1;
          this.type = type;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
  var GlBufferSystem;
  var init_GlBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
      init_Extensions();
      init_const10();
      init_const15();
      init_GlBuffer();
      GlBufferSystem = class {
        constructor(renderer) {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._boundBufferBases = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        destroy() {
          this._renderer = null;
          this._gl = null;
          this._gpuBuffers = null;
          this._boundBufferBases = null;
        }
        contextChange() {
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
          this._gl = this._renderer.gl;
        }
        getGlBuffer(buffer) {
          return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
        }
        bind(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        }
        bindBufferBase(buffer, index) {
          const { _gl: gl } = this;
          if (this._boundBufferBases[index] !== buffer) {
            const glBuffer = this.getGlBuffer(buffer);
            this._boundBufferBases[index] = buffer;
            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
          }
        }
        bindBufferRange(buffer, index, offset) {
          const { _gl: gl } = this;
          offset = offset || 0;
          const glBuffer = this.getGlBuffer(buffer);
          gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
        }
        updateBuffer(buffer) {
          const { _gl: gl } = this;
          const glBuffer = this.getGlBuffer(buffer);
          if (buffer._updateID === glBuffer.updateID) {
            return glBuffer;
          }
          glBuffer.updateID = buffer._updateID;
          gl.bindBuffer(glBuffer.type, glBuffer.buffer);
          const data = buffer.data;
          if (glBuffer.byteLength >= buffer.data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
          } else {
            const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
            glBuffer.byteLength = data.byteLength;
            gl.bufferData(glBuffer.type, data, drawType);
          }
          return glBuffer;
        }
        destroyAll() {
          const gl = this._gl;
          for (const id in this._gpuBuffers) {
            gl.deleteBuffer(this._gpuBuffers[id].buffer);
          }
          this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        }
        onBufferDestroy(buffer, contextLost) {
          const glBuffer = this._gpuBuffers[buffer.uid];
          const gl = this._gl;
          if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
          }
          this._gpuBuffers[buffer.uid] = null;
        }
        createGLBuffer(buffer) {
          const { _gl: gl } = this;
          let type = BUFFER_TYPE2.ARRAY_BUFFER;
          if (buffer.descriptor.usage & BufferUsage.INDEX) {
            type = BUFFER_TYPE2.ELEMENT_ARRAY_BUFFER;
          } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
            type = BUFFER_TYPE2.UNIFORM_BUFFER;
          }
          const glBuffer = new GlBuffer(gl.createBuffer(), type);
          this._gpuBuffers[buffer.uid] = glBuffer;
          buffer.on("destroy", this.onBufferDestroy, this);
          return glBuffer;
        }
      };
      GlBufferSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "buffer"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/context/GlContextSystem.mjs
  var _GlContextSystem, GlContextSystem;
  var init_GlContextSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
      init_adapter2();
      init_Extensions();
      init_warn();
      _GlContextSystem = class _GlContextSystem2 {
        constructor(renderer) {
          this.supports = {
            uint32Indices: true,
            uniformBufferObject: true,
            vertexArrayObject: true,
            srgbTextures: true,
            nonPowOf2wrapping: true,
            msaa: true,
            nonPowOf2mipmaps: true
          };
          this._renderer = renderer;
          this.extensions = /* @__PURE__ */ Object.create(null);
          this.handleContextLost = this.handleContextLost.bind(this);
          this.handleContextRestored = this.handleContextRestored.bind(this);
        }
        get isLost() {
          return !this.gl || this.gl.isContextLost();
        }
        contextChange(gl) {
          this.gl = gl;
          this._renderer.gl = gl;
        }
        init(options) {
          options = { ..._GlContextSystem2.defaultOptions, ...options };
          let multiView = this.multiView = options.multiView;
          if (options.context && multiView) {
            warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
            multiView = false;
          }
          if (multiView) {
            this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
          } else {
            this.canvas = this._renderer.view.canvas;
          }
          if (options.context) {
            this.initFromContext(options.context);
          } else {
            const alpha = this._renderer.background.alpha < 1;
            const premultipliedAlpha = options.premultipliedAlpha ?? true;
            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(options.preferWebGLVersion, {
              alpha,
              premultipliedAlpha,
              antialias,
              stencil: true,
              preserveDrawingBuffer: options.preserveDrawingBuffer,
              powerPreference: options.powerPreference ?? "default"
            });
          }
        }
        ensureCanvasSize(targetCanvas) {
          if (!this.multiView) {
            if (targetCanvas !== this.canvas) {
              warn("multiView is disabled, but targetCanvas is not the main canvas");
            }
            return;
          }
          const { canvas } = this;
          if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
          }
        }
        initFromContext(gl) {
          this.gl = gl;
          this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
          this.getExtensions();
          this.validateContext(gl);
          this._renderer.runners.contextChange.emit(gl);
          const element = this._renderer.view.canvas;
          element.addEventListener("webglcontextlost", this.handleContextLost, false);
          element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        createContext(preferWebGLVersion, options) {
          let gl;
          const canvas = this.canvas;
          if (preferWebGLVersion === 2) {
            gl = canvas.getContext("webgl2", options);
          }
          if (!gl) {
            gl = canvas.getContext("webgl", options);
            if (!gl) {
              throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            }
          }
          this.gl = gl;
          this.initFromContext(this.gl);
        }
        getExtensions() {
          const { gl } = this;
          const common = {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: gl.getExtension("WEBGL_compressed_texture_etc"),
            etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: gl.getExtension("WEBGL_compressed_texture_atc"),
            astc: gl.getExtension("WEBGL_compressed_texture_astc"),
            bptc: gl.getExtension("EXT_texture_compression_bptc"),
            rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
            loseContext: gl.getExtension("WEBGL_lose_context")
          };
          if (this.webGLVersion === 1) {
            this.extensions = {
              ...common,
              drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
              depthTexture: gl.getExtension("WEBGL_depth_texture"),
              vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
              uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
              floatTexture: gl.getExtension("OES_texture_float"),
              floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
              textureHalfFloat: gl.getExtension("OES_texture_half_float"),
              textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
              vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
              srgb: gl.getExtension("EXT_sRGB")
            };
          } else {
            this.extensions = {
              ...common,
              colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
            };
            const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
            if (provokeExt) {
              provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
            }
          }
        }
        handleContextLost(event) {
          event.preventDefault();
          if (this._contextLossForced) {
            this._contextLossForced = false;
            setTimeout(() => {
              if (this.gl.isContextLost()) {
                this.extensions.loseContext?.restoreContext();
              }
            }, 0);
          }
        }
        handleContextRestored() {
          this._renderer.runners.contextChange.emit(this.gl);
        }
        destroy() {
          const element = this._renderer.view.canvas;
          this._renderer = null;
          element.removeEventListener("webglcontextlost", this.handleContextLost);
          element.removeEventListener("webglcontextrestored", this.handleContextRestored);
          this.gl.useProgram(null);
          this.extensions.loseContext?.loseContext();
        }
        forceContextLoss() {
          this.extensions.loseContext?.loseContext();
          this._contextLossForced = true;
        }
        validateContext(gl) {
          const attributes = gl.getContextAttributes();
          if (attributes && !attributes.stencil) {
            warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          }
          const supports = this.supports;
          const isWebGl2 = this.webGLVersion === 2;
          const extensions4 = this.extensions;
          supports.uint32Indices = isWebGl2 || !!extensions4.uint32ElementIndex;
          supports.uniformBufferObject = isWebGl2;
          supports.vertexArrayObject = isWebGl2 || !!extensions4.vertexArrayObject;
          supports.srgbTextures = isWebGl2 || !!extensions4.srgb;
          supports.nonPowOf2wrapping = isWebGl2;
          supports.nonPowOf2mipmaps = isWebGl2;
          supports.msaa = isWebGl2;
          if (!supports.uint32Indices) {
            warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
          }
        }
      };
      _GlContextSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "context"
      };
      _GlContextSystem.defaultOptions = {
        context: null,
        premultipliedAlpha: true,
        preserveDrawingBuffer: false,
        powerPreference: void 0,
        preferWebGLVersion: 2,
        multiView: false
      };
      GlContextSystem = _GlContextSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/const.mjs
  var GL_FORMATS, GL_TARGETS, GL_TYPES;
  var init_const16 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/const.mjs"() {
      "use strict";
      GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
        GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
        GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
        GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
        GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
        GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
        GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        return GL_FORMATS2;
      })(GL_FORMATS || {});
      GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        return GL_TARGETS2;
      })(GL_TARGETS || {});
      GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
        GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
        GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
        GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
        GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
        GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
        return GL_TYPES2;
      })(GL_TYPES || {});
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
  function getGlTypeFromFormat(format2) {
    return infoMap[format2] ?? infoMap.float32;
  }
  var infoMap;
  var init_getGlTypeFromFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
      init_const16();
      infoMap = {
        uint8x2: GL_TYPES.UNSIGNED_BYTE,
        uint8x4: GL_TYPES.UNSIGNED_BYTE,
        sint8x2: GL_TYPES.BYTE,
        sint8x4: GL_TYPES.BYTE,
        unorm8x2: GL_TYPES.UNSIGNED_BYTE,
        unorm8x4: GL_TYPES.UNSIGNED_BYTE,
        snorm8x2: GL_TYPES.BYTE,
        snorm8x4: GL_TYPES.BYTE,
        uint16x2: GL_TYPES.UNSIGNED_SHORT,
        uint16x4: GL_TYPES.UNSIGNED_SHORT,
        sint16x2: GL_TYPES.SHORT,
        sint16x4: GL_TYPES.SHORT,
        unorm16x2: GL_TYPES.UNSIGNED_SHORT,
        unorm16x4: GL_TYPES.UNSIGNED_SHORT,
        snorm16x2: GL_TYPES.SHORT,
        snorm16x4: GL_TYPES.SHORT,
        float16x2: GL_TYPES.HALF_FLOAT,
        float16x4: GL_TYPES.HALF_FLOAT,
        float32: GL_TYPES.FLOAT,
        float32x2: GL_TYPES.FLOAT,
        float32x3: GL_TYPES.FLOAT,
        float32x4: GL_TYPES.FLOAT,
        uint32: GL_TYPES.UNSIGNED_INT,
        uint32x2: GL_TYPES.UNSIGNED_INT,
        uint32x3: GL_TYPES.UNSIGNED_INT,
        uint32x4: GL_TYPES.UNSIGNED_INT,
        sint32: GL_TYPES.INT,
        sint32x2: GL_TYPES.INT,
        sint32x3: GL_TYPES.INT,
        sint32x4: GL_TYPES.INT
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
  var topologyToGlMap, GlGeometrySystem;
  var init_GlGeometrySystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
      init_Extensions();
      init_getAttributeInfoFromFormat();
      init_ensureAttributes();
      init_getGlTypeFromFormat();
      topologyToGlMap = {
        "point-list": 0,
        "line-list": 1,
        "line-strip": 3,
        "triangle-list": 4,
        "triangle-strip": 5
      };
      GlGeometrySystem = class {
        constructor(renderer) {
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
          this._activeGeometry = null;
          this._activeVao = null;
          this.hasVao = true;
          this.hasInstance = true;
        }
        contextChange() {
          const gl = this.gl = this._renderer.gl;
          if (!this._renderer.context.supports.vertexArrayObject) {
            throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
          }
          const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
          if (nativeVaoExtension) {
            gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
            gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
            gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
          }
          const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
          if (nativeInstancedExtension) {
            gl.drawArraysInstanced = (a2, b2, c2, d2) => {
              nativeInstancedExtension.drawArraysInstancedANGLE(a2, b2, c2, d2);
            };
            gl.drawElementsInstanced = (a2, b2, c2, d2, e2) => {
              nativeInstancedExtension.drawElementsInstancedANGLE(a2, b2, c2, d2, e2);
            };
            gl.vertexAttribDivisor = (a2, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b2);
          }
          this._activeGeometry = null;
          this._activeVao = null;
          this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        }
        bind(geometry, program) {
          const gl = this.gl;
          this._activeGeometry = geometry;
          const vao = this.getVao(geometry, program);
          if (this._activeVao !== vao) {
            this._activeVao = vao;
            gl.bindVertexArray(vao);
          }
          this.updateBuffers();
        }
        reset() {
          this.unbind();
        }
        updateBuffers() {
          const geometry = this._activeGeometry;
          const bufferSystem = this._renderer.buffer;
          for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
            const buffer = geometry.buffers[i2];
            bufferSystem.updateBuffer(buffer);
          }
        }
        checkCompatibility(geometry, program) {
          const geometryAttributes = geometry.attributes;
          const shaderAttributes = program._attributeData;
          for (const j2 in shaderAttributes) {
            if (!geometryAttributes[j2]) {
              throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
            }
          }
        }
        getSignature(geometry, program) {
          const attribs = geometry.attributes;
          const shaderAttributes = program._attributeData;
          const strings = ["g", geometry.uid];
          for (const i2 in attribs) {
            if (shaderAttributes[i2]) {
              strings.push(i2, shaderAttributes[i2].location);
            }
          }
          return strings.join("-");
        }
        getVao(geometry, program) {
          return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
        }
        initGeometryVao(geometry, program, _incRefCount = true) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          this._renderer.shader._getProgramData(program);
          this.checkCompatibility(geometry, program);
          const signature = this.getSignature(geometry, program);
          if (!this._geometryVaoHash[geometry.uid]) {
            this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
            geometry.on("destroy", this.onGeometryDestroy, this);
          }
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          let vao = vaoObjectHash[signature];
          if (vao) {
            vaoObjectHash[program._key] = vao;
            return vao;
          }
          ensureAttributes(geometry, program._attributeData);
          const buffers = geometry.buffers;
          vao = gl.createVertexArray();
          gl.bindVertexArray(vao);
          for (let i2 = 0; i2 < buffers.length; i2++) {
            const buffer = buffers[i2];
            bufferSystem.bind(buffer);
          }
          this.activateVao(geometry, program);
          vaoObjectHash[program._key] = vao;
          vaoObjectHash[signature] = vao;
          gl.bindVertexArray(null);
          return vao;
        }
        onGeometryDestroy(geometry, contextLost) {
          const vaoObjectHash = this._geometryVaoHash[geometry.uid];
          const gl = this.gl;
          if (vaoObjectHash) {
            if (contextLost) {
              for (const i2 in vaoObjectHash) {
                if (this._activeVao !== vaoObjectHash[i2]) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[i2]);
              }
            }
            this._geometryVaoHash[geometry.uid] = null;
          }
        }
        destroyAll(contextLost = false) {
          const gl = this.gl;
          for (const i2 in this._geometryVaoHash) {
            if (contextLost) {
              for (const j2 in this._geometryVaoHash[i2]) {
                const vaoObjectHash = this._geometryVaoHash[i2];
                if (this._activeVao !== vaoObjectHash) {
                  this.unbind();
                }
                gl.deleteVertexArray(vaoObjectHash[j2]);
              }
            }
            this._geometryVaoHash[i2] = null;
          }
        }
        activateVao(geometry, program) {
          const gl = this._renderer.gl;
          const bufferSystem = this._renderer.buffer;
          const attributes = geometry.attributes;
          if (geometry.indexBuffer) {
            bufferSystem.bind(geometry.indexBuffer);
          }
          let lastBuffer = null;
          for (const j2 in attributes) {
            const attribute = attributes[j2];
            const buffer = attribute.buffer;
            const glBuffer = bufferSystem.getGlBuffer(buffer);
            const programAttrib = program._attributeData[j2];
            if (programAttrib) {
              if (lastBuffer !== glBuffer) {
                bufferSystem.bind(buffer);
                lastBuffer = glBuffer;
              }
              const location = programAttrib.location;
              gl.enableVertexAttribArray(location);
              const attributeInfo = getAttributeInfoFromFormat(attribute.format);
              const type = getGlTypeFromFormat(attribute.format);
              if (programAttrib.format?.substring(1, 4) === "int") {
                gl.vertexAttribIPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attribute.stride,
                  attribute.offset
                );
              } else {
                gl.vertexAttribPointer(
                  location,
                  attributeInfo.size,
                  type,
                  attributeInfo.normalised,
                  attribute.stride,
                  attribute.offset
                );
              }
              if (attribute.instance) {
                if (this.hasInstance) {
                  const divisor = attribute.divisor ?? 1;
                  gl.vertexAttribDivisor(location, divisor);
                } else {
                  throw new Error("geometry error, GPU Instancing is not supported on this device");
                }
              }
            }
          }
        }
        draw(topology, size, start, instanceCount) {
          const { gl } = this._renderer;
          const geometry = this._activeGeometry;
          const glTopology = topologyToGlMap[geometry.topology || topology];
          instanceCount || (instanceCount = geometry.instanceCount);
          if (geometry.indexBuffer) {
            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
            if (instanceCount > 1) {
              gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
            } else {
              gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else if (instanceCount > 1) {
            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
          } else {
            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
          }
          return this;
        }
        unbind() {
          this.gl.bindVertexArray(null);
          this._activeVao = null;
          this._activeGeometry = null;
        }
        destroy() {
          this._renderer = null;
          this.gl = null;
          this._activeVao = null;
          this._activeGeometry = null;
        }
      };
      GlGeometrySystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "geometry"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
  var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
  var init_GlBackBufferSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
      init_Extensions();
      init_warn();
      init_Geometry2();
      init_Shader2();
      init_State2();
      init_TextureSource();
      init_Texture2();
      init_GlProgram();
      bigTriangleGeometry = new Geometry2({
        attributes: {
          aPosition: [
            -1,
            -1,
            3,
            -1,
            -1,
            3
          ]
        }
      });
      _GlBackBufferSystem = class _GlBackBufferSystem2 {
        constructor(renderer) {
          this.useBackBuffer = false;
          this._useBackBufferThisRender = false;
          this._renderer = renderer;
        }
        init(options = {}) {
          const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
          this.useBackBuffer = useBackBuffer;
          this._antialias = antialias;
          if (!this._renderer.context.supports.msaa) {
            warn("antialiasing, is not supported on when using the back buffer");
            this._antialias = false;
          }
          this._state = State2.for2d();
          const bigTriangleProgram = new GlProgram({
            vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
            fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
            name: "big-triangle"
          });
          this._bigTriangleShader = new Shader2({
            glProgram: bigTriangleProgram,
            resources: {
              uTexture: Texture2.WHITE.source
            }
          });
        }
        renderStart(options) {
          const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
          this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
          if (this._useBackBufferThisRender) {
            const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
            this._targetTexture = renderTarget2.colorTexture;
            options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
          }
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const renderer = this._renderer;
          renderer.renderTarget.finishRenderPass();
          if (!this._useBackBufferThisRender)
            return;
          renderer.renderTarget.bind(this._targetTexture, false);
          this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
          renderer.encoder.draw({
            geometry: bigTriangleGeometry,
            shader: this._bigTriangleShader,
            state: this._state
          });
        }
        _getBackBufferTexture(targetSourceTexture) {
          this._backBufferTexture = this._backBufferTexture || new Texture2({
            source: new TextureSource({
              width: targetSourceTexture.width,
              height: targetSourceTexture.height,
              resolution: targetSourceTexture._resolution,
              antialias: this._antialias
            })
          });
          this._backBufferTexture.source.resize(
            targetSourceTexture.width,
            targetSourceTexture.height,
            targetSourceTexture._resolution
          );
          return this._backBufferTexture;
        }
        destroy() {
          if (this._backBufferTexture) {
            this._backBufferTexture.destroy();
            this._backBufferTexture = null;
          }
        }
      };
      _GlBackBufferSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "backBuffer",
        priority: 1
      };
      _GlBackBufferSystem.defaultOptions = {
        useBackBuffer: false
      };
      GlBackBufferSystem = _GlBackBufferSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
  var GlColorMaskSystem;
  var init_GlColorMaskSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
      init_Extensions();
      GlColorMaskSystem = class {
        constructor(renderer) {
          this._colorMaskCache = 15;
          this._renderer = renderer;
        }
        setMask(colorMask) {
          if (this._colorMaskCache === colorMask)
            return;
          this._colorMaskCache = colorMask;
          this._renderer.gl.colorMask(
            !!(colorMask & 8),
            !!(colorMask & 4),
            !!(colorMask & 2),
            !!(colorMask & 1)
          );
        }
      };
      GlColorMaskSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "colorMask"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlEncoderSystem.mjs
  var GlEncoderSystem;
  var init_GlEncoderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
      init_Extensions();
      GlEncoderSystem = class {
        constructor(renderer) {
          this.commandFinished = Promise.resolve();
          this._renderer = renderer;
        }
        setGeometry(geometry, shader) {
          this._renderer.geometry.bind(geometry, shader.glProgram);
        }
        finishRenderPass() {
        }
        draw(options) {
          const renderer = this._renderer;
          const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
          renderer.shader.bind(shader, skipSync);
          renderer.geometry.bind(geometry, renderer.shader._activeProgram);
          if (state) {
            renderer.state.set(state);
          }
          renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
        }
        destroy() {
          this._renderer = null;
        }
      };
      GlEncoderSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "encoder"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlStencilSystem.mjs
  var GlStencilSystem;
  var init_GlStencilSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
      init_Extensions();
      init_GpuStencilModesToPixi();
      init_const9();
      GlStencilSystem = class {
        constructor(renderer) {
          this._stencilCache = {
            enabled: false,
            stencilReference: 0,
            stencilMode: STENCIL_MODES.NONE
          };
          this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
          renderer.renderTarget.onRenderTargetChange.add(this);
        }
        contextChange(gl) {
          this._gl = gl;
          this._comparisonFuncMapping = {
            always: gl.ALWAYS,
            never: gl.NEVER,
            equal: gl.EQUAL,
            "not-equal": gl.NOTEQUAL,
            less: gl.LESS,
            "less-equal": gl.LEQUAL,
            greater: gl.GREATER,
            "greater-equal": gl.GEQUAL
          };
          this._stencilOpsMapping = {
            keep: gl.KEEP,
            zero: gl.ZERO,
            replace: gl.REPLACE,
            invert: gl.INVERT,
            "increment-clamp": gl.INCR,
            "decrement-clamp": gl.DECR,
            "increment-wrap": gl.INCR_WRAP,
            "decrement-wrap": gl.DECR_WRAP
          };
          this._stencilCache.enabled = false;
          this._stencilCache.stencilMode = STENCIL_MODES.NONE;
          this._stencilCache.stencilReference = 0;
        }
        onRenderTargetChange(renderTarget) {
          if (this._activeRenderTarget === renderTarget)
            return;
          this._activeRenderTarget = renderTarget;
          let stencilState = this._renderTargetStencilState[renderTarget.uid];
          if (!stencilState) {
            stencilState = this._renderTargetStencilState[renderTarget.uid] = {
              stencilMode: STENCIL_MODES.DISABLED,
              stencilReference: 0
            };
          }
          this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
        }
        setStencilMode(stencilMode, stencilReference) {
          const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
          const gl = this._gl;
          const mode = GpuStencilModesToPixi[stencilMode];
          const _stencilCache = this._stencilCache;
          stencilState.stencilMode = stencilMode;
          stencilState.stencilReference = stencilReference;
          if (stencilMode === STENCIL_MODES.DISABLED) {
            if (this._stencilCache.enabled) {
              this._stencilCache.enabled = false;
              gl.disable(gl.STENCIL_TEST);
            }
            return;
          }
          if (!this._stencilCache.enabled) {
            this._stencilCache.enabled = true;
            gl.enable(gl.STENCIL_TEST);
          }
          if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
            _stencilCache.stencilMode = stencilMode;
            _stencilCache.stencilReference = stencilReference;
            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
          }
        }
      };
      GlStencilSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "stencil"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
  function createUboElementsSTD40(uniformData) {
    const uboElements = uniformData.map((data) => ({
      data,
      offset: 0,
      size: 0
    }));
    let size = 0;
    let chunkSize = 0;
    let offset = 0;
    for (let i2 = 0; i2 < uboElements.length; i2++) {
      const uboElement = uboElements[i2];
      size = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size) {
        throw new Error(`Unknown type ${uboElement.data.type}`);
      }
      if (uboElement.data.size > 1) {
        size = Math.max(size, 16) * uboElement.data.size;
      }
      uboElement.size = size;
      if (chunkSize % size !== 0 && chunkSize < 16) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      if (chunkSize + size > 16) {
        offset = Math.ceil(offset / 16) * 16;
        uboElement.offset = offset;
        offset += size;
        chunkSize = size;
      } else {
        uboElement.offset = offset;
        chunkSize += size;
        offset += size;
      }
    }
    offset = Math.ceil(offset / 16) * 16;
    return { uboElements, size: offset };
  }
  var WGSL_TO_STD40_SIZE;
  var init_createUboElementsSTD40 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
      "use strict";
      WGSL_TO_STD40_SIZE = {
        f32: 4,
        "vec2<f32>": 8,
        "vec3<f32>": 12,
        "vec4<f32>": 16,
        "mat2x2<f32>": 16 * 2,
        "mat3x3<f32>": 16 * 3,
        "mat4x4<f32>": 16 * 4
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
  function generateArraySyncSTD40(uboElement, offsetToAdd) {
    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
    const elementSize = uboElement.data.value.length / uboElement.data.size;
    const remainder = (4 - elementSize % 4) % 4;
    return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
  }
  var init_generateArraySyncSTD40 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
      init_createUboElementsSTD40();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
  function createUboSyncFunctionSTD40(uboElements) {
    return createUboSyncFunction(
      uboElements,
      "uboStd40",
      generateArraySyncSTD40,
      uboSyncFunctionsSTD40
    );
  }
  var init_createUboSyncSTD40 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
      init_createUboSyncFunction();
      init_uboSyncFunctions();
      init_generateArraySyncSTD40();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlUboSystem.mjs
  var GlUboSystem;
  var init_GlUboSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
      init_Extensions();
      init_UboSystem();
      init_createUboElementsSTD40();
      init_createUboSyncSTD40();
      GlUboSystem = class extends UboSystem {
        constructor() {
          super({
            createUboElements: createUboElementsSTD40,
            generateUboSync: createUboSyncFunctionSTD40
          });
        }
      };
      GlUboSystem.extension = {
        type: [ExtensionType2.WebGLSystem],
        name: "ubo"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/GlRenderTarget.mjs
  var GlRenderTarget;
  var init_GlRenderTarget = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
      "use strict";
      GlRenderTarget = class {
        constructor() {
          this.width = -1;
          this.height = -1;
          this.msaa = false;
          this.msaaRenderBuffer = [];
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
  var GlRenderTargetAdaptor;
  var init_GlRenderTargetAdaptor = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
      init_Rectangle2();
      init_warn();
      init_CanvasSource();
      init_const13();
      init_GlRenderTarget();
      GlRenderTargetAdaptor = class {
        constructor() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle2();
        }
        init(renderer, renderTargetSystem) {
          this._renderer = renderer;
          this._renderTargetSystem = renderTargetSystem;
          renderer.runners.contextChange.add(this);
        }
        contextChange() {
          this._clearColorCache = [0, 0, 0, 0];
          this._viewPortCache = new Rectangle2();
        }
        copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
          const renderTargetSystem = this._renderTargetSystem;
          const renderer = this._renderer;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
          const gl = renderer.gl;
          this.finishRenderPass(sourceRenderSurfaceTexture);
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          renderer.texture.bind(destinationTexture, 0);
          gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            originDest.x,
            originDest.y,
            originSrc.x,
            originSrc.y,
            size.width,
            size.height
          );
          return destinationTexture;
        }
        startRenderPass(renderTarget, clear = true, clearColor, viewport) {
          const renderTargetSystem = this._renderTargetSystem;
          const source2 = renderTarget.colorTexture;
          const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          let viewPortY = viewport.y;
          if (renderTarget.isRoot) {
            viewPortY = source2.pixelHeight - viewport.height;
          }
          renderTarget.colorTextures.forEach((texture) => {
            this._renderer.texture.unbind(texture);
          });
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
          const viewPortCache = this._viewPortCache;
          if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
            viewPortCache.x = viewport.x;
            viewPortCache.y = viewPortY;
            viewPortCache.width = viewport.width;
            viewPortCache.height = viewport.height;
            gl.viewport(
              viewport.x,
              viewPortY,
              viewport.width,
              viewport.height
            );
          }
          if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
            this._initStencil(gpuRenderTarget);
          }
          this.clear(renderTarget, clear, clearColor);
        }
        finishRenderPass(renderTarget) {
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          if (!glRenderTarget.msaa)
            return;
          const gl = this._renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
          gl.blitFramebuffer(
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            0,
            0,
            glRenderTarget.width,
            glRenderTarget.height,
            gl.COLOR_BUFFER_BIT,
            gl.NEAREST
          );
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        }
        initGpuRenderTarget(renderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const glRenderTarget = new GlRenderTarget();
          const colorTexture = renderTarget.colorTexture;
          if (CanvasSource.test(colorTexture.resource)) {
            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
            glRenderTarget.framebuffer = null;
            return glRenderTarget;
          }
          this._initColor(renderTarget, glRenderTarget);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return glRenderTarget;
        }
        destroyGpuRenderTarget(gpuRenderTarget) {
          const gl = this._renderer.gl;
          if (gpuRenderTarget.framebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
            gpuRenderTarget.framebuffer = null;
          }
          if (gpuRenderTarget.resolveTargetFramebuffer) {
            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
            gpuRenderTarget.resolveTargetFramebuffer = null;
          }
          if (gpuRenderTarget.depthStencilRenderBuffer) {
            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
            gpuRenderTarget.depthStencilRenderBuffer = null;
          }
          gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
            gl.deleteRenderbuffer(renderBuffer);
          });
          gpuRenderTarget.msaaRenderBuffer = null;
        }
        clear(_renderTarget, clear, clearColor) {
          if (!clear)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          if (typeof clear === "boolean") {
            clear = clear ? CLEAR.ALL : CLEAR.NONE;
          }
          const gl = this._renderer.gl;
          if (clear & CLEAR.COLOR) {
            clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
            const clearColorCache = this._clearColorCache;
            const clearColorArray = clearColor;
            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
              clearColorCache[0] = clearColorArray[0];
              clearColorCache[1] = clearColorArray[1];
              clearColorCache[2] = clearColorArray[2];
              clearColorCache[3] = clearColorArray[3];
              gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
            }
          }
          gl.clear(clear);
        }
        resizeGpuRenderTarget(renderTarget) {
          if (renderTarget.isRoot)
            return;
          const renderTargetSystem = this._renderTargetSystem;
          const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
          this._resizeColor(renderTarget, glRenderTarget);
          if (renderTarget.stencil || renderTarget.depth) {
            this._resizeStencil(glRenderTarget);
          }
        }
        _initColor(renderTarget, glRenderTarget) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const resolveTargetFramebuffer = gl.createFramebuffer();
          glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
          glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
          glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source2 = colorTexture.source;
            if (source2.antialias) {
              if (renderer.context.supports.msaa) {
                glRenderTarget.msaa = true;
              } else {
                warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
              }
            }
            renderer.texture.bindSource(source2, 0);
            const glSource = renderer.texture.getGlSource(source2);
            const glTexture = glSource.texture;
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              3553,
              glTexture,
              0
            );
          });
          if (glRenderTarget.msaa) {
            const viewFramebuffer = gl.createFramebuffer();
            glRenderTarget.framebuffer = viewFramebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((_, i2) => {
              const msaaRenderBuffer = gl.createRenderbuffer();
              glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
            });
          } else {
            glRenderTarget.framebuffer = resolveTargetFramebuffer;
          }
          this._resizeColor(renderTarget, glRenderTarget);
        }
        _resizeColor(renderTarget, glRenderTarget) {
          const source2 = renderTarget.colorTexture.source;
          glRenderTarget.width = source2.pixelWidth;
          glRenderTarget.height = source2.pixelHeight;
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            if (i2 === 0)
              return;
            colorTexture.source.resize(source2.width, source2.height, source2._resolution);
          });
          if (glRenderTarget.msaa) {
            const renderer = this._renderer;
            const gl = renderer.gl;
            const viewFramebuffer = glRenderTarget.framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
            renderTarget.colorTextures.forEach((colorTexture, i2) => {
              const source22 = colorTexture.source;
              renderer.texture.bindSource(source22, 0);
              const glSource = renderer.texture.getGlSource(source22);
              const glInternalFormat = glSource.internalFormat;
              const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
              gl.bindRenderbuffer(
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
              gl.renderbufferStorageMultisample(
                gl.RENDERBUFFER,
                4,
                glInternalFormat,
                source22.pixelWidth,
                source22.pixelHeight
              );
              gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.COLOR_ATTACHMENT0 + i2,
                gl.RENDERBUFFER,
                msaaRenderBuffer
              );
            });
          }
        }
        _initStencil(glRenderTarget) {
          if (glRenderTarget.framebuffer === null)
            return;
          const gl = this._renderer.gl;
          const depthStencilRenderBuffer = gl.createRenderbuffer();
          glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          gl.framebufferRenderbuffer(
            gl.FRAMEBUFFER,
            gl.DEPTH_STENCIL_ATTACHMENT,
            gl.RENDERBUFFER,
            depthStencilRenderBuffer
          );
          this._resizeStencil(glRenderTarget);
        }
        _resizeStencil(glRenderTarget) {
          const gl = this._renderer.gl;
          gl.bindRenderbuffer(
            gl.RENDERBUFFER,
            glRenderTarget.depthStencilRenderBuffer
          );
          if (glRenderTarget.msaa) {
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              gl.DEPTH24_STENCIL8,
              glRenderTarget.width,
              glRenderTarget.height
            );
          } else {
            gl.renderbufferStorage(
              gl.RENDERBUFFER,
              this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              glRenderTarget.width,
              glRenderTarget.height
            );
          }
        }
        postrender(renderTarget) {
          if (!this._renderer.context.multiView)
            return;
          if (CanvasSource.test(renderTarget.colorTexture.resource)) {
            const contextCanvas = this._renderer.context.canvas;
            const canvasSource = renderTarget.colorTexture;
            canvasSource.context2D.drawImage(
              contextCanvas,
              0,
              canvasSource.pixelHeight - contextCanvas.height
            );
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
  var GlRenderTargetSystem;
  var init_GlRenderTargetSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
      init_Extensions();
      init_RenderTargetSystem();
      init_GlRenderTargetAdaptor();
      GlRenderTargetSystem = class extends RenderTargetSystem {
        constructor(renderer) {
          super(renderer);
          this.adaptor = new GlRenderTargetAdaptor();
          this.adaptor.init(renderer, this);
        }
      };
      GlRenderTargetSystem.extension = {
        type: [ExtensionType2.WebGLSystem],
        name: "renderTarget"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
  function generateShaderSyncCode(shader, shaderSystem) {
    const funcFragments = [];
    const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let addedTextreSystem = false;
    let blockIndex = 0;
    let textureCount = 0;
    const programData = shaderSystem._getProgramData(shader.glProgram);
    for (const i2 in shader.groups) {
      const group = shader.groups[i2];
      funcFragments.push(`
            resources = g[${i2}].resources;
        `);
      for (const j2 in group.resources) {
        const resource = group.resources[j2];
        if (resource instanceof UniformGroup2) {
          if (resource.ubo) {
            funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            sS._uniformBindMap[${i2}[${j2}],
                            ${blockIndex++}
                        );
                    `);
          } else {
            funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
          }
        } else if (resource instanceof BufferResource2) {
          funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        sS._uniformBindMap[${i2}[${j2}],
                        ${blockIndex++}
                    );
                `);
        } else if (resource instanceof TextureSource) {
          const uniformName = shader._uniformBindMap[i2][j2];
          const uniformData = programData.uniformData[uniformName];
          if (uniformData) {
            if (!addedTextreSystem) {
              addedTextreSystem = true;
              headerFragments.push(`
                        var tS = r.texture;
                        `);
            }
            shaderSystem._gl.uniform1i(uniformData.location, textureCount);
            funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
            textureCount++;
          }
        }
      }
    }
    const functionSource = [...headerFragments, ...funcFragments].join("\n");
    return new Function("r", "s", "sD", functionSource);
  }
  var init_GenerateShaderSyncCode = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
      init_BufferResource2();
      init_UniformGroup2();
      init_TextureSource();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgramData.mjs
  var GlProgramData;
  var init_GlProgramData = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
      "use strict";
      GlProgramData = class {
        constructor(program, uniformData) {
          this.program = program;
          this.uniformData = uniformData;
          this.uniformGroups = {};
          this.uniformDirtyGroups = {};
          this.uniformBlockBindings = {};
        }
        destroy() {
          this.uniformData = null;
          this.uniformGroups = null;
          this.uniformDirtyGroups = null;
          this.uniformBlockBindings = null;
          this.program = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/compileShader.mjs
  function compileShader2(gl, type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    return shader;
  }
  var init_compileShader2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
  function booleanArray2(size) {
    const array = new Array(size);
    for (let i2 = 0; i2 < array.length; i2++) {
      array[i2] = false;
    }
    return array;
  }
  function defaultValue2(type, size) {
    switch (type) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * size);
      case "vec3":
        return new Float32Array(3 * size);
      case "vec4":
        return new Float32Array(4 * size);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * size);
      case "ivec3":
        return new Int32Array(3 * size);
      case "ivec4":
        return new Int32Array(4 * size);
      case "uvec2":
        return new Uint32Array(2 * size);
      case "uvec3":
        return new Uint32Array(3 * size);
      case "uvec4":
        return new Uint32Array(4 * size);
      case "bool":
        return false;
      case "bvec2":
        return booleanArray2(2 * size);
      case "bvec3":
        return booleanArray2(3 * size);
      case "bvec4":
        return booleanArray2(4 * size);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  var init_defaultValue2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/mapType.mjs
  function mapType2(gl, type) {
    if (!GL_TABLE2) {
      const typeNames = Object.keys(GL_TO_GLSL_TYPES2);
      GL_TABLE2 = {};
      for (let i2 = 0; i2 < typeNames.length; ++i2) {
        const tn = typeNames[i2];
        GL_TABLE2[gl[tn]] = GL_TO_GLSL_TYPES2[tn];
      }
    }
    return GL_TABLE2[type];
  }
  function mapGlToVertexFormat(gl, type) {
    const typeValue = mapType2(gl, type);
    return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
  }
  var GL_TABLE2, GL_TO_GLSL_TYPES2, GLSL_TO_VERTEX_TYPES;
  var init_mapType2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
      "use strict";
      GL_TABLE2 = null;
      GL_TO_GLSL_TYPES2 = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
      };
      GLSL_TO_VERTEX_TYPES = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
  function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
    const attributes = {};
    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i2 = 0; i2 < totalAttributes; i2++) {
      const attribData = gl.getActiveAttrib(program, i2);
      if (attribData.name.startsWith("gl_")) {
        continue;
      }
      const format2 = mapGlToVertexFormat(gl, attribData.type);
      attributes[attribData.name] = {
        location: 0,
        format: format2,
        stride: getAttributeInfoFromFormat(format2).stride,
        offset: 0,
        instance: false,
        start: 0
      };
    }
    const keys = Object.keys(attributes);
    if (sortAttributes) {
      keys.sort((a2, b2) => a2 > b2 ? 1 : -1);
      for (let i2 = 0; i2 < keys.length; i2++) {
        attributes[keys[i2]].location = i2;
        gl.bindAttribLocation(program, i2, keys[i2]);
      }
      gl.linkProgram(program);
    } else {
      for (let i2 = 0; i2 < keys.length; i2++) {
        attributes[keys[i2]].location = gl.getAttribLocation(program, keys[i2]);
      }
    }
    return attributes;
  }
  var init_extractAttributesFromGlProgram = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
      init_getAttributeInfoFromFormat();
      init_mapType2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUboData.mjs
  function getUboData(program, gl) {
    if (!gl.ACTIVE_UNIFORM_BLOCKS)
      return {};
    const uniformBlocks = {};
    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
      const name = gl.getActiveUniformBlockName(program, i2);
      const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
      const size = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
      uniformBlocks[name] = {
        name,
        index: uniformBlockIndex,
        size
      };
    }
    return uniformBlocks;
  }
  var init_getUboData = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
  function getUniformData2(program, gl) {
    const uniforms = {};
    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < totalUniforms; i2++) {
      const uniformData = gl.getActiveUniform(program, i2);
      const name = uniformData.name.replace(/\[.*?\]$/, "");
      const isArray = !!uniformData.name.match(/\[.*?\]$/);
      const type = mapType2(gl, uniformData.type);
      uniforms[name] = {
        name,
        index: i2,
        type,
        size: uniformData.size,
        isArray,
        value: defaultValue2(type, uniformData.size)
      };
    }
    return uniforms;
  }
  var init_getUniformData2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
      init_defaultValue2();
      init_mapType2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
  function logPrettyShaderError2(gl, shader) {
    const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
    const shaderLog = gl.getShaderInfoLog(shader);
    const splitShader = shaderLog.split("\n");
    const dedupe = {};
    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
      if (n2 && !dedupe[n2]) {
        dedupe[n2] = true;
        return true;
      }
      return false;
    });
    const logArgs = [""];
    lineNumbers.forEach((number) => {
      shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
      logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    const fragmentSourceToLog = shaderSrc.join("\n");
    logArgs[0] = fragmentSourceToLog;
    console.error(shaderLog);
    console.groupCollapsed("click to view full shader code");
    console.warn(...logArgs);
    console.groupEnd();
  }
  function logProgramError2(gl, program, vertexShader, fragmentShader) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError2(gl, vertexShader);
      }
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        logPrettyShaderError2(gl, fragmentShader);
      }
      console.error("PixiJS Error: Could not initialize shader.");
      if (gl.getProgramInfoLog(program) !== "") {
        console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
      }
    }
  }
  var init_logProgramError2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
  function generateProgram2(gl, program) {
    const glVertShader = compileShader2(gl, gl.VERTEX_SHADER, program.vertex);
    const glFragShader = compileShader2(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    if (transformFeedbackVaryings) {
      if (typeof gl.transformFeedbackVaryings !== "function") {
        warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
      } else {
        gl.transformFeedbackVaryings(
          webGLProgram,
          transformFeedbackVaryings.names,
          transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
        );
      }
    }
    gl.linkProgram(webGLProgram);
    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
      logProgramError2(gl, webGLProgram, glVertShader, glFragShader);
    }
    program._attributeData = extractAttributesFromGlProgram(
      webGLProgram,
      gl,
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
    );
    program._uniformData = getUniformData2(webGLProgram, gl);
    program._uniformBlockData = getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    const uniformData = {};
    for (const i2 in program._uniformData) {
      const data = program._uniformData[i2];
      uniformData[i2] = {
        location: gl.getUniformLocation(webGLProgram, i2),
        value: defaultValue2(data.type, data.size)
      };
    }
    const glProgram3 = new GlProgramData(webGLProgram, uniformData);
    return glProgram3;
  }
  var init_generateProgram2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
      init_warn();
      init_GlProgramData();
      init_compileShader2();
      init_defaultValue2();
      init_extractAttributesFromGlProgram();
      init_getUboData();
      init_getUniformData2();
      init_logProgramError2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
  var defaultSyncData2, GlShaderSystem;
  var init_GlShaderSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
      init_Extensions();
      init_maxRecommendedTextures2();
      init_GenerateShaderSyncCode();
      init_generateProgram2();
      defaultSyncData2 = {
        textureCount: 0,
        blockIndex: 0
      };
      GlShaderSystem = class {
        constructor(renderer) {
          this._activeProgram = null;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._nextIndex = 0;
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
          this._programDataHash = /* @__PURE__ */ Object.create(null);
          this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
          this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
          this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
          this._activeProgram = null;
          this.maxTextures = getMaxTexturesPerBatch();
        }
        bind(shader, skipSync) {
          this._setProgram(shader.glProgram);
          if (skipSync)
            return;
          defaultSyncData2.textureCount = 0;
          defaultSyncData2.blockIndex = 0;
          let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
          if (!syncFunction) {
            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
          }
          syncFunction(this._renderer, shader, defaultSyncData2);
        }
        updateUniformGroup(uniformGroup) {
          this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData2);
        }
        bindUniformBlock(uniformGroup, name, index = 0) {
          const bufferSystem = this._renderer.buffer;
          const programData = this._getProgramData(this._activeProgram);
          const isBufferResource = uniformGroup._bufferResource;
          if (isBufferResource) {
            this._renderer.ubo.updateUniformGroup(uniformGroup);
          }
          bufferSystem.updateBuffer(uniformGroup.buffer);
          let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
          if (boundIndex === void 0) {
            const nextIndex = this._nextIndex++ % this._maxBindings;
            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
            if (currentBoundUniformGroup) {
              this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
            }
            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
            if (isBufferResource) {
              bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
            } else {
              bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
            }
          }
          const gl = this._gl;
          const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
          if (programData.uniformBlockBindings[index] === boundIndex)
            return;
          programData.uniformBlockBindings[index] = boundIndex;
          gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
        }
        _setProgram(program) {
          if (this._activeProgram === program)
            return;
          this._activeProgram = program;
          const programData = this._getProgramData(program);
          this._gl.useProgram(programData.program);
        }
        _getProgramData(program) {
          return this._programDataHash[program._key] || this._createProgramData(program);
        }
        _createProgramData(program) {
          const key = program._key;
          this._programDataHash[key] = generateProgram2(this._gl, program);
          return this._programDataHash[key];
        }
        destroy() {
          for (const key of Object.keys(this._programDataHash)) {
            const programData = this._programDataHash[key];
            programData.destroy();
            this._programDataHash[key] = null;
          }
          this._programDataHash = null;
          this._boundUniformsIdsToIndexHash = null;
        }
        _generateShaderSync(shader, shaderSystem) {
          return generateShaderSyncCode(shader, shaderSystem);
        }
      };
      GlShaderSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "shader"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
  var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
  var init_generateUniformsSyncTypes = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
      "use strict";
      UNIFORM_TO_SINGLE_SETTERS = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
      };
      UNIFORM_TO_ARRAY_SETTERS = {
        f32: `gl.uniform1fv(location, v);`,
        "vec2<f32>": `gl.uniform2fv(location, v);`,
        "vec3<f32>": `gl.uniform3fv(location, v);`,
        "vec4<f32>": `gl.uniform4fv(location, v);`,
        "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
        "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
        "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
        i32: `gl.uniform1iv(location, v);`,
        "vec2<i32>": `gl.uniform2iv(location, v);`,
        "vec3<i32>": `gl.uniform3iv(location, v);`,
        "vec4<i32>": `gl.uniform4iv(location, v);`,
        u32: `gl.uniform1iv(location, v);`,
        "vec2<u32>": `gl.uniform2iv(location, v);`,
        "vec3<u32>": `gl.uniform3iv(location, v);`,
        "vec4<u32>": `gl.uniform4iv(location, v);`,
        bool: `gl.uniform1iv(location, v);`,
        "vec2<bool>": `gl.uniform2iv(location, v);`,
        "vec3<bool>": `gl.uniform3iv(location, v);`,
        "vec4<bool>": `gl.uniform4iv(location, v);`
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
  function generateUniformsSync2(group, uniformData) {
    const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const i2 in group.uniforms) {
      if (!uniformData[i2]) {
        if (group.uniforms[i2] instanceof UniformGroup2) {
          if (group.uniforms[i2].ubo) {
            funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
          } else {
            funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
          }
        } else if (group.uniforms[i2] instanceof BufferResource2) {
          funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
        }
        continue;
      }
      const uniform = group.uniformStructures[i2];
      let parsed = false;
      for (let j2 = 0; j2 < uniformParsers2.length; j2++) {
        const parser = uniformParsers2[j2];
        if (uniform.type === parser.type && parser.test(uniform)) {
          funcFragments.push(`name = "${i2}";`, uniformParsers2[j2].uniform);
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
        const template = templateType[uniform.type].replace("location", `ud["${i2}"].location`);
        funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
      }
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  }
  var init_generateUniformsSync2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
      init_BufferResource2();
      init_UniformGroup2();
      init_uniformParsers2();
      init_generateUniformsSyncTypes();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
  var GlUniformGroupSystem;
  var init_GlUniformGroupSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
      init_Extensions();
      init_generateUniformsSync2();
      GlUniformGroupSystem = class {
        constructor(renderer) {
          this._cache = {};
          this._uniformGroupSyncHash = {};
          this._renderer = renderer;
          this.gl = null;
          this._cache = {};
        }
        contextChange(gl) {
          this.gl = gl;
        }
        updateUniformGroup(group, program, syncData) {
          const programData = this._renderer.shader._getProgramData(program);
          if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
            programData.uniformDirtyGroups[group.uid] = group._dirtyId;
            const syncFunc = this._getUniformSyncFunction(group, program);
            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
          }
        }
        _getUniformSyncFunction(group, program) {
          return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
        }
        _createUniformSyncFunction(group, program) {
          const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
          const id = this._getSignature(group, program._uniformData, "u");
          if (!this._cache[id]) {
            this._cache[id] = this._generateUniformsSync(group, program._uniformData);
          }
          uniformGroupSyncHash[program._key] = this._cache[id];
          return uniformGroupSyncHash[program._key];
        }
        _generateUniformsSync(group, uniformData) {
          return generateUniformsSync2(group, uniformData);
        }
        _getSignature(group, uniformData, preFix) {
          const uniforms = group.uniforms;
          const strings = [`${preFix}-`];
          for (const i2 in uniforms) {
            strings.push(i2);
            if (uniformData[i2]) {
              strings.push(uniformData[i2].type);
            }
          }
          return strings.join("-");
        }
        destroy() {
          this._renderer = null;
          this._cache = null;
        }
      };
      GlUniformGroupSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "uniformGroup"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
  function mapWebGLBlendModesToPixi2(gl) {
    const blendMap = {};
    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.add = [gl.ONE, gl.ONE];
    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.none = [0, 0];
    blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
    blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
    if (isWebGl2) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
    } else {
      const ext = gl.getExtension("EXT_blend_minmax");
      if (ext) {
        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
      }
    }
    return blendMap;
  }
  var init_mapWebGLBlendModesToPixi2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
      init_adapter2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/state/GlStateSystem.mjs
  var BLEND4, OFFSET4, CULLING4, DEPTH_TEST4, WINDING4, DEPTH_MASK4, _GlStateSystem, GlStateSystem;
  var init_GlStateSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
      init_Extensions();
      init_State2();
      init_mapWebGLBlendModesToPixi2();
      BLEND4 = 0;
      OFFSET4 = 1;
      CULLING4 = 2;
      DEPTH_TEST4 = 3;
      WINDING4 = 4;
      DEPTH_MASK4 = 5;
      _GlStateSystem = class _GlStateSystem2 {
        constructor() {
          this.gl = null;
          this.stateId = 0;
          this.polygonOffset = 0;
          this.blendMode = "none";
          this._blendEq = false;
          this.map = [];
          this.map[BLEND4] = this.setBlend;
          this.map[OFFSET4] = this.setOffset;
          this.map[CULLING4] = this.setCullFace;
          this.map[DEPTH_TEST4] = this.setDepthTest;
          this.map[WINDING4] = this.setFrontFace;
          this.map[DEPTH_MASK4] = this.setDepthMask;
          this.checks = [];
          this.defaultState = State2.for2d();
        }
        contextChange(gl) {
          this.gl = gl;
          this.blendModesMap = mapWebGLBlendModesToPixi2(gl);
          this.reset();
        }
        set(state) {
          state = state || this.defaultState;
          if (this.stateId !== state.data) {
            let diff = this.stateId ^ state.data;
            let i2 = 0;
            while (diff) {
              if (diff & 1) {
                this.map[i2].call(this, !!(state.data & 1 << i2));
              }
              diff = diff >> 1;
              i2++;
            }
            this.stateId = state.data;
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state);
          }
        }
        forceState(state) {
          state = state || this.defaultState;
          for (let i2 = 0; i2 < this.map.length; i2++) {
            this.map[i2].call(this, !!(state.data & 1 << i2));
          }
          for (let i2 = 0; i2 < this.checks.length; i2++) {
            this.checks[i2](this, state);
          }
          this.stateId = state.data;
        }
        setBlend(value) {
          this._updateCheck(_GlStateSystem2._checkBlendMode, value);
          this.gl[value ? "enable" : "disable"](this.gl.BLEND);
        }
        setOffset(value) {
          this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
          this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(value) {
          this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }
        setDepthMask(value) {
          this.gl.depthMask(value);
        }
        setCullFace(value) {
          this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        }
        setFrontFace(value) {
          this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
        }
        setBlendMode(value) {
          if (!this.blendModesMap[value]) {
            value = "normal";
          }
          if (value === this.blendMode) {
            return;
          }
          this.blendMode = value;
          const mode = this.blendModesMap[value];
          const gl = this.gl;
          if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
          } else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
          }
          if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
          } else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
          }
        }
        setPolygonOffset(value, scale) {
          this.gl.polygonOffset(value, scale);
        }
        reset() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
          this.forceState(this.defaultState);
          this._blendEq = true;
          this.blendMode = "";
          this.setBlendMode("normal");
        }
        _updateCheck(func, value) {
          const index = this.checks.indexOf(func);
          if (value && index === -1) {
            this.checks.push(func);
          } else if (!value && index !== -1) {
            this.checks.splice(index, 1);
          }
        }
        static _checkBlendMode(system, state) {
          system.setBlendMode(state.blendMode);
        }
        static _checkPolygonOffset(system, state) {
          system.setPolygonOffset(1, state.polygonOffset);
        }
        destroy() {
          this.gl = null;
          this.checks.length = 0;
        }
      };
      _GlStateSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "state"
      };
      GlStateSystem = _GlStateSystem;
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTexture.mjs
  var GlTexture;
  var init_GlTexture = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
      init_const16();
      GlTexture = class {
        constructor(texture) {
          this.target = GL_TARGETS.TEXTURE_2D;
          this.texture = texture;
          this.width = -1;
          this.height = -1;
          this.type = GL_TYPES.UNSIGNED_BYTE;
          this.internalFormat = GL_FORMATS.RGBA;
          this.format = GL_FORMATS.RGBA;
          this.samplerType = 0;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
  var glUploadBufferImageResource;
  var init_glUploadBufferImageResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
      "use strict";
      glUploadBufferImageResource = {
        id: "buffer",
        upload(source2, glTexture, gl) {
          if (glTexture.width === source2.width || glTexture.height === source2.height) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              source2.width,
              source2.height,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              source2.width,
              source2.height,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
          glTexture.width = source2.width;
          glTexture.height = source2.height;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
  var compressedFormatMap, glUploadCompressedTextureResource;
  var init_glUploadCompressedTextureResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
      "use strict";
      compressedFormatMap = {
        "bc1-rgba-unorm": true,
        "bc1-rgba-unorm-srgb": true,
        "bc2-rgba-unorm": true,
        "bc2-rgba-unorm-srgb": true,
        "bc3-rgba-unorm": true,
        "bc3-rgba-unorm-srgb": true,
        "bc4-r-unorm": true,
        "bc4-r-snorm": true,
        "bc5-rg-unorm": true,
        "bc5-rg-snorm": true,
        "bc6h-rgb-ufloat": true,
        "bc6h-rgb-float": true,
        "bc7-rgba-unorm": true,
        "bc7-rgba-unorm-srgb": true,
        "etc2-rgb8unorm": true,
        "etc2-rgb8unorm-srgb": true,
        "etc2-rgb8a1unorm": true,
        "etc2-rgb8a1unorm-srgb": true,
        "etc2-rgba8unorm": true,
        "etc2-rgba8unorm-srgb": true,
        "eac-r11unorm": true,
        "eac-r11snorm": true,
        "eac-rg11unorm": true,
        "eac-rg11snorm": true,
        "astc-4x4-unorm": true,
        "astc-4x4-unorm-srgb": true,
        "astc-5x4-unorm": true,
        "astc-5x4-unorm-srgb": true,
        "astc-5x5-unorm": true,
        "astc-5x5-unorm-srgb": true,
        "astc-6x5-unorm": true,
        "astc-6x5-unorm-srgb": true,
        "astc-6x6-unorm": true,
        "astc-6x6-unorm-srgb": true,
        "astc-8x5-unorm": true,
        "astc-8x5-unorm-srgb": true,
        "astc-8x6-unorm": true,
        "astc-8x6-unorm-srgb": true,
        "astc-8x8-unorm": true,
        "astc-8x8-unorm-srgb": true,
        "astc-10x5-unorm": true,
        "astc-10x5-unorm-srgb": true,
        "astc-10x6-unorm": true,
        "astc-10x6-unorm-srgb": true,
        "astc-10x8-unorm": true,
        "astc-10x8-unorm-srgb": true,
        "astc-10x10-unorm": true,
        "astc-10x10-unorm-srgb": true,
        "astc-12x10-unorm": true,
        "astc-12x10-unorm-srgb": true,
        "astc-12x12-unorm": true,
        "astc-12x12-unorm-srgb": true
      };
      glUploadCompressedTextureResource = {
        id: "compressed",
        upload(source2, glTexture, gl) {
          gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
          let mipWidth = source2.pixelWidth;
          let mipHeight = source2.pixelHeight;
          const compressed = !!compressedFormatMap[source2.format];
          for (let i2 = 0; i2 < source2.resource.length; i2++) {
            const levelBuffer = source2.resource[i2];
            if (compressed) {
              gl.compressedTexImage2D(
                gl.TEXTURE_2D,
                i2,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                levelBuffer
              );
            } else {
              gl.texImage2D(
                gl.TEXTURE_2D,
                i2,
                glTexture.internalFormat,
                mipWidth,
                mipHeight,
                0,
                glTexture.format,
                glTexture.type,
                levelBuffer
              );
            }
            mipWidth = Math.max(mipWidth >> 1, 1);
            mipHeight = Math.max(mipHeight >> 1, 1);
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
  var glUploadImageResource;
  var init_glUploadImageResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
      "use strict";
      glUploadImageResource = {
        id: "image",
        upload(source2, glTexture, gl, webGLVersion) {
          const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
          const glWidth = glTexture.width;
          const glHeight = glTexture.height;
          const textureWidth = source2.pixelWidth;
          const textureHeight = source2.pixelHeight;
          const resourceWidth = source2.resourceWidth;
          const resourceHeight = source2.resourceHeight;
          if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
            if (glWidth !== textureWidth || glHeight !== textureHeight) {
              gl.texImage2D(
                glTexture.target,
                0,
                glTexture.internalFormat,
                textureWidth,
                textureHeight,
                0,
                glTexture.format,
                glTexture.type,
                null
              );
            }
            if (webGLVersion === 2) {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                resourceWidth,
                resourceHeight,
                glTexture.format,
                glTexture.type,
                source2.resource
              );
            } else {
              gl.texSubImage2D(
                gl.TEXTURE_2D,
                0,
                0,
                0,
                glTexture.format,
                glTexture.type,
                source2.resource
              );
            }
          } else if (glWidth === textureWidth || glHeight === textureHeight) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else if (webGLVersion === 2) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
          glTexture.width = textureWidth;
          glTexture.height = textureHeight;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
  var glUploadVideoResource;
  var init_glUploadVideoResource = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
      init_glUploadImageResource();
      glUploadVideoResource = {
        id: "video",
        upload(source2, glTexture, gl, webGLVersion) {
          if (!source2.isValid) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              1,
              1,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
            return;
          }
          glUploadImageResource.upload(source2, glTexture, gl, webGLVersion);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
  var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
  var init_pixiToGlMaps = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
      "use strict";
      scaleModeToGlFilter = {
        linear: 9729,
        nearest: 9728
      };
      mipmapScaleModeToGlFilter = {
        linear: {
          linear: 9987,
          nearest: 9985
        },
        nearest: {
          linear: 9986,
          nearest: 9984
        }
      };
      wrapModeToGlAddress = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
      };
      compareModeToGlCompare = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
  function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
    const castParam = firstParam;
    if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
      const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
      const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
      const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
      if (gl.TEXTURE_WRAP_R)
        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
    }
    if (!firstCreation || style.magFilter !== "linear") {
      gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
    }
    if (mipmaps) {
      if (!firstCreation || style.mipmapFilter !== "linear") {
        const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
      }
    } else {
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
    }
    if (anisotropicExt && style.maxAnisotropy > 1) {
      const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
      gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
    }
    if (style.compare) {
      gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
    }
  }
  var init_applyStyleParams = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
      init_pixiToGlMaps();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
  function mapFormatToGlFormat(gl) {
    return {
      r8unorm: gl.RED,
      r8snorm: gl.RED,
      r8uint: gl.RED,
      r8sint: gl.RED,
      r16uint: gl.RED,
      r16sint: gl.RED,
      r16float: gl.RED,
      rg8unorm: gl.RG,
      rg8snorm: gl.RG,
      rg8uint: gl.RG,
      rg8sint: gl.RG,
      r32uint: gl.RED,
      r32sint: gl.RED,
      r32float: gl.RED,
      rg16uint: gl.RG,
      rg16sint: gl.RG,
      rg16float: gl.RG,
      rgba8unorm: gl.RGBA,
      "rgba8unorm-srgb": gl.RGBA,
      rgba8snorm: gl.RGBA,
      rgba8uint: gl.RGBA,
      rgba8sint: gl.RGBA,
      bgra8unorm: gl.RGBA,
      "bgra8unorm-srgb": gl.RGBA,
      rgb9e5ufloat: gl.RGB,
      rgb10a2unorm: gl.RGBA,
      rg11b10ufloat: gl.RGB,
      rg32uint: gl.RG,
      rg32sint: gl.RG,
      rg32float: gl.RG,
      rgba16uint: gl.RGBA,
      rgba16sint: gl.RGBA,
      rgba16float: gl.RGBA,
      rgba32uint: gl.RGBA,
      rgba32sint: gl.RGBA,
      rgba32float: gl.RGBA,
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT,
      depth24plus: gl.DEPTH_COMPONENT,
      "depth24plus-stencil8": gl.DEPTH_STENCIL,
      depth32float: gl.DEPTH_COMPONENT,
      "depth32float-stencil8": gl.DEPTH_STENCIL
    };
  }
  var init_mapFormatToGlFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
  function mapFormatToGlInternalFormat(gl, extensions4) {
    let srgb = {};
    let bgra8unorm = gl.RGBA;
    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
      srgb = {
        "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
        "bgra8unorm-srgb": gl.SRGB8_ALPHA8
      };
      bgra8unorm = gl.RGBA8;
    } else if (extensions4.srgb) {
      srgb = {
        "rgba8unorm-srgb": extensions4.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": extensions4.srgb.SRGB8_ALPHA8_EXT
      };
    }
    return {
      r8unorm: gl.R8,
      r8snorm: gl.R8_SNORM,
      r8uint: gl.R8UI,
      r8sint: gl.R8I,
      r16uint: gl.R16UI,
      r16sint: gl.R16I,
      r16float: gl.R16F,
      rg8unorm: gl.RG8,
      rg8snorm: gl.RG8_SNORM,
      rg8uint: gl.RG8UI,
      rg8sint: gl.RG8I,
      r32uint: gl.R32UI,
      r32sint: gl.R32I,
      r32float: gl.R32F,
      rg16uint: gl.RG16UI,
      rg16sint: gl.RG16I,
      rg16float: gl.RG16F,
      rgba8unorm: gl.RGBA,
      ...srgb,
      rgba8snorm: gl.RGBA8_SNORM,
      rgba8uint: gl.RGBA8UI,
      rgba8sint: gl.RGBA8I,
      bgra8unorm,
      rgb9e5ufloat: gl.RGB9_E5,
      rgb10a2unorm: gl.RGB10_A2,
      rg11b10ufloat: gl.R11F_G11F_B10F,
      rg32uint: gl.RG32UI,
      rg32sint: gl.RG32I,
      rg32float: gl.RG32F,
      rgba16uint: gl.RGBA16UI,
      rgba16sint: gl.RGBA16I,
      rgba16float: gl.RGBA16F,
      rgba32uint: gl.RGBA32UI,
      rgba32sint: gl.RGBA32I,
      rgba32float: gl.RGBA32F,
      stencil8: gl.STENCIL_INDEX8,
      depth16unorm: gl.DEPTH_COMPONENT16,
      depth24plus: gl.DEPTH_COMPONENT24,
      "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
      depth32float: gl.DEPTH_COMPONENT32F,
      "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
      ...extensions4.s3tc ? {
        "bc1-rgba-unorm": extensions4.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm": extensions4.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm": extensions4.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } : {},
      ...extensions4.s3tc_sRGB ? {
        "bc1-rgba-unorm-srgb": extensions4.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        "bc2-rgba-unorm-srgb": extensions4.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        "bc3-rgba-unorm-srgb": extensions4.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
      } : {},
      ...extensions4.rgtc ? {
        "bc4-r-unorm": extensions4.rgtc.COMPRESSED_RED_RGTC1_EXT,
        "bc4-r-snorm": extensions4.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
        "bc5-rg-unorm": extensions4.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
        "bc5-rg-snorm": extensions4.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } : {},
      ...extensions4.bptc ? {
        "bc6h-rgb-float": extensions4.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        "bc6h-rgb-ufloat": extensions4.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        "bc7-rgba-unorm": extensions4.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        "bc7-rgba-unorm-srgb": extensions4.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
      } : {},
      ...extensions4.etc ? {
        "etc2-rgb8unorm": extensions4.etc.COMPRESSED_RGB8_ETC2,
        "etc2-rgb8unorm-srgb": extensions4.etc.COMPRESSED_SRGB8_ETC2,
        "etc2-rgb8a1unorm": extensions4.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgb8a1unorm-srgb": extensions4.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
        "etc2-rgba8unorm": extensions4.etc.COMPRESSED_RGBA8_ETC2_EAC,
        "etc2-rgba8unorm-srgb": extensions4.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
        "eac-r11unorm": extensions4.etc.COMPRESSED_R11_EAC,
        "eac-rg11unorm": extensions4.etc.COMPRESSED_SIGNED_RG11_EAC
      } : {},
      ...extensions4.astc ? {
        "astc-4x4-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
        "astc-4x4-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
        "astc-5x4-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
        "astc-5x4-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
        "astc-5x5-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
        "astc-5x5-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
        "astc-6x5-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
        "astc-6x5-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
        "astc-6x6-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
        "astc-6x6-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
        "astc-8x5-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
        "astc-8x5-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
        "astc-8x6-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
        "astc-8x6-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
        "astc-8x8-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
        "astc-8x8-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
        "astc-10x5-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
        "astc-10x5-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
        "astc-10x6-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
        "astc-10x6-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
        "astc-10x8-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
        "astc-10x8-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
        "astc-10x10-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
        "astc-10x10-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
        "astc-12x10-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
        "astc-12x10-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
        "astc-12x12-unorm": extensions4.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
        "astc-12x12-unorm-srgb": extensions4.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
      } : {}
    };
  }
  var init_mapFormatToGlInternalFormat = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
      init_adapter2();
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
  function mapFormatToGlType(gl) {
    return {
      r8unorm: gl.UNSIGNED_BYTE,
      r8snorm: gl.BYTE,
      r8uint: gl.UNSIGNED_BYTE,
      r8sint: gl.BYTE,
      r16uint: gl.UNSIGNED_SHORT,
      r16sint: gl.SHORT,
      r16float: gl.HALF_FLOAT,
      rg8unorm: gl.UNSIGNED_BYTE,
      rg8snorm: gl.BYTE,
      rg8uint: gl.UNSIGNED_BYTE,
      rg8sint: gl.BYTE,
      r32uint: gl.UNSIGNED_INT,
      r32sint: gl.INT,
      r32float: gl.FLOAT,
      rg16uint: gl.UNSIGNED_SHORT,
      rg16sint: gl.SHORT,
      rg16float: gl.HALF_FLOAT,
      rgba8unorm: gl.UNSIGNED_BYTE,
      "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
      rgba8snorm: gl.BYTE,
      rgba8uint: gl.UNSIGNED_BYTE,
      rgba8sint: gl.BYTE,
      bgra8unorm: gl.UNSIGNED_BYTE,
      "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
      rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: gl.UNSIGNED_INT,
      rg32sint: gl.INT,
      rg32float: gl.FLOAT,
      rgba16uint: gl.UNSIGNED_SHORT,
      rgba16sint: gl.SHORT,
      rgba16float: gl.HALF_FLOAT,
      rgba32uint: gl.UNSIGNED_INT,
      rgba32sint: gl.INT,
      rgba32float: gl.FLOAT,
      stencil8: gl.UNSIGNED_BYTE,
      depth16unorm: gl.UNSIGNED_SHORT,
      depth24plus: gl.UNSIGNED_INT,
      "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
      depth32float: gl.FLOAT,
      "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
    };
  }
  var init_mapFormatToGlType = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
  var BYTES_PER_PIXEL2, GlTextureSystem;
  var init_GlTextureSystem = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
      init_adapter2();
      init_Extensions();
      init_Texture2();
      init_GlTexture();
      init_glUploadBufferImageResource();
      init_glUploadCompressedTextureResource();
      init_glUploadImageResource();
      init_glUploadVideoResource();
      init_applyStyleParams();
      init_mapFormatToGlFormat();
      init_mapFormatToGlInternalFormat();
      init_mapFormatToGlType();
      BYTES_PER_PIXEL2 = 4;
      GlTextureSystem = class {
        constructor(renderer) {
          this.managedTextures = [];
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundTextures = [];
          this._activeTextureLocation = -1;
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          this._uploads = {
            image: glUploadImageResource,
            buffer: glUploadBufferImageResource,
            video: glUploadVideoResource,
            compressed: glUploadCompressedTextureResource
          };
          this._useSeparateSamplers = false;
          this._renderer = renderer;
        }
        contextChange(gl) {
          this._gl = gl;
          if (!this._mapFormatToInternalFormat) {
            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
            this._mapFormatToType = mapFormatToGlType(gl);
            this._mapFormatToFormat = mapFormatToGlFormat(gl);
          }
          this._glTextures = /* @__PURE__ */ Object.create(null);
          this._glSamplers = /* @__PURE__ */ Object.create(null);
          this._boundSamplers = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < 16; i2++) {
            this.bind(Texture2.EMPTY, i2);
          }
        }
        initSource(source2) {
          this.bind(source2);
        }
        bind(texture, location = 0) {
          const source2 = texture.source;
          if (texture) {
            this.bindSource(source2, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(source2.style, location);
            }
          } else {
            this.bindSource(null, location);
            if (this._useSeparateSamplers) {
              this._bindSampler(null, location);
            }
          }
        }
        bindSource(source2, location = 0) {
          const gl = this._gl;
          source2._touched = this._renderer.textureGC.count;
          if (this._boundTextures[location] !== source2) {
            this._boundTextures[location] = source2;
            this._activateLocation(location);
            source2 = source2 || Texture2.EMPTY.source;
            const glTexture = this.getGlSource(source2);
            gl.bindTexture(glTexture.target, glTexture.texture);
          }
        }
        _bindSampler(style, location = 0) {
          const gl = this._gl;
          if (!style) {
            this._boundSamplers[location] = null;
            gl.bindSampler(location, null);
            return;
          }
          const sampler = this._getGlSampler(style);
          if (this._boundSamplers[location] !== sampler) {
            this._boundSamplers[location] = sampler;
            gl.bindSampler(location, sampler);
          }
        }
        unbind(texture) {
          const source2 = texture.source;
          const boundTextures = this._boundTextures;
          const gl = this._gl;
          for (let i2 = 0; i2 < boundTextures.length; i2++) {
            if (boundTextures[i2] === source2) {
              this._activateLocation(i2);
              const glTexture = this.getGlSource(source2);
              gl.bindTexture(glTexture.target, null);
              boundTextures[i2] = null;
            }
          }
        }
        _activateLocation(location) {
          if (this._activeTextureLocation !== location) {
            this._activeTextureLocation = location;
            this._gl.activeTexture(this._gl.TEXTURE0 + location);
          }
        }
        _initSource(source2) {
          const gl = this._gl;
          const glTexture = new GlTexture(gl.createTexture());
          glTexture.type = this._mapFormatToType[source2.format];
          glTexture.internalFormat = this._mapFormatToInternalFormat[source2.format];
          glTexture.format = this._mapFormatToFormat[source2.format];
          if (source2.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source2.isPowerOfTwo)) {
            const biggestDimension = Math.max(source2.width, source2.height);
            source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
          }
          this._glTextures[source2.uid] = glTexture;
          if (!this.managedTextures.includes(source2)) {
            source2.on("update", this.onSourceUpdate, this);
            source2.on("resize", this.onSourceUpdate, this);
            source2.on("styleChange", this.onStyleChange, this);
            source2.on("destroy", this.onSourceDestroy, this);
            source2.on("unload", this.onSourceUnload, this);
            source2.on("updateMipmaps", this.onUpdateMipmaps, this);
            this.managedTextures.push(source2);
          }
          this.onSourceUpdate(source2);
          this.updateStyle(source2, false);
          return glTexture;
        }
        onStyleChange(source2) {
          this.updateStyle(source2, false);
        }
        updateStyle(source2, firstCreation) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source2);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source2;
          applyStyleParams(
            source2.style,
            gl,
            source2.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "texParameteri",
            gl.TEXTURE_2D,
            !this._renderer.context.supports.nonPowOf2wrapping && !source2.isPowerOfTwo,
            firstCreation
          );
        }
        onSourceUnload(source2) {
          const glTexture = this._glTextures[source2.uid];
          if (!glTexture)
            return;
          this.unbind(source2);
          this._glTextures[source2.uid] = null;
          this._gl.deleteTexture(glTexture.texture);
        }
        onSourceUpdate(source2) {
          const gl = this._gl;
          const glTexture = this.getGlSource(source2);
          gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
          this._boundTextures[this._activeTextureLocation] = source2;
          if (this._uploads[source2.uploadMethodId]) {
            this._uploads[source2.uploadMethodId].upload(source2, glTexture, gl, this._renderer.context.webGLVersion);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source2.pixelWidth, source2.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
            this.onUpdateMipmaps(source2, false);
          }
        }
        onUpdateMipmaps(source2, bind = true) {
          if (bind)
            this.bindSource(source2, 0);
          const glTexture = this.getGlSource(source2);
          this._gl.generateMipmap(glTexture.target);
        }
        onSourceDestroy(source2) {
          source2.off("destroy", this.onSourceDestroy, this);
          source2.off("update", this.onSourceUpdate, this);
          source2.off("resize", this.onSourceUpdate, this);
          source2.off("unload", this.onSourceUnload, this);
          source2.off("styleChange", this.onStyleChange, this);
          source2.off("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
          this.onSourceUnload(source2);
        }
        _initSampler(style) {
          const gl = this._gl;
          const glSampler = this._gl.createSampler();
          this._glSamplers[style._resourceId] = glSampler;
          applyStyleParams(
            style,
            gl,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            "samplerParameteri",
            glSampler,
            false,
            true
          );
          return this._glSamplers[style._resourceId];
        }
        _getGlSampler(sampler) {
          return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
        }
        getGlSource(source2) {
          return this._glTextures[source2.uid] || this._initSource(source2);
        }
        generateCanvas(texture) {
          const { pixels, width, height } = this.getPixels(texture);
          const canvas = DOMAdapter.get().createCanvas();
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (ctx) {
            const imageData = ctx.createImageData(width, height);
            imageData.data.set(pixels);
            ctx.putImageData(imageData, 0, 0);
          }
          return canvas;
        }
        getPixels(texture) {
          const resolution = texture.source.resolution;
          const frame = texture.frame;
          const width = Math.max(Math.round(frame.width * resolution), 1);
          const height = Math.max(Math.round(frame.height * resolution), 1);
          const pixels = new Uint8Array(BYTES_PER_PIXEL2 * width * height);
          const renderer = this._renderer;
          const renderTarget = renderer.renderTarget.getRenderTarget(texture);
          const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
          const gl = renderer.gl;
          gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
          gl.readPixels(
            Math.round(frame.x * resolution),
            Math.round(frame.y * resolution),
            width,
            height,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            pixels
          );
          if (false) {
            unpremultiplyAlpha(pixels);
          }
          return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
        }
        destroy() {
          this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
          this.managedTextures = null;
          this._renderer = null;
        }
      };
      GlTextureSystem.extension = {
        type: [
          ExtensionType2.WebGLSystem
        ],
        name: "texture"
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/gl/WebGLRenderer.mjs
  var WebGLRenderer_exports = {};
  __export(WebGLRenderer_exports, {
    WebGLRenderer: () => WebGLRenderer
  });
  var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
  var init_WebGLRenderer = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
      init_Extensions();
      init_GlGraphicsAdaptor();
      init_GlMeshAdaptor();
      init_GlBatchAdaptor();
      init_AbstractRenderer();
      init_SharedSystems();
      init_types2();
      init_GlBufferSystem();
      init_GlContextSystem();
      init_GlGeometrySystem();
      init_GlBackBufferSystem();
      init_GlColorMaskSystem();
      init_GlEncoderSystem();
      init_GlStencilSystem();
      init_GlUboSystem();
      init_GlRenderTargetSystem();
      init_GlShaderSystem();
      init_GlUniformGroupSystem();
      init_GlStateSystem();
      init_GlTextureSystem();
      DefaultWebGLSystems = [
        ...SharedSystems,
        GlUboSystem,
        GlBackBufferSystem,
        GlContextSystem,
        GlBufferSystem,
        GlTextureSystem,
        GlRenderTargetSystem,
        GlGeometrySystem,
        GlUniformGroupSystem,
        GlShaderSystem,
        GlEncoderSystem,
        GlStateSystem,
        GlStencilSystem,
        GlColorMaskSystem
      ];
      DefaultWebGLPipes = [...SharedRenderPipes];
      DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
      systems2 = [];
      renderPipes2 = [];
      renderPipeAdaptors2 = [];
      extensions3.handleByNamedList(ExtensionType2.WebGLSystem, systems2);
      extensions3.handleByNamedList(ExtensionType2.WebGLPipes, renderPipes2);
      extensions3.handleByNamedList(ExtensionType2.WebGLPipesAdaptor, renderPipeAdaptors2);
      extensions3.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
      WebGLRenderer = class extends AbstractRenderer {
        constructor() {
          const systemConfig = {
            name: "webgl",
            type: RendererType.WEBGL,
            systems: systems2,
            renderPipes: renderPipes2,
            renderPipeAdaptors: renderPipeAdaptors2
          };
          super(systemConfig);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/rendering/renderers/autoDetectRenderer.mjs
  async function autoDetectRenderer2(options) {
    let preferredOrder = [];
    if (options.preference) {
      preferredOrder.push(options.preference);
      renderPriority.forEach((item) => {
        if (item !== options.preference) {
          preferredOrder.push(item);
        }
      });
    } else {
      preferredOrder = renderPriority.slice();
    }
    let RendererClass;
    let finalOptions = {};
    for (let i2 = 0; i2 < preferredOrder.length; i2++) {
      const rendererType = preferredOrder[i2];
      if (rendererType === "webgpu" && await isWebGPUSupported()) {
        const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
        RendererClass = WebGPURenderer2;
        finalOptions = { ...options, ...options.webgpu };
        break;
      } else if (rendererType === "webgl" && isWebGLSupported2(
        options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
      )) {
        const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
        RendererClass = WebGLRenderer2;
        finalOptions = { ...options, ...options.webgl };
        break;
      } else if (rendererType === "canvas") {
        finalOptions = { ...options };
        throw new Error("CanvasRenderer is not yet implemented");
      }
    }
    delete finalOptions.webgpu;
    delete finalOptions.webgl;
    if (!RendererClass) {
      throw new Error("No available renderer for the current environment");
    }
    const renderer = new RendererClass();
    await renderer.init(finalOptions);
    return renderer;
  }
  var renderPriority;
  var init_autoDetectRenderer2 = __esm({
    "node_modules/pixi-v8/lib/rendering/renderers/autoDetectRenderer.mjs"() {
      init_isWebGLSupported2();
      init_isWebGPUSupported();
      init_AbstractRenderer();
      renderPriority = ["webgl", "webgpu", "canvas"];
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/BitmapFont.mjs
  var BitmapFont2;
  var init_BitmapFont2 = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/BitmapFont.mjs"() {
      init_Rectangle2();
      init_Texture2();
      init_AbstractBitmapFont();
      init_BitmapFontManager();
      BitmapFont2 = class extends AbstractBitmapFont {
        constructor(options, url2) {
          super();
          const { textures, data } = options;
          Object.keys(data.pages).forEach((key) => {
            const pageData = data.pages[parseInt(key, 10)];
            const texture = textures[pageData.id];
            this.pages.push({ texture });
          });
          Object.keys(data.chars).forEach((key) => {
            const charData = data.chars[key];
            const {
              frame: textureFrame,
              source: textureSource
            } = textures[charData.page];
            const frameReal = new Rectangle2(
              charData.x + textureFrame.x,
              charData.y + textureFrame.y,
              charData.width,
              charData.height
            );
            const texture = new Texture2({
              source: textureSource,
              frame: frameReal
            });
            this.chars[key] = {
              id: key.codePointAt(0),
              xOffset: charData.xOffset,
              yOffset: charData.yOffset,
              xAdvance: charData.xAdvance,
              kerning: charData.kerning ?? {},
              texture
            };
          });
          this.baseRenderedFontSize = data.fontSize;
          this.baseMeasurementFontSize = data.fontSize;
          this.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: data.fontSize
          };
          this.baseLineOffset = data.baseLineOffset;
          this.lineHeight = data.lineHeight;
          this.fontFamily = data.fontFamily;
          this.distanceField = data.distanceField ?? {
            type: "none",
            range: 0
          };
          this.url = url2;
        }
        destroy() {
          super.destroy();
          for (let i2 = 0; i2 < this.pages.length; i2++) {
            const { texture } = this.pages[i2];
            texture.destroy(true);
          }
          this.pages = null;
        }
        static install(options) {
          BitmapFontManager.install(options);
        }
        static uninstall(name) {
          BitmapFontManager.uninstall(name);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
  var bitmapFontTextParser;
  var init_bitmapFontTextParser = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs"() {
      "use strict";
      bitmapFontTextParser = {
        test(data) {
          return typeof data === "string" && data.startsWith("info face=");
        },
        parse(txt) {
          const items = txt.match(/^[a-z]+\s+.+$/gm);
          const rawData = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
          };
          for (const i2 in items) {
            const name = items[i2].match(/^[a-z]+/gm)[0];
            const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
            const itemData = {};
            for (const i22 in attributeList) {
              const split = attributeList[i22].split("=");
              const key = split[0];
              const strValue = split[1].replace(/"/gm, "");
              const floatValue = parseFloat(strValue);
              const value = isNaN(floatValue) ? strValue : floatValue;
              itemData[key] = value;
            }
            rawData[name].push(itemData);
          }
          const font = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const [info] = rawData.info;
          const [common] = rawData.common;
          const [distanceField] = rawData.distanceField ?? [];
          if (distanceField) {
            font.distanceField = {
              range: parseInt(distanceField.distanceRange, 10),
              type: distanceField.fieldType
            };
          }
          font.fontSize = parseInt(info.size, 10);
          font.fontFamily = info.face;
          font.lineHeight = parseInt(common.lineHeight, 10);
          const page = rawData.page;
          for (let i2 = 0; i2 < page.length; i2++) {
            font.pages.push({
              id: parseInt(page[i2].id, 10) || 0,
              file: page[i2].file
            });
          }
          const map4 = {};
          font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
          const char = rawData.char;
          for (let i2 = 0; i2 < char.length; i2++) {
            const charNode = char[i2];
            const id = parseInt(charNode.id, 10);
            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
            if (letter === "space")
              letter = " ";
            map4[id] = letter;
            font.chars[letter] = {
              id,
              page: parseInt(charNode.page, 10) || 0,
              x: parseInt(charNode.x, 10),
              y: parseInt(charNode.y, 10),
              width: parseInt(charNode.width, 10),
              height: parseInt(charNode.height, 10),
              xOffset: parseInt(charNode.xoffset, 10),
              yOffset: parseInt(charNode.yoffset, 10),
              xAdvance: parseInt(charNode.xadvance, 10),
              kerning: {}
            };
          }
          const kerning = rawData.kerning || [];
          for (let i2 = 0; i2 < kerning.length; i2++) {
            const first = parseInt(kerning[i2].first, 10);
            const second = parseInt(kerning[i2].second, 10);
            const amount = parseInt(kerning[i2].amount, 10);
            font.chars[map4[second]].kerning[map4[first]] = amount;
          }
          return font;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
  var bitmapFontXMLParser;
  var init_bitmapFontXMLParser = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs"() {
      "use strict";
      bitmapFontXMLParser = {
        test(data) {
          const xml = data;
          return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
        },
        parse(xml) {
          const data = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: "",
            distanceField: null,
            baseLineOffset: 0
          };
          const info = xml.getElementsByTagName("info")[0];
          const common = xml.getElementsByTagName("common")[0];
          const distanceField = xml.getElementsByTagName("distanceField")[0];
          if (distanceField) {
            data.distanceField = {
              type: distanceField.getAttribute("fieldType"),
              range: parseInt(distanceField.getAttribute("distanceRange"), 10)
            };
          }
          const page = xml.getElementsByTagName("page");
          const char = xml.getElementsByTagName("char");
          const kerning = xml.getElementsByTagName("kerning");
          data.fontSize = parseInt(info.getAttribute("size"), 10);
          data.fontFamily = info.getAttribute("face");
          data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
          for (let i2 = 0; i2 < page.length; i2++) {
            data.pages.push({
              id: parseInt(page[i2].getAttribute("id"), 10) || 0,
              file: page[i2].getAttribute("file")
            });
          }
          const map4 = {};
          data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
          for (let i2 = 0; i2 < char.length; i2++) {
            const charNode = char[i2];
            const id = parseInt(charNode.getAttribute("id"), 10);
            let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
            if (letter === "space")
              letter = " ";
            map4[id] = letter;
            data.chars[letter] = {
              id,
              page: parseInt(charNode.getAttribute("page"), 10) || 0,
              x: parseInt(charNode.getAttribute("x"), 10),
              y: parseInt(charNode.getAttribute("y"), 10),
              width: parseInt(charNode.getAttribute("width"), 10),
              height: parseInt(charNode.getAttribute("height"), 10),
              xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
              yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
              xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
              kerning: {}
            };
          }
          for (let i2 = 0; i2 < kerning.length; i2++) {
            const first = parseInt(kerning[i2].getAttribute("first"), 10);
            const second = parseInt(kerning[i2].getAttribute("second"), 10);
            const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
            data.chars[map4[second]].kerning[map4[first]] = amount;
          }
          return data;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
  var bitmapFontXMLStringParser;
  var init_bitmapFontXMLStringParser = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs"() {
      init_adapter2();
      init_bitmapFontXMLParser();
      bitmapFontXMLStringParser = {
        test(data) {
          if (typeof data === "string" && data.includes("<font>")) {
            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
          }
          return false;
        },
        parse(data) {
          return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
  var validExtensions2, bitmapFontCachePlugin, loadBitmapFont2;
  var init_loadBitmapFont2 = __esm({
    "node_modules/pixi-v8/lib/scene/text-bitmap/asset/loadBitmapFont.mjs"() {
      init_LoaderParser2();
      init_copySearchParams2();
      init_adapter2();
      init_Extensions();
      init_path2();
      init_BitmapFont2();
      init_bitmapFontTextParser();
      init_bitmapFontXMLStringParser();
      validExtensions2 = [".xml", ".fnt"];
      bitmapFontCachePlugin = {
        extension: {
          type: ExtensionType2.CacheParser,
          name: "cacheBitmapFont"
        },
        test: (asset) => asset instanceof BitmapFont2,
        getCacheableAssets(keys, asset) {
          const out2 = {};
          keys.forEach((key) => {
            out2[key] = asset;
            out2[`${key}-bitmap`] = asset;
          });
          out2[`${asset.fontFamily}-bitmap`] = asset;
          return out2;
        }
      };
      loadBitmapFont2 = {
        extension: {
          type: ExtensionType2.LoadParser,
          priority: LoaderParserPriority2.Normal
        },
        name: "loadBitmapFont",
        test(url2) {
          return validExtensions2.includes(path2.extname(url2).toLowerCase());
        },
        async testParse(data) {
          return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
        },
        async parse(asset, data, loader) {
          const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
          const { src } = data;
          const { pages } = bitmapFontData;
          const textureUrls = [];
          const textureOptions = bitmapFontData.distanceField ? {
            scaleMode: "linear",
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: false,
            resolution: 1
          } : {};
          for (let i2 = 0; i2 < pages.length; ++i2) {
            const pageFile = pages[i2].file;
            let imagePath = path2.join(path2.dirname(src), pageFile);
            imagePath = copySearchParams2(imagePath, src);
            textureUrls.push({
              src: imagePath,
              data: textureOptions
            });
          }
          const loadedTextures = await loader.load(textureUrls);
          const textures = textureUrls.map((url2) => loadedTextures[url2.src]);
          const bitmapFont = new BitmapFont2({
            data: bitmapFontData,
            textures
          }, src);
          return bitmapFont;
        },
        async load(url2, _options) {
          const response = await DOMAdapter.get().fetch(url2);
          return await response.text();
        },
        async unload(bitmapFont, _resolvedAsset, loader) {
          await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
          bitmapFont.destroy();
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/BackgroundLoader.mjs
  var BackgroundLoader2;
  var init_BackgroundLoader2 = __esm({
    "node_modules/pixi-v8/lib/assets/BackgroundLoader.mjs"() {
      "use strict";
      BackgroundLoader2 = class {
        constructor(loader, verbose = false) {
          this._loader = loader;
          this._assetList = [];
          this._isLoading = false;
          this._maxConcurrent = 1;
          this.verbose = verbose;
        }
        add(assetUrls) {
          assetUrls.forEach((a2) => {
            this._assetList.push(a2);
          });
          if (this.verbose) {
            console.log("[BackgroundLoader] assets: ", this._assetList);
          }
          if (this._isActive && !this._isLoading) {
            void this._next();
          }
        }
        async _next() {
          if (this._assetList.length && this._isActive) {
            this._isLoading = true;
            const toLoad = [];
            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i2 = 0; i2 < toLoadAmount; i2++) {
              toLoad.push(this._assetList.pop());
            }
            await this._loader.load(toLoad);
            this._isLoading = false;
            void this._next();
          }
        }
        get active() {
          return this._isActive;
        }
        set active(value) {
          if (this._isActive === value)
            return;
          this._isActive = value;
          if (value && !this._isLoading) {
            void this._next();
          }
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/cache/parsers/cacheTextureArray.mjs
  var cacheTextureArray2;
  var init_cacheTextureArray2 = __esm({
    "node_modules/pixi-v8/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
      init_Extensions();
      init_Texture2();
      cacheTextureArray2 = {
        extension: {
          type: ExtensionType2.CacheParser,
          name: "cacheTextureArray"
        },
        test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture2),
        getCacheableAssets: (keys, asset) => {
          const out2 = {};
          keys.forEach((key) => {
            asset.forEach((item, i2) => {
              out2[key + (i2 === 0 ? "" : i2 + 1)] = item;
            });
          });
          return out2;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/utils/testImageFormat.mjs
  async function testImageFormat(imageData) {
    if ("Image" in globalThis) {
      return new Promise((resolve2) => {
        const image = new Image();
        image.onload = () => {
          resolve2(true);
        };
        image.onerror = () => {
          resolve2(false);
        };
        image.src = imageData;
      });
    }
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const blob = await (await fetch(imageData)).blob();
        await createImageBitmap(blob);
      } catch (e2) {
        return false;
      }
      return true;
    }
    return false;
  }
  var init_testImageFormat = __esm({
    "node_modules/pixi-v8/lib/assets/detections/utils/testImageFormat.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectAvif.mjs
  var detectAvif2;
  var init_detectAvif2 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectAvif.mjs"() {
      init_Extensions();
      init_testImageFormat();
      detectAvif2 = {
        extension: {
          type: ExtensionType2.DetectionParser,
          priority: 1
        },
        test: async () => testImageFormat(
          "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
        ),
        add: async (formats2) => [...formats2, "avif"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "avif")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectDefaults.mjs
  var imageFormats2, detectDefaults2;
  var init_detectDefaults2 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectDefaults.mjs"() {
      init_Extensions();
      imageFormats2 = ["png", "jpg", "jpeg"];
      detectDefaults2 = {
        extension: {
          type: ExtensionType2.DetectionParser,
          priority: -1
        },
        test: () => Promise.resolve(true),
        add: async (formats2) => [...formats2, ...imageFormats2],
        remove: async (formats2) => formats2.filter((f2) => !imageFormats2.includes(f2))
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/utils/testVideoFormat.mjs
  function testVideoFormat2(mimeType) {
    if (inWorker2) {
      return false;
    }
    const video = document.createElement("video");
    return video.canPlayType(mimeType) !== "";
  }
  var inWorker2;
  var init_testVideoFormat2 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/utils/testVideoFormat.mjs"() {
      "use strict";
      inWorker2 = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectMp4.mjs
  var detectMp42;
  var init_detectMp42 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectMp4.mjs"() {
      init_Extensions();
      init_testVideoFormat2();
      detectMp42 = {
        extension: {
          type: ExtensionType2.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat2("video/mp4"),
        add: async (formats2) => [...formats2, "mp4", "m4v"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectOgv.mjs
  var detectOgv2;
  var init_detectOgv2 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectOgv.mjs"() {
      init_Extensions();
      init_testVideoFormat2();
      detectOgv2 = {
        extension: {
          type: ExtensionType2.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat2("video/ogg"),
        add: async (formats2) => [...formats2, "ogv"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "ogv")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectWebm.mjs
  var detectWebm2;
  var init_detectWebm2 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectWebm.mjs"() {
      init_Extensions();
      init_testVideoFormat2();
      detectWebm2 = {
        extension: {
          type: ExtensionType2.DetectionParser,
          priority: 0
        },
        test: async () => testVideoFormat2("video/webm"),
        add: async (formats2) => [...formats2, "webm"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "webm")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/detections/parsers/detectWebp.mjs
  var detectWebp2;
  var init_detectWebp2 = __esm({
    "node_modules/pixi-v8/lib/assets/detections/parsers/detectWebp.mjs"() {
      init_Extensions();
      init_testImageFormat();
      detectWebp2 = {
        extension: {
          type: ExtensionType2.DetectionParser,
          priority: 0
        },
        test: async () => testImageFormat(
          "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
        ),
        add: async (formats2) => [...formats2, "webp"],
        remove: async (formats2) => formats2.filter((f2) => f2 !== "webp")
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/Loader.mjs
  var Loader2;
  var init_Loader2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/Loader.mjs"() {
      init_warn();
      init_path2();
      init_convertToList2();
      init_isSingleItem2();
      Loader2 = class {
        constructor() {
          this._parsers = [];
          this._parsersValidated = false;
          this.parsers = new Proxy(this._parsers, {
            set: (target, key, value) => {
              this._parsersValidated = false;
              target[key] = value;
              return true;
            }
          });
          this.promiseCache = {};
        }
        reset() {
          this._parsersValidated = false;
          this.promiseCache = {};
        }
        _getLoadPromiseAndParser(url2, data) {
          const result = {
            promise: null,
            parser: null
          };
          result.promise = (async () => {
            let asset = null;
            let parser = null;
            if (data.loadParser) {
              parser = this._parserHash[data.loadParser];
              if (!parser) {
                warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url2}`);
              }
            }
            if (!parser) {
              for (let i2 = 0; i2 < this.parsers.length; i2++) {
                const parserX = this.parsers[i2];
                if (parserX.load && parserX.test?.(url2, data, this)) {
                  parser = parserX;
                  break;
                }
              }
              if (!parser) {
                warn(`[Assets] ${url2} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
                return null;
              }
            }
            asset = await parser.load(url2, data, this);
            result.parser = parser;
            for (let i2 = 0; i2 < this.parsers.length; i2++) {
              const parser2 = this.parsers[i2];
              if (parser2.parse) {
                if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
                  asset = await parser2.parse(asset, data, this) || asset;
                  result.parser = parser2;
                }
              }
            }
            return asset;
          })();
          return result;
        }
        async load(assetsToLoadIn, onProgress) {
          if (!this._parsersValidated) {
            this._validateParsers();
          }
          let count2 = 0;
          const assets = {};
          const singleAsset = isSingleItem2(assetsToLoadIn);
          const assetsToLoad = convertToList2(assetsToLoadIn, (item) => ({
            alias: [item],
            src: item,
            data: {}
          }));
          const total = assetsToLoad.length;
          const promises = assetsToLoad.map(async (asset) => {
            const url2 = path2.toAbsolute(asset.src);
            if (!assets[asset.src]) {
              try {
                if (!this.promiseCache[url2]) {
                  this.promiseCache[url2] = this._getLoadPromiseAndParser(url2, asset);
                }
                assets[asset.src] = await this.promiseCache[url2].promise;
                if (onProgress)
                  onProgress(++count2 / total);
              } catch (e2) {
                delete this.promiseCache[url2];
                delete assets[asset.src];
                throw new Error(`[Loader.load] Failed to load ${url2}.
${e2}`);
              }
            }
          });
          await Promise.all(promises);
          return singleAsset ? assets[assetsToLoad[0].src] : assets;
        }
        async unload(assetsToUnloadIn) {
          const assetsToUnload = convertToList2(assetsToUnloadIn, (item) => ({
            alias: [item],
            src: item
          }));
          const promises = assetsToUnload.map(async (asset) => {
            const url2 = path2.toAbsolute(asset.src);
            const loadPromise = this.promiseCache[url2];
            if (loadPromise) {
              const loadedAsset = await loadPromise.promise;
              delete this.promiseCache[url2];
              await loadPromise.parser?.unload?.(loadedAsset, asset, this);
            }
          });
          await Promise.all(promises);
        }
        _validateParsers() {
          this._parsersValidated = true;
          this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
            if (!parser.name) {
              warn(`[Assets] loadParser should have a name`);
            } else if (hash[parser.name]) {
              warn(`[Assets] loadParser name conflict "${parser.name}"`);
            }
            return { ...hash, [parser.name]: parser };
          }, {});
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/checkDataUrl.mjs
  function checkDataUrl2(url2, mimes) {
    if (Array.isArray(mimes)) {
      for (const mime of mimes) {
        if (url2.startsWith(`data:${mime}`))
          return true;
      }
      return false;
    }
    return url2.startsWith(`data:${mimes}`);
  }
  var init_checkDataUrl2 = __esm({
    "node_modules/pixi-v8/lib/assets/utils/checkDataUrl.mjs"() {
      "use strict";
    }
  });

  // node_modules/pixi-v8/lib/assets/utils/checkExtension.mjs
  function checkExtension2(url2, extension) {
    const tempURL = url2.split("?")[0];
    const ext = path2.extname(tempURL).toLowerCase();
    if (Array.isArray(extension)) {
      return extension.includes(ext);
    }
    return ext === extension;
  }
  var init_checkExtension2 = __esm({
    "node_modules/pixi-v8/lib/assets/utils/checkExtension.mjs"() {
      init_path2();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/loadJson.mjs
  var validJSONExtension2, validJSONMIME2, loadJson2;
  var init_loadJson2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/loadJson.mjs"() {
      init_adapter2();
      init_Extensions();
      init_checkDataUrl2();
      init_checkExtension2();
      init_LoaderParser2();
      validJSONExtension2 = ".json";
      validJSONMIME2 = "application/json";
      loadJson2 = {
        extension: {
          type: ExtensionType2.LoadParser,
          priority: LoaderParserPriority2.Low
        },
        name: "loadJson",
        test(url2) {
          return checkDataUrl2(url2, validJSONMIME2) || checkExtension2(url2, validJSONExtension2);
        },
        async load(url2) {
          const response = await DOMAdapter.get().fetch(url2);
          const json = await response.json();
          return json;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/loadTxt.mjs
  var validTXTExtension2, validTXTMIME2, loadTxt2;
  var init_loadTxt2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/loadTxt.mjs"() {
      init_adapter2();
      init_Extensions();
      init_checkDataUrl2();
      init_checkExtension2();
      init_LoaderParser2();
      validTXTExtension2 = ".txt";
      validTXTMIME2 = "text/plain";
      loadTxt2 = {
        name: "loadTxt",
        extension: {
          type: ExtensionType2.LoadParser,
          priority: LoaderParserPriority2.Low,
          name: "loadTxt"
        },
        test(url2) {
          return checkDataUrl2(url2, validTXTMIME2) || checkExtension2(url2, validTXTExtension2);
        },
        async load(url2) {
          const response = await DOMAdapter.get().fetch(url2);
          const txt = await response.text();
          return txt;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/loadWebFont.mjs
  function getFontFamilyName2(url2) {
    const ext = path2.extname(url2);
    const name = path2.basename(url2, ext);
    const nameWithSpaces = name.replace(/(-|_)/g, " ");
    const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
    let valid = nameTokens.length > 0;
    for (const token of nameTokens) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX2)) {
        valid = false;
        break;
      }
    }
    let fontFamilyName = nameTokens.join(" ");
    if (!valid) {
      fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
    }
    return fontFamilyName;
  }
  function encodeURIWhenNeeded(uri) {
    if (validURICharactersRegex.test(uri)) {
      return uri;
    }
    return encodeURI(uri);
  }
  var validWeights2, validFontExtensions2, validFontMIMEs2, CSS_IDENT_TOKEN_REGEX2, validURICharactersRegex, loadWebFont2;
  var init_loadWebFont2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/loadWebFont.mjs"() {
      init_adapter2();
      init_Extensions();
      init_warn();
      init_path2();
      init_Cache2();
      init_checkDataUrl2();
      init_checkExtension2();
      init_LoaderParser2();
      validWeights2 = [
        "normal",
        "bold",
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
      ];
      validFontExtensions2 = [".ttf", ".otf", ".woff", ".woff2"];
      validFontMIMEs2 = [
        "font/ttf",
        "font/otf",
        "font/woff",
        "font/woff2"
      ];
      CSS_IDENT_TOKEN_REGEX2 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
      validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
      loadWebFont2 = {
        extension: {
          type: ExtensionType2.LoadParser,
          priority: LoaderParserPriority2.Low
        },
        name: "loadWebFont",
        test(url2) {
          return checkDataUrl2(url2, validFontMIMEs2) || checkExtension2(url2, validFontExtensions2);
        },
        async load(url2, options) {
          const fonts = DOMAdapter.get().getFontFaceSet();
          if (fonts) {
            const fontFaces = [];
            const name = options.data?.family ?? getFontFamilyName2(url2);
            const weights = options.data?.weights?.filter((weight) => validWeights2.includes(weight)) ?? ["normal"];
            const data = options.data ?? {};
            for (let i2 = 0; i2 < weights.length; i2++) {
              const weight = weights[i2];
              const font = new FontFace(name, `url(${encodeURIWhenNeeded(url2)})`, {
                ...data,
                weight
              });
              await font.load();
              fonts.add(font);
              fontFaces.push(font);
            }
            Cache2.set(`${name}-and-url`, {
              url: url2,
              fontFaces
            });
            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
          }
          warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
          return null;
        },
        unload(font) {
          (Array.isArray(font) ? font : [font]).forEach((t2) => {
            Cache2.remove(t2.family);
            DOMAdapter.get().getFontFaceSet().delete(t2);
          });
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/utils/network/getResolutionOfUrl.mjs
  function getResolutionOfUrl2(url2, defaultValue3 = 1) {
    const resolution = Resolver2.RETINA_PREFIX?.exec(url2);
    if (resolution) {
      return parseFloat(resolution[1]);
    }
    return defaultValue3;
  }
  var init_getResolutionOfUrl2 = __esm({
    "node_modules/pixi-v8/lib/utils/network/getResolutionOfUrl.mjs"() {
      init_Resolver2();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/utils/createTexture.mjs
  function createTexture2(source2, loader, url2) {
    source2.label = url2;
    source2._sourceOrigin = url2;
    const texture = new Texture2({
      source: source2,
      label: url2
    });
    const unload = () => {
      delete loader.promiseCache[url2];
      if (Cache2.has(url2)) {
        Cache2.remove(url2);
      }
    };
    texture.source.once("destroy", () => {
      if (loader.promiseCache[url2]) {
        warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
        unload();
      }
    });
    texture.once("destroy", () => {
      if (!source2.destroyed) {
        warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
        unload();
      }
    });
    return texture;
  }
  var init_createTexture2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
      init_Texture2();
      init_warn();
      init_Cache2();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadSVG.mjs
  async function loadAsTexture(url2, asset, loader, crossOrigin2) {
    const response = await DOMAdapter.get().fetch(url2);
    const blob = await response.blob();
    const blobUrl = URL.createObjectURL(blob);
    const image = new Image();
    image.src = blobUrl;
    image.crossOrigin = crossOrigin2;
    await image.decode();
    URL.revokeObjectURL(blobUrl);
    const canvas = document.createElement("canvas");
    const context3 = canvas.getContext("2d");
    const resolution = asset.data?.resolution || getResolutionOfUrl2(url2);
    const width = asset.data?.width ?? image.width;
    const height = asset.data?.height ?? image.height;
    canvas.width = width * resolution;
    canvas.height = height * resolution;
    context3.drawImage(image, 0, 0, width * resolution, height * resolution);
    const { parseAsGraphicsContext: _p, ...rest } = asset.data;
    const base = new ImageSource({
      resource: canvas,
      alphaMode: "premultiply-alpha-on-upload",
      resolution,
      ...rest
    });
    return createTexture2(base, loader, url2);
  }
  async function loadAsGraphics(url2) {
    const response = await DOMAdapter.get().fetch(url2);
    const svgSource = await response.text();
    const context3 = new GraphicsContext();
    context3.svg(svgSource);
    return context3;
  }
  var validSVGExtension2, validSVGMIME2, loadSvg;
  var init_loadSVG2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
      init_adapter2();
      init_Extensions();
      init_ImageSource();
      init_GraphicsContext();
      init_getResolutionOfUrl2();
      init_checkDataUrl2();
      init_checkExtension2();
      init_LoaderParser2();
      init_createTexture2();
      validSVGExtension2 = ".svg";
      validSVGMIME2 = "image/svg+xml";
      loadSvg = {
        extension: {
          type: ExtensionType2.LoadParser,
          priority: LoaderParserPriority2.Low,
          name: "loadSVG"
        },
        name: "loadSVG",
        config: {
          crossOrigin: "anonymous",
          parseAsGraphicsContext: false
        },
        test(url2) {
          return checkDataUrl2(url2, validSVGMIME2) || checkExtension2(url2, validSVGExtension2);
        },
        async load(url2, asset, loader) {
          if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {
            return loadAsGraphics(url2);
          }
          return loadAsTexture(url2, asset, loader, this.config.crossOrigin);
        },
        unload(asset) {
          asset.destroy(true);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/_virtual/checkImageBitmap.worker.mjs
  var WORKER_CODE, WORKER_URL, WorkerInstance;
  var init_checkImageBitmap_worker = __esm({
    "node_modules/pixi-v8/lib/_virtual/checkImageBitmap.worker.mjs"() {
      WORKER_CODE = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
      WORKER_URL = null;
      WorkerInstance = class {
        constructor() {
          if (!WORKER_URL) {
            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }));
          }
          this.worker = new Worker(WORKER_URL);
        }
      };
      WorkerInstance.revokeObjectURL = function revokeObjectURL() {
        if (WORKER_URL) {
          URL.revokeObjectURL(WORKER_URL);
          WORKER_URL = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/_virtual/loadImageBitmap.worker.mjs
  var WORKER_CODE2, WORKER_URL2, WorkerInstance2;
  var init_loadImageBitmap_worker = __esm({
    "node_modules/pixi-v8/lib/_virtual/loadImageBitmap.worker.mjs"() {
      WORKER_CODE2 = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
      WORKER_URL2 = null;
      WorkerInstance2 = class {
        constructor() {
          if (!WORKER_URL2) {
            WORKER_URL2 = URL.createObjectURL(new Blob([WORKER_CODE2], { type: "application/javascript" }));
          }
          this.worker = new Worker(WORKER_URL2);
        }
      };
      WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
        if (WORKER_URL2) {
          URL.revokeObjectURL(WORKER_URL2);
          WORKER_URL2 = null;
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/workers/WorkerManager.mjs
  var UUID2, MAX_WORKERS2, WorkerManagerClass2, WorkerManager2;
  var init_WorkerManager2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/workers/WorkerManager.mjs"() {
      init_checkImageBitmap_worker();
      init_loadImageBitmap_worker();
      UUID2 = 0;
      WorkerManagerClass2 = class {
        constructor() {
          this._initialized = false;
          this._createdWorkers = 0;
          this._workerPool = [];
          this._queue = [];
          this._resolveHash = {};
        }
        isImageBitmapSupported() {
          if (this._isImageBitmapSupported !== void 0)
            return this._isImageBitmapSupported;
          this._isImageBitmapSupported = new Promise((resolve2) => {
            const { worker } = new WorkerInstance();
            worker.addEventListener("message", (event) => {
              worker.terminate();
              WorkerInstance.revokeObjectURL();
              resolve2(event.data);
            });
          });
          return this._isImageBitmapSupported;
        }
        loadImageBitmap(src, asset) {
          return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);
        }
        async _initWorkers() {
          if (this._initialized)
            return;
          this._initialized = true;
        }
        _getWorker() {
          if (MAX_WORKERS2 === void 0) {
            MAX_WORKERS2 = navigator.hardwareConcurrency || 4;
          }
          let worker = this._workerPool.pop();
          if (!worker && this._createdWorkers < MAX_WORKERS2) {
            this._createdWorkers++;
            worker = new WorkerInstance2().worker;
            worker.addEventListener("message", (event) => {
              this._complete(event.data);
              this._returnWorker(event.target);
              this._next();
            });
          }
          return worker;
        }
        _returnWorker(worker) {
          this._workerPool.push(worker);
        }
        _complete(data) {
          if (data.error !== void 0) {
            this._resolveHash[data.uuid].reject(data.error);
          } else {
            this._resolveHash[data.uuid].resolve(data.data);
          }
          this._resolveHash[data.uuid] = null;
        }
        async _run(id, args) {
          await this._initWorkers();
          const promise3 = new Promise((resolve2, reject) => {
            this._queue.push({ id, arguments: args, resolve: resolve2, reject });
          });
          this._next();
          return promise3;
        }
        _next() {
          if (!this._queue.length)
            return;
          const worker = this._getWorker();
          if (!worker) {
            return;
          }
          const toDo = this._queue.pop();
          const id = toDo.id;
          this._resolveHash[UUID2] = { resolve: toDo.resolve, reject: toDo.reject };
          worker.postMessage({
            data: toDo.arguments,
            uuid: UUID2++,
            id
          });
        }
      };
      WorkerManager2 = new WorkerManagerClass2();
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadTextures.mjs
  async function loadImageBitmap2(url2, asset) {
    const response = await DOMAdapter.get().fetch(url2);
    if (!response.ok) {
      throw new Error(`[loadImageBitmap] Failed to fetch ${url2}: ${response.status} ${response.statusText}`);
    }
    const imageBlob = await response.blob();
    return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
  }
  var validImageExtensions2, validImageMIMEs2, loadTextures2;
  var init_loadTextures2 = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
      init_adapter2();
      init_Extensions();
      init_ImageSource();
      init_getResolutionOfUrl2();
      init_checkDataUrl2();
      init_checkExtension2();
      init_WorkerManager2();
      init_LoaderParser2();
      init_createTexture2();
      validImageExtensions2 = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
      validImageMIMEs2 = [
        "image/jpeg",
        "image/png",
        "image/webp",
        "image/avif"
      ];
      loadTextures2 = {
        name: "loadTextures",
        extension: {
          type: ExtensionType2.LoadParser,
          priority: LoaderParserPriority2.High,
          name: "loadTextures"
        },
        config: {
          preferWorkers: true,
          preferCreateImageBitmap: true,
          crossOrigin: "anonymous"
        },
        test(url2) {
          return checkDataUrl2(url2, validImageMIMEs2) || checkExtension2(url2, validImageExtensions2);
        },
        async load(url2, asset, loader) {
          let src = null;
          if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
            if (this.config.preferWorkers && await WorkerManager2.isImageBitmapSupported()) {
              src = await WorkerManager2.loadImageBitmap(url2, asset);
            } else {
              src = await loadImageBitmap2(url2, asset);
            }
          } else {
            src = await new Promise((resolve2) => {
              src = new Image();
              src.crossOrigin = this.config.crossOrigin;
              src.src = url2;
              if (src.complete) {
                resolve2(src);
              } else {
                src.onload = () => {
                  resolve2(src);
                };
              }
            });
          }
          const base = new ImageSource({
            resource: src,
            alphaMode: "premultiply-alpha-on-upload",
            resolution: asset.data?.resolution || getResolutionOfUrl2(url2),
            ...asset.data
          });
          return createTexture2(base, loader, url2);
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
  function crossOrigin(element, url2, crossorigin) {
    if (crossorigin === void 0 && !url2.startsWith("data:")) {
      element.crossOrigin = determineCrossOrigin2(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  function preloadVideo(element) {
    return new Promise((resolve2, reject) => {
      element.addEventListener("canplaythrough", loaded);
      element.addEventListener("error", error);
      element.load();
      function loaded() {
        cleanup();
        resolve2();
      }
      function error(err) {
        cleanup();
        reject(err);
      }
      function cleanup() {
        element.removeEventListener("canplaythrough", loaded);
        element.removeEventListener("error", error);
      }
    });
  }
  function determineCrossOrigin2(url2, loc = globalThis.location) {
    if (url2.startsWith("data:")) {
      return "";
    }
    loc = loc || globalThis.location;
    const parsedUrl = new URL(url2, document.baseURI);
    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
      return "anonymous";
    }
    return "";
  }
  var validVideoExtensions2, validVideoMIMEs2, loadVideoTextures;
  var init_loadVideoTextures = __esm({
    "node_modules/pixi-v8/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
      init_Extensions();
      init_VideoSource();
      init_detectVideoAlphaMode2();
      init_getResolutionOfUrl2();
      init_checkDataUrl2();
      init_checkExtension2();
      init_createTexture2();
      validVideoExtensions2 = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
      validVideoMIMEs2 = validVideoExtensions2.map((ext) => `video/${ext.substring(1)}`);
      loadVideoTextures = {
        name: "loadVideo",
        extension: {
          type: ExtensionType2.LoadParser,
          name: "loadVideo"
        },
        test(url2) {
          const isValidDataUrl = checkDataUrl2(url2, validVideoMIMEs2);
          const isValidExtension = checkExtension2(url2, validVideoExtensions2);
          return isValidDataUrl || isValidExtension;
        },
        async load(url2, asset, loader) {
          const options = {
            ...VideoSource.defaultOptions,
            resolution: asset.data?.resolution || getResolutionOfUrl2(url2),
            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode2(),
            ...asset.data
          };
          const videoElement = document.createElement("video");
          const attributeMap = {
            preload: options.autoLoad !== false ? "auto" : void 0,
            "webkit-playsinline": options.playsinline !== false ? "" : void 0,
            playsinline: options.playsinline !== false ? "" : void 0,
            muted: options.muted === true ? "" : void 0,
            loop: options.loop === true ? "" : void 0,
            autoplay: options.autoPlay !== false ? "" : void 0
          };
          Object.keys(attributeMap).forEach((key) => {
            const value = attributeMap[key];
            if (value !== void 0)
              videoElement.setAttribute(key, value);
          });
          if (options.muted === true) {
            videoElement.muted = true;
          }
          crossOrigin(videoElement, url2, options.crossorigin);
          const sourceElement = document.createElement("source");
          let mime;
          if (url2.startsWith("data:")) {
            mime = url2.slice(5, url2.indexOf(";"));
          } else if (!url2.startsWith("blob:")) {
            const ext = url2.split("?")[0].slice(url2.lastIndexOf(".") + 1).toLowerCase();
            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
          }
          sourceElement.src = url2;
          if (mime) {
            sourceElement.type = mime;
          }
          return new Promise((resolve2) => {
            const onCanPlay = async () => {
              const base = new VideoSource({ ...options, resource: videoElement });
              videoElement.removeEventListener("canplay", onCanPlay);
              if (asset.data.preload) {
                await preloadVideo(videoElement);
              }
              resolve2(createTexture2(base, loader, url2));
            };
            videoElement.addEventListener("canplay", onCanPlay);
            videoElement.appendChild(sourceElement);
          });
        },
        unload(texture) {
          texture.destroy(true);
        }
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/resolver/parsers/resolveTextureUrl.mjs
  var resolveTextureUrl2;
  var init_resolveTextureUrl2 = __esm({
    "node_modules/pixi-v8/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
      init_Extensions();
      init_loadTextures2();
      init_Resolver2();
      resolveTextureUrl2 = {
        extension: {
          type: ExtensionType2.ResolveParser,
          name: "resolveTexture"
        },
        test: loadTextures2.test,
        parse: (value) => ({
          resolution: parseFloat(Resolver2.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: value.split(".").pop(),
          src: value
        })
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/resolver/parsers/resolveJsonUrl.mjs
  var resolveJsonUrl;
  var init_resolveJsonUrl = __esm({
    "node_modules/pixi-v8/lib/assets/resolver/parsers/resolveJsonUrl.mjs"() {
      init_Extensions();
      init_Resolver2();
      init_resolveTextureUrl2();
      resolveJsonUrl = {
        extension: {
          type: ExtensionType2.ResolveParser,
          priority: -2,
          name: "resolveJson"
        },
        test: (value) => Resolver2.RETINA_PREFIX.test(value) && value.endsWith(".json"),
        parse: resolveTextureUrl2.parse
      };
    }
  });

  // node_modules/pixi-v8/lib/assets/Assets.mjs
  var AssetsClass2, Assets2, assetKeyMap2;
  var init_Assets2 = __esm({
    "node_modules/pixi-v8/lib/assets/Assets.mjs"() {
      init_Extensions();
      init_loadBitmapFont2();
      init_warn();
      init_BackgroundLoader2();
      init_Cache2();
      init_cacheTextureArray2();
      init_detectAvif2();
      init_detectDefaults2();
      init_detectMp42();
      init_detectOgv2();
      init_detectWebm2();
      init_detectWebp2();
      init_Loader2();
      init_loadJson2();
      init_loadTxt2();
      init_loadWebFont2();
      init_loadSVG2();
      init_loadTextures2();
      init_loadVideoTextures();
      init_resolveJsonUrl();
      init_resolveTextureUrl2();
      init_Resolver2();
      init_convertToList2();
      init_isSingleItem2();
      AssetsClass2 = class {
        constructor() {
          this._detections = [];
          this._initialized = false;
          this.resolver = new Resolver2();
          this.loader = new Loader2();
          this.cache = Cache2;
          this._backgroundLoader = new BackgroundLoader2(this.loader);
          this._backgroundLoader.active = true;
          this.reset();
        }
        async init(options = {}) {
          if (this._initialized) {
            warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
            return;
          }
          this._initialized = true;
          if (options.defaultSearchParams) {
            this.resolver.setDefaultSearchParams(options.defaultSearchParams);
          }
          if (options.basePath) {
            this.resolver.basePath = options.basePath;
          }
          if (options.bundleIdentifier) {
            this.resolver.setBundleIdentifier(options.bundleIdentifier);
          }
          if (options.manifest) {
            let manifest = options.manifest;
            if (typeof manifest === "string") {
              manifest = await this.load(manifest);
            }
            this.resolver.addManifest(manifest);
          }
          const resolutionPref = options.texturePreference?.resolution ?? 1;
          const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
          const formats2 = await this._detectFormats({
            preferredFormats: options.texturePreference?.format,
            skipDetections: options.skipDetections,
            detections: this._detections
          });
          this.resolver.prefer({
            params: {
              format: formats2,
              resolution
            }
          });
          if (options.preferences) {
            this.setPreferences(options.preferences);
          }
        }
        add(assets) {
          this.resolver.add(assets);
        }
        async load(urls, onProgress) {
          if (!this._initialized) {
            await this.init();
          }
          const singleAsset = isSingleItem2(urls);
          const urlArray = convertToList2(urls).map((url2) => {
            if (typeof url2 !== "string") {
              const aliases = this.resolver.getAlias(url2);
              if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
                this.add(url2);
              }
              return Array.isArray(aliases) ? aliases[0] : aliases;
            }
            if (!this.resolver.hasKey(url2))
              this.add({ alias: url2, src: url2 });
            return url2;
          });
          const resolveResults = this.resolver.resolve(urlArray);
          const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
          return singleAsset ? out2[urlArray[0]] : out2;
        }
        addBundle(bundleId, assets) {
          this.resolver.addBundle(bundleId, assets);
        }
        async loadBundle(bundleIds, onProgress) {
          if (!this._initialized) {
            await this.init();
          }
          let singleAsset = false;
          if (typeof bundleIds === "string") {
            singleAsset = true;
            bundleIds = [bundleIds];
          }
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          const out2 = {};
          const keys = Object.keys(resolveResults);
          let count2 = 0;
          let total = 0;
          const _onProgress = () => {
            onProgress?.(++count2 / total);
          };
          const promises = keys.map((bundleId) => {
            const resolveResult = resolveResults[bundleId];
            total += Object.keys(resolveResult).length;
            return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
              out2[bundleId] = resolveResult2;
            });
          });
          await Promise.all(promises);
          return singleAsset ? out2[bundleIds[0]] : out2;
        }
        async backgroundLoad(urls) {
          if (!this._initialized) {
            await this.init();
          }
          if (typeof urls === "string") {
            urls = [urls];
          }
          const resolveResults = this.resolver.resolve(urls);
          this._backgroundLoader.add(Object.values(resolveResults));
        }
        async backgroundLoadBundle(bundleIds) {
          if (!this._initialized) {
            await this.init();
          }
          if (typeof bundleIds === "string") {
            bundleIds = [bundleIds];
          }
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          Object.values(resolveResults).forEach((resolveResult) => {
            this._backgroundLoader.add(Object.values(resolveResult));
          });
        }
        reset() {
          this.resolver.reset();
          this.loader.reset();
          this.cache.reset();
          this._initialized = false;
        }
        get(keys) {
          if (typeof keys === "string") {
            return Cache2.get(keys);
          }
          const assets = {};
          for (let i2 = 0; i2 < keys.length; i2++) {
            assets[i2] = Cache2.get(keys[i2]);
          }
          return assets;
        }
        async _mapLoadToResolve(resolveResults, onProgress) {
          const resolveArray = [...new Set(Object.values(resolveResults))];
          this._backgroundLoader.active = false;
          const loadedAssets = await this.loader.load(resolveArray, onProgress);
          this._backgroundLoader.active = true;
          const out2 = {};
          resolveArray.forEach((resolveResult) => {
            const asset = loadedAssets[resolveResult.src];
            const keys = [resolveResult.src];
            if (resolveResult.alias) {
              keys.push(...resolveResult.alias);
            }
            keys.forEach((key) => {
              out2[key] = asset;
            });
            Cache2.set(keys, asset);
          });
          return out2;
        }
        async unload(urls) {
          if (!this._initialized) {
            await this.init();
          }
          const urlArray = convertToList2(urls).map((url2) => typeof url2 !== "string" ? url2.src : url2);
          const resolveResults = this.resolver.resolve(urlArray);
          await this._unloadFromResolved(resolveResults);
        }
        async unloadBundle(bundleIds) {
          if (!this._initialized) {
            await this.init();
          }
          bundleIds = convertToList2(bundleIds);
          const resolveResults = this.resolver.resolveBundle(bundleIds);
          const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
          await Promise.all(promises);
        }
        async _unloadFromResolved(resolveResult) {
          const resolveArray = Object.values(resolveResult);
          resolveArray.forEach((resolveResult2) => {
            Cache2.remove(resolveResult2.src);
          });
          await this.loader.unload(resolveArray);
        }
        async _detectFormats(options) {
          let formats2 = [];
          if (options.preferredFormats) {
            formats2 = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
          }
          for (const detection of options.detections) {
            if (options.skipDetections || await detection.test()) {
              formats2 = await detection.add(formats2);
            } else if (!options.skipDetections) {
              formats2 = await detection.remove(formats2);
            }
          }
          formats2 = formats2.filter((format2, index) => formats2.indexOf(format2) === index);
          return formats2;
        }
        get detections() {
          return this._detections;
        }
        setPreferences(preferences) {
          this.loader.parsers.forEach((parser) => {
            if (!parser.config)
              return;
            Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
              parser.config[key] = preferences[key];
            });
          });
        }
      };
      Assets2 = new AssetsClass2();
      extensions3.handleByList(ExtensionType2.LoadParser, Assets2.loader.parsers).handleByList(ExtensionType2.ResolveParser, Assets2.resolver.parsers).handleByList(ExtensionType2.CacheParser, Assets2.cache.parsers).handleByList(ExtensionType2.DetectionParser, Assets2.detections);
      extensions3.add(
        cacheTextureArray2,
        detectDefaults2,
        detectAvif2,
        detectWebp2,
        detectMp42,
        detectOgv2,
        detectWebm2,
        loadJson2,
        loadTxt2,
        loadWebFont2,
        loadSvg,
        loadTextures2,
        loadVideoTextures,
        loadBitmapFont2,
        bitmapFontCachePlugin,
        resolveTextureUrl2,
        resolveJsonUrl
      );
      assetKeyMap2 = {
        loader: ExtensionType2.LoadParser,
        resolver: ExtensionType2.ResolveParser,
        cache: ExtensionType2.CacheParser,
        detection: ExtensionType2.DetectionParser
      };
      extensions3.handle(ExtensionType2.Asset, (extension) => {
        const ref = extension.ref;
        Object.entries(assetKeyMap2).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions3.add(Object.assign(
          ref[key],
          { extension: ref[key].extension ?? type }
        )));
      }, (extension) => {
        const ref = extension.ref;
        Object.keys(assetKeyMap2).filter((key) => !!ref[key]).forEach((key) => extensions3.remove(ref[key]));
      });
    }
  });

  // node_modules/pixi-v8/lib/index.mjs
  var import_earcut3;
  var init_lib39 = __esm({
    "node_modules/pixi-v8/lib/index.mjs"() {
      init_browserExt();
      init_webworkerExt();
      init_Extensions();
      init_init5();
      init_init4();
      init_Assets2();
      init_EventSystem2();
      init_Rectangle2();
      init_autoDetectRenderer2();
      init_TextureStyle();
      init_textureFrom();
      init_Container2();
      init_Sprite2();
      init_eventemitter3();
      import_earcut3 = __toESM(require_earcut(), 1);
      extensions3.add(browserExt, webworkerExt);
    }
  });

  // src/bunny-mark/v8/Bunny-v8.ts
  var BunnyV8;
  var init_Bunny_v8 = __esm({
    "src/bunny-mark/v8/Bunny-v8.ts"() {
      init_lib39();
      BunnyV8 = class {
        constructor(texture, bounds) {
          this.gravity = 0.75;
          this.speedX = Math.random() * 10;
          this.speedY = Math.random() * 10 - 5;
          this.positionX = 0;
          this.positionY = 0;
          this.view = new Sprite2(texture);
          this.view.anchor.set(0.5, 1);
          this.bounds = bounds;
        }
        update() {
          let pX = this.positionX;
          let pY = this.positionY;
          pX += this.speedX;
          pY += this.speedY;
          this.speedY += this.gravity;
          if (pX > this.bounds.right) {
            this.speedX *= -1;
            pX = this.bounds.right;
          } else if (pX < this.bounds.left) {
            this.speedX *= -1;
            pX = this.bounds.left;
          }
          if (pY > this.bounds.bottom) {
            this.speedY *= -0.85;
            pY = this.bounds.bottom;
            if (Math.random() > 0.5) {
              this.speedY -= Math.random() * 6;
            }
          } else if (pY < this.bounds.top) {
            this.speedY = 0;
            pY = this.bounds.top;
          }
          this.view.position.x = this.positionX = pX;
          this.view.position.y = this.positionY = pY;
        }
        reset() {
          this.positionX = 0;
          this.positionY = 0;
        }
      };
    }
  });

  // src/bunny-mark/v8/bunny-mark-v8.ts
  var bunny_mark_v8_exports = {};
  __export(bunny_mark_v8_exports, {
    bunnyMarkV8: () => bunnyMarkV8
  });
  async function bunnyMarkV8({ totalBunnies, preference }) {
    const renderer = await autoDetectRenderer2({
      preference,
      clearBeforeRender: true,
      backgroundAlpha: 1,
      backgroundColor: 16777215,
      width: 800,
      height: 600,
      resolution: 1,
      antialias: false,
      hello: true
    });
    document.body.appendChild(renderer.view.canvas);
    const stage = new Container2();
    const textures = Object.values(await Assets2.load([
      "./assets/bunnies/rabbitv3_ash.png",
      "./assets/bunnies/rabbitv3_batman.png",
      "./assets/bunnies/rabbitv3_bb8.png",
      "./assets/bunnies/rabbitv3_frankenstein.png",
      "./assets/bunnies/rabbitv3_neo.png",
      "./assets/bunnies/rabbitv3_sonic.png",
      "./assets/bunnies/rabbitv3_spidey.png",
      "./assets/bunnies/rabbitv3_stormtrooper.png",
      "./assets/bunnies/rabbitv3_superman.png",
      "./assets/bunnies/rabbitv3_tron.png",
      "./assets/bunnies/rabbitv3_wolverine.png",
      "./assets/bunnies/rabbitv3.png"
    ]));
    const bounds = new Rectangle2(0, 0, 800, 600);
    const bunnies = [];
    function addBunny() {
      const bunny = bunnyPool.pop() || new BunnyV8(textures[bunnies.length % textures.length], bounds);
      bunny.reset();
      stage.addChild(bunny.view);
      bunnies.push(bunny);
    }
    for (let i2 = 0; i2 < totalBunnies; i2++) {
      addBunny();
    }
    let pause = false;
    renderer.view.canvas.addEventListener("mousedown", () => {
      pause = !pause;
    });
    function renderUpdate() {
      if (!pause) {
        for (let i2 = 0; i2 < bunnies.length; i2++) {
          bunnies[i2].update();
        }
      }
      renderer.render(stage);
      requestAnimationFrame(renderUpdate);
    }
    renderUpdate();
  }
  var bunnyPool;
  var init_bunny_mark_v8 = __esm({
    "src/bunny-mark/v8/bunny-mark-v8.ts"() {
      init_lib39();
      init_Bunny_v8();
      TextureStyle.defaultOptions.scaleMode = "nearest";
      EventSystem2.defaultEventFeatures.move = false;
      EventSystem2.defaultEventFeatures.globalMove = false;
      bunnyPool = [];
    }
  });

  // src/index.ts
  async function init3() {
    const params = new URLSearchParams(window.location.search);
    const version = params.get("version") || "v8";
    const totalBunnies = parseInt(params.get("count")) || 1e5;
    const preference = params.get("renderer") || "webgpu";
    if (version === "v7") {
      const { bunnyMarkV7: bunnyMarkV72 } = await Promise.resolve().then(() => (init_bunny_mark_v7(), bunny_mark_v7_exports));
      bunnyMarkV72({ totalBunnies });
    } else {
      const { bunnyMarkV8: bunnyMarkV82 } = await Promise.resolve().then(() => (init_bunny_mark_v8(), bunny_mark_v8_exports));
      bunnyMarkV82({ totalBunnies, preference });
    }
  }
  init3();
})();
/*! https://mths.be/punycode v1.4.1 by @mathias */
