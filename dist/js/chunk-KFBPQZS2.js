import{A as _,B as C,C as ge,D as _e,E as xe,F as ye,G as ie,H as be,I as oe,a as b,b as z,d as G,f as j,h as K,j as T,l as de,m as ce,n as B,o as pe,q as he,s as Y,t as fe,u as le,v as q,w as y,x as me,z as se}from"./chunk-Z4UU6YWC.js";import{C as re,E as ue,G as S,c as u,d as P,g as N,l as te,z as ae}from"./chunk-MPTJJU46.js";var v=class{init(){let e=new ce({transformMatrix:{value:new N,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),t={name:"local-uniform-bit",vertex:{header:`
        
                    struct LocalUniforms {
                        uTransformMatrix:mat3x3<f32>,
                        uColor:vec4<f32>,
                        uRound:f32,
                    }
        
                    @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
                `,main:`
                    vColor *= localUniforms.uColor;
                    modelMatrix *= localUniforms.uTransformMatrix;
                `,end:`
                    if(localUniforms.uRound == 1)
                    {
                        vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                    }
                `}},r=G({name:"graphics",bits:[j,K(16),t,T]});this.shader=new B({gpuProgram:r,resources:{localUniforms:e}}),this.shader.addResource("globalUniforms",0,0)}execute(e,t){let r=t.view.context,s=r.customShader||this.shader,i=e.renderer,o=i.graphicsContext,{geometry:a,instructions:d}=o.getContextRenderData(r),c=i.encoder;c.setPipelineFromGeometryProgramAndState(a,s.gpuProgram,e.state),c.setGeometry(a);let h=i.globalUniforms.bindGroup;c.setBindGroup(0,h,s.gpuProgram);let p=i.renderPipes.uniformBatch.getUniformBindGroup(s.resources.localUniforms,!0);c.setBindGroup(2,p,s.gpuProgram);let m=d.instructions;for(let g=0;g<d.instructionSize;g++){let l=m[g];if(s.groups[1]=l.bindGroup,!l.gpuBindGroup){let ee=l.textures;l.bindGroup=z(ee.textures,ee.count),l.gpuBindGroup=i.bindGroup.getBindGroup(l.bindGroup,s.gpuProgram,1)}c.setBindGroup(1,l.bindGroup,s.gpuProgram),c.renderPassEncoder.drawIndexed(l.size,1,l.start)}}destroy(){this.shader.destroy(!0),this.shader=null}};v.extension={type:[u.WebGPUPipesAdaptor],name:"graphics"};var U=class{init(){let e=G({name:"mesh",bits:[pe,he,T]});this._shader=new B({gpuProgram:e,resources:{uTexture:S.EMPTY._source,uSampler:S.EMPTY._source.style}})}execute(e,t){let r=e.renderer,s=t.view,i=s._shader;i||(i=this._shader,i.groups[2]=r.texture.getTextureBindGroup(s.texture)),i.groups[0]=r.globalUniforms.bindGroup;let o=e.localUniforms;i.groups[1]=r.renderPipes.uniformBatch.getUniformBindGroup(o,!0),r.encoder.draw({geometry:s._geometry,shader:i,state:s.state})}destroy(){this._shader.destroy(!0),this._shader=null}};U.extension={type:[u.WebGPUPipesAdaptor],name:"mesh"};var X=Y.for2d(),R=class{init(){let e=G({name:"batch",bits:[j,K(16),T]});this._shader=new B({gpuProgram:e,groups:{}})}start(e,t){let r=e.renderer,s=r.encoder,i=this._shader.gpuProgram;this._geometry=t,s.setGeometry(t),X.blendMode="normal",r.pipeline.getPipeline(t,i,X);let o=r.globalUniforms.bindGroup;s.setBindGroup(0,o,i)}execute(e,t){let r=this._shader.gpuProgram,s=e.renderer,i=s.encoder;if(!t.bindGroup){let d=t.textures;t.bindGroup=z(d.textures,d.count)}X.blendMode=t.blendMode;let o=s.bindGroup.getBindGroup(t.bindGroup,r,1),a=s.pipeline.getPipeline(this._geometry,r,X);t.bindGroup.touch(s.textureGC.count),i.setPipeline(a),i.renderPassEncoder.setBindGroup(1,o),i.renderPassEncoder.drawIndexed(t.size,1,t.start)}destroy(){this._shader.destroy(!0),this._shader=null}};R.extension={type:[u.WebGPUPipesAdaptor],name:"batch"};var w=class{constructor(e){this._hash=Object.create(null),this._renderer=e}contextChange(e){this._gpu=e}getBindGroup(e,t,r){return e.updateKey(),this._hash[e.key]||this._createBindGroup(e,t,r)}_createBindGroup(e,t,r){let s=this._gpu.device,i=t.layout[r],o=[];for(let d in i){let c=e.resources[d]??e.resources[i[d]],h;if(c.resourceType==="uniformGroup"){let p=c;this._renderer.uniformBuffer.updateUniformGroup(p);let m=p.buffer;h={buffer:this._renderer.buffer.getGPUBuffer(m),offset:0,size:m.descriptor.size}}else if(c.resourceType==="buffer"){let p=c;h={buffer:this._renderer.buffer.getGPUBuffer(p),offset:0,size:p.descriptor.size}}else if(c.resourceType==="bufferResource"){let p=c;h={buffer:this._renderer.buffer.getGPUBuffer(p.buffer),offset:p.offset,size:p.size}}else if(c.resourceType==="textureSampler"){let p=c;h=this._renderer.texture.getGpuSampler(p)}else if(c.resourceType==="textureSource"){let p=c;h=this._renderer.texture.getGpuSource(p).createView({})}o.push({binding:i[d],resource:h})}let a=s.createBindGroup({layout:t._gpuLayout.bindGroups[r],entries:o});return this._hash[e.key]=a,a}destroy(){for(let t of Object.keys(this._hash))this._hash[t]=null;this._hash=null;let e=this;e._renderer=null}};w.extension={type:[u.WebGPUSystem],name:"bindGroup"};var E=class{constructor(){this._gpuBuffers=Object.create(null)}contextChange(e){this._gpu=e}getGPUBuffer(e){return this._gpuBuffers[e.uid]||this.createGPUBuffer(e)}updateBuffer(e){let t=this._gpuBuffers[e.uid]||this.createGPUBuffer(e);return e._updateID&&e.data&&(e._updateID=0,this._gpu.device.queue.writeBuffer(t,0,e.data.buffer,0,e._updateSize)),t}destroyAll(){for(let e in this._gpuBuffers)this._gpuBuffers[e].destroy();this._gpuBuffers={}}createGPUBuffer(e){let t=this._gpu.device.createBuffer(e.descriptor);return e._updateID=0,e.data&&(me(e.data.buffer,t.getMappedRange()),t.unmap()),this._gpuBuffers[e.uid]=t,e.on("update",this.updateBuffer,this),e.on("change",this.onBufferChange,this),e.on("destroy",this.onBufferDestroy,this),t}onBufferChange(e){let t=this._gpuBuffers[e.uid];t.destroy(),t=this.createGPUBuffer(e),e._updateID=0}onBufferDestroy(e){this._gpuBuffers[e.uid].destroy(),this._gpuBuffers[e.uid]=null}destroy(){for(let t of Object.keys(this._gpuBuffers)){let r=Number(t);this._gpuBuffers[r].destroy(),this._gpuBuffers[r]=null}this._gpuBuffers=null;let e=this;e._renderer=null}};E.extension={type:[u.WebGPUSystem],name:"buffer"};var M=class{constructor(e){this._colorMaskCache=15,this._renderer=e}setMask(e){this._colorMaskCache!==e&&(this._colorMaskCache=e,this._renderer.pipeline.setColorMask(e))}destroy(){let e=this;e._renderer=null,this._colorMaskCache=null}};M.extension={type:[u.WebGPUSystem],name:"colorMask"};var L=class{constructor(e){this._renderer=e}async init(){return this._initPromise?this._initPromise:(this._initPromise=this._createDeviceAndAdaptor({}).then(e=>{this.gpu=e,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise)}contextChange(e){this._renderer.gpu=e}async _createDeviceAndAdaptor(e){let t=await navigator.gpu.requestAdapter(e),r=await t.requestDevice();return{adapter:t,device:r}}destroy(){this.gpu=null,this._renderer=null}};L.extension={type:[u.WebGPUSystem],name:"device"};var I=class{constructor(e){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=e}start(){this.commandFinished=new Promise(e=>{this._resolveCommandFinished=e}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(e,t){this.renderPassEncoder&&this.renderPassEncoder.end(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(t.descriptor),this._setViewport(e.viewport)}_setViewport(e){this.renderPassEncoder.setViewport(e.x,e.y,e.width,e.height,0,1)}setPipelineFromGeometryProgramAndState(e,t,r,s){let i=this._renderer.pipeline.getPipeline(e,t,r,s);this.setPipeline(i)}setPipeline(e){this._boundPipeline!==e&&(this._boundPipeline=e,this.renderPassEncoder.setPipeline(e))}_setVertexBuffer(e,t){this._boundVertexBuffer[e]!==t&&(this._boundVertexBuffer[e]=t,this.renderPassEncoder.setVertexBuffer(e,this._renderer.buffer.updateBuffer(t)))}_setIndexBuffer(e){this._boundIndexBuffer!==e&&(this._boundIndexBuffer=e,this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e),"uint32"))}setBindGroup(e,t,r){if(this._boundBindGroup[e]===t)return;this._boundBindGroup[e]=t,t.touch(this._renderer.textureGC.count);let s=this._renderer.bindGroup.getBindGroup(t,r,e);this.renderPassEncoder.setBindGroup(e,s)}setGeometry(e){for(let t in e.attributes){let r=e.attributes[t];this._setVertexBuffer(r.shaderLocation,r.buffer)}e.indexBuffer&&this._setIndexBuffer(e.indexBuffer)}_setShaderBindGroups(e,t){for(let r in e.groups){let s=e.groups[r];t||this._syncBindGroup(s),this.setBindGroup(r,s,e.gpuProgram)}}_syncBindGroup(e){for(let t in e.resources){let r=e.resources[t];r.isUniformGroup&&this._renderer.uniformBuffer.updateUniformGroup(r)}}draw(e){let{geometry:t,shader:r,state:s,topology:i,size:o,start:a,instanceCount:d,skipSync:c}=e;this.setPipelineFromGeometryProgramAndState(t,r.gpuProgram,s,i),this.setGeometry(t),this._setShaderBindGroups(r,c),t.indexBuffer?this.renderPassEncoder.drawIndexed(o||t.indexBuffer.data.length,d||1,a||0):this.renderPassEncoder.draw(o||t.getSize(),d||1,a||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished()}restoreRenderPass(){let e=this._renderer.renderTarget.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(e);let t=this._boundPipeline,r={...this._boundVertexBuffer},s=this._boundIndexBuffer,i={...this._boundBindGroup};this._clearCache();let o=this._renderer.renderTarget.renderTarget.viewport;this.renderPassEncoder.setViewport(o.x,o.y,o.width,o.height,0,1),this.setPipeline(t);for(let a in r)this._setVertexBuffer(a,r[a]);for(let a in i)this.setBindGroup(a,i[a],null);this._setIndexBuffer(s)}_clearCache(){for(let e=0;e<16;e++)this._boundBindGroup[e]=null,this._boundVertexBuffer[e]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){let e=this;e._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(e){this._gpu=e}};I.extension={type:[u.WebGPUSystem],name:"encoder"};var A=class{constructor(e){this._renderTargetStencilState=Object.create(null),this._renderer=e,e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:C.DISABLED,stencilReference:0}),this._activeRenderTarget=e,this.setStencilMode(t.stencilMode,t.stencilReference)}setStencilMode(e,t){let r=this._renderTargetStencilState[this._activeRenderTarget.uid];r.stencilMode=e,r.stencilReference=t;let s=this._renderer;s.pipeline.setStencilMode(e),s.encoder.renderPassEncoder.setStencilReference(t)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this);let e=this;e._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}};A.extension={type:[u.WebGPUSystem],name:"stencil"};var $=class{constructor({minUniformOffsetAlignment:e}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=e,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(e){if(e>this._minUniformOffsetAlignment/4)throw new Error(`UniformBufferBatch: array is too large: ${e*4}`);let t=this.byteIndex,r=t+e*4;if(r=Math.ceil(r/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,r>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=r,t}addGroup(e){let t=this.addEmptyGroup(e.length);for(let r=0;r<e.length;r++)this.data[t/4+r]=e[r];return t}destroy(){this._buffer.destroy(),this._buffer=null,this.data=null}};var x=128,O=class{constructor(e){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=e,this._batchBuffer=new $({minUniformOffsetAlignment:x});let t=256/x;for(let r=0;r<t;r++){let s=y.UNIFORM|y.COPY_DST;r===0&&(s|=y.COPY_SRC),this._buffers.push(new q({data:this._batchBuffer.data,usage:s}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(let e in this._bindGroupHash)this._bindGroupHash[e]=null;this._batchBuffer.clear()}getUniformBindGroup(e,t){if(!t&&this._bindGroupHash[e.uid])return this._bindGroupHash[e.uid];this._renderer.uniformBuffer.ensureUniformGroup(e);let r=e.buffer.data,s=this._batchBuffer.addEmptyGroup(r.length);return this._renderer.uniformBuffer.syncUniformGroup(e,this._batchBuffer.data,s/4),this._bindGroupHash[e.uid]=this._getBindGroup(s/x),this._bindGroupHash[e.uid]}getUniformBufferResource(e){this._renderer.uniformBuffer.updateUniformGroup(e);let t=e.buffer.data,r=this._batchBuffer.addGroup(t);return this._getBufferResource(r/x)}getArrayBindGroup(e){let t=this._batchBuffer.addGroup(e);return this._getBindGroup(t/x)}getArrayBufferResource(e){let r=this._batchBuffer.addGroup(e)/x;return this._getBufferResource(r)}_getBufferResource(e){if(!this._bufferResources[e]){let t=this._buffers[e%2];this._bufferResources[e]=new ye({buffer:t,offset:(e/2|0)*256,size:x})}return this._bufferResources[e]}_getBindGroup(e){if(!this._bindGroups[e]){let t=new b({0:this._getBufferResource(e)});this._bindGroups[e]=t}return this._bindGroups[e]}_uploadBindGroups(){let e=this._renderer.buffer,t=this._buffers[0];t.update(this._batchBuffer.byteIndex),e.updateBuffer(t);let r=this._renderer.gpu.device.createCommandEncoder();for(let s=1;s<this._buffers.length;s++){let i=this._buffers[s];r.copyBufferToBuffer(e.getGPUBuffer(t),x,e.getGPUBuffer(i),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([r.finish()])}destroy(){for(let e=0;e<this._bindGroups.length;e++)this._bindGroups[e].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let e=0;e<this._buffers.length;e++)this._buffers[e].destroy();this._buffers=null;for(let e=0;e<this._bufferResources.length;e++)this._bufferResources[e].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}};O.extension={type:[u.WebGPUPipes],name:"uniformBatch"};var ne=class extends b{constructor(){super({0:new q({data:new Float32Array(128),usage:y.UNIFORM|y.COPY_DST})})}get buffer(){return this.resources[0]}get data(){return this.resources[0].data}},F=class{constructor(e){this._activeBindGroups=[],this._activeBindGroupIndex=0,this._renderer=e}getUniformBindGroup(e){let t=this._renderer;t.uniformBuffer.ensureUniformGroup(e);let r=te.get(ne);return t.uniformBuffer.syncUniformGroup(e,r.data,0),r.buffer.update(e.buffer.data.byteLength),this._activeBindGroups[this._activeBindGroupIndex++]=r,r}renderEnd(){for(let e=0;e<this._activeBindGroupIndex;e++)te.return(this._activeBindGroups[e]);this._activeBindGroupIndex=0}};F.extension={type:[u.WebGPUPipes],name:"uniformBuffer"};var Ue={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function Re(n,e,t,r,s,i,o,a){return n<<26|e<<18|o<<14|t<<8|r<<3|a<<1|s<<4|i}var H=class{constructor(e){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._pipeCache=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=e}contextChange(e){this._gpu=e,this.setStencilMode(C.DISABLED)}setMultisampleCount(e){this._multisampleCount=e}setColorMask(e){this._colorMask=e}setStencilMode(e){this._stencilMode=e,this._stencilState=ie[e]}setPipeline(e,t,r,s){let i=this.getPipeline(e,t,r);s.setPipeline(i)}getPipeline(e,t,r,s){e._layoutKey||this._generateBufferKey(e),t._layoutKey||(this._generateProgramKey(t),this._renderer.shader.createProgramLayout(t)),s=s||e.topology;let i=Re(e._layoutKey,t._layoutKey,r.data,r._blendModeId,this._stencilMode,this._multisampleCount,this._colorMask,Ue[s]);return this._pipeCache[i]?this._pipeCache[i]:(this._pipeCache[i]=this._createPipeline(e,t,r,s),this._pipeCache[i])}_createPipeline(e,t,r,s){let i=this._gpu.device,o=this._createVertexBufferLayouts(e),a=this._renderer.state.getColorTargets(r),d=this._stencilState;d=ie[this._stencilMode],a[0].writeMask=this._stencilMode===C.RENDERING_MASK_ADD?0:this._colorMask;let c={vertex:{module:this._getModule(t.vertex.source),entryPoint:t.vertex.entryPoint,buffers:o},fragment:{module:this._getModule(t.fragment.source),entryPoint:t.fragment.entryPoint,targets:a},primitive:{topology:s,cullMode:r.cullMode},layout:t._gpuLayout.pipeline,multisample:{count:this._multisampleCount},depthStencil:d,label:"PIXI Pipeline"};return i.createRenderPipeline(c)}_getModule(e){return this._moduleCache[e]||this._createModule(e)}_createModule(e){let t=this._gpu.device;return this._moduleCache[e]=t.createShaderModule({code:e}),this._moduleCache[e]}_generateProgramKey(e){let{vertex:t,fragment:r}=e,s=t.source+r.source+t.entryPoint+r.entryPoint;return e._layoutKey=re(s,"program"),e._layoutKey}_generateBufferKey(e){let t=[],r=0,s=Object.keys(e.attributes).sort();for(let o=0;o<s.length;o++){let a=e.attributes[s[o]];t[r++]=a.shaderLocation,t[r++]=a.offset,t[r++]=a.format,t[r++]=a.stride}let i=t.join("");return e._layoutKey=re(i,"geometry"),e._layoutKey}_createVertexBufferLayouts(e){if(this._bufferLayoutsCache[e._layoutKey])return this._bufferLayoutsCache[e._layoutKey];let t=[];return e.buffers.forEach(r=>{let s={arrayStride:0,stepMode:"vertex",attributes:[]},i=s.attributes;for(let o in e.attributes){let a=e.attributes[o];a.buffer===r&&(s.arrayStride=a.stride,i.push({shaderLocation:a.shaderLocation,offset:a.offset,format:a.format}))}i.length&&t.push(s)}),this._bufferLayoutsCache[e._layoutKey]=t,t}destroy(){let e=this;e._renderer=null,this._bufferLayoutsCache=null}};H.extension={type:[u.WebGPUSystem],name:"pipeline"};var J=class{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}};var D=class{constructor(e){this.rootProjectionMatrix=new N,this.onRenderTargetChange=new fe("onRenderTargetChange"),this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._defaultClearColor=[0,0,0,0],this._renderer=e}renderStart({target:e,clear:t,clearColor:r}){this.rootRenderTarget=this.getRenderTarget(e),this.rootProjectionMatrix=this.rootRenderTarget.projectionMatrix,this.renderingToScreen=be(this.rootRenderTarget),this._renderTargetStack.length=0,this._renderer.encoder.start(),this.push(this.rootRenderTarget,t,r??this._renderer.background.colorRgba)}contextChange(e){this._gpu=e}bind(e,t=!0,r){let s=this.getRenderTarget(e),i=this.renderTarget!==s;return this.renderTarget=s,this._startRenderPass(t,r),i&&this.onRenderTargetChange.emit(s),s}_getGpuColorTexture(e){let t=this._getGpuRenderTarget(e);return t.contexts[0]?t.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(e.colorTextures[0].source)}getDescriptor(e,t,r){typeof t=="boolean"&&(t=t?_.ALL:_.NONE);let s=this._getGpuRenderTarget(e),i=e.colorTextures.map((d,c)=>{let h=s.contexts[c],p,m;h?p=h.getCurrentTexture().createView():p=this._renderer.texture.getTextureView(d),s.msaaTextures[c]&&(m=p,p=this._renderer.texture.getTextureView(s.msaaTextures[c]));let g=t&_.COLOR?"clear":"load";return r??(r=this._defaultClearColor),{view:p,resolveTarget:m,clearValue:r,storeOp:"store",loadOp:g}}),o;if(e.depthTexture){let d=t&_.STENCIL?"clear":"load";o={view:this._renderer.texture.getGpuSource(e.depthTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:d}}return{colorAttachments:i,depthStencilAttachment:o}}clear(e=_.ALL,t){!e||this._startRenderPass(e,t)}push(e,t=_.ALL,r){let s=this.bind(e,t,r);return this._renderTargetStack.push(s),s}pop(){this._renderTargetStack.pop(),this.bind(this._renderTargetStack[this._renderTargetStack.length-1],!1)}getRenderTarget(e){return this._renderSurfaceToRenderTargetHash.get(e)??this._initRenderTarget(e)}copyToTexture(e,t,r,s){let i=this._renderer,o=i.renderTarget._getGpuColorTexture(e),a=i.texture.getGpuSource(t.source);return i.encoder.commandEncoder.copyTextureToTexture({texture:o,origin:r},{texture:a},s),t}restart(){this.bind(this.rootRenderTarget,_.NONE)}destroy(){let e=this;e._renderer=null,this._renderSurfaceToRenderTargetHash.clear()}_startRenderPass(e=!0,t){let r=this.renderTarget,s=this._getGpuRenderTarget(r);(r.width!==s.width||r.height!==s.height)&&this._resizeGpuRenderTarget(r);let i=this.getDescriptor(r,e,t);s.descriptor=i,this._renderer.encoder.beginRenderPass(r,s),this._renderer.pipeline.setMultisampleCount(s.msaaSamples)}_initRenderTarget(e){let t=null;return e instanceof HTMLCanvasElement&&(e=ge(e)),e instanceof oe?t=e:e instanceof S&&(t=new oe({colorTextures:[e],depthTexture:e.source.depthStencil})),t.isRoot=!0,this._renderSurfaceToRenderTargetHash.set(e,t),t}_getGpuRenderTarget(e){return this._gpuRenderTargetHash[e.uid]||this._initGpuRenderTarget(e)}_initGpuRenderTarget(e){e.isRoot=!0;let t=new J;return e.colorTextures.forEach((r,s)=>{if(r.source.resource instanceof HTMLCanvasElement){let i=e.colorTexture.source.resource.getContext("webgpu");try{i.configure({device:this._gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:"opaque"})}catch(o){console.error(o)}t.contexts[s]=i}if(t.msaa=r.source.antialias,r.source.antialias){let i=new ue({width:0,height:0,sampleCount:4});t.msaaTextures[s]=i}}),t.msaa&&(t.msaaSamples=4,e.depthTexture&&(e.depthTexture.source.sampleCount=4)),this._gpuRenderTargetHash[e.uid]=t,t}_resizeGpuRenderTarget(e){let t=this._getGpuRenderTarget(e);t.width=e.width,t.height=e.height,t.msaa&&e.colorTextures.forEach((r,s)=>{t.msaaTextures[s]?.resize(r.source.width,r.source.height,r.source._resolution)})}};D.extension={type:[u.WebGPUSystem],name:"renderTarget"};var V=class{contextChange(e){this._gpu=e}createProgramLayout(e){let t=this._gpu.device;if(!e._gpuLayout)if(e.gpuLayout){let r=e.gpuLayout.map(i=>t.createBindGroupLayout({entries:i})),s={bindGroupLayouts:r};e._gpuLayout={bindGroups:r,pipeline:t.createPipelineLayout(s)}}else e._gpuLayout={bindGroups:null,pipeline:"auto"}}destroy(){this._gpu=null}};V.extension={type:[u.WebGPUSystem],name:"shader"};var f={};f.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};f.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}};f.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}};f.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};f.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};f.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}};f["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}};f["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}};f["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}};f.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}};var k=class{constructor(){this.defaultState=new Y,this.defaultState.blend=!0}contextChange(e){this.gpu=e}getColorTargets(e){return[{format:"bgra8unorm",writeMask:0,blend:f[e.blendMode]||f.normal}]}destroy(){this.gpu=null}};k.extension={type:[u.WebGPUSystem],name:"state"};var Ge={type:"image",upload(n,e,t){let r=n.resource,s=(n.pixelWidth|0)*(n.pixelHeight|0),i=r.byteLength/s;t.device.queue.writeTexture({texture:e},r,{offset:0,rowsPerImage:n.pixelWidth,bytesPerRow:n.pixelWidth*i},{width:n.pixelWidth,height:n.pixelHeight,depthOrArrayLayers:1})}};var Q={type:"image",upload(n,e,t){let r=n.resource;if(!r)return;let s=n.resourceWidth||n.pixelWidth,i=n.resourceHeight||n.pixelHeight,o=n.alphaMode==="premultiply-alpha-on-upload";t.device.queue.copyExternalImageToTexture({source:r},{texture:e,premultipliedAlpha:o},{width:s,height:i})}};var Te={type:"video",upload(n,e,t){Q.upload(n,e,t)}};var Z=class{constructor(e){this.device=e,this.sampler=e.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(e){let t=this.pipelines[e];return t||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),t=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:e}]}}),this.pipelines[e]=t),t}generateMipmap(e){let t=this._getMipmapPipeline(e.format);if(e.dimension==="3d"||e.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let r=e,s=e.depthOrArrayLayers||1,i=e.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!i){let d={size:{width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:s},format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:e.mipLevelCount-1};r=this.device.createTexture(d)}let o=this.device.createCommandEncoder({}),a=t.getBindGroupLayout(0);for(let d=0;d<s;++d){let c=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:d,arrayLayerCount:1}),h=i?1:0;for(let p=1;p<e.mipLevelCount;++p){let m=r.createView({baseMipLevel:h++,mipLevelCount:1,dimension:"2d",baseArrayLayer:d,arrayLayerCount:1}),g=o.beginRenderPass({colorAttachments:[{view:m,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),l=this.device.createBindGroup({layout:a,entries:[{binding:0,resource:this.sampler},{binding:1,resource:c}]});g.setPipeline(t),g.setBindGroup(0,l),g.draw(3,1,0,0),g.end(),c=m}}if(!i){let d={width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:s};for(let c=1;c<e.mipLevelCount;++c)o.copyTextureToTexture({texture:r,mipLevel:c-1},{texture:e,mipLevel:c},d),d.width=Math.ceil(d.width/2),d.height=Math.ceil(d.height/2)}return this.device.queue.submit([o.finish()]),i||r.destroy(),e}};var W=class{constructor(e){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:Q,buffer:Ge,video:Te},this._renderer=e}contextChange(e){this._gpu=e}initSource(e){if(e.autoGenerateMipmaps){let s=Math.max(e.pixelWidth,e.pixelHeight);e.mipLevelCount=Math.floor(Math.log2(s))+1}let t={size:{width:e.pixelWidth||1,height:e.pixelHeight||1},format:e.format,sampleCount:e.sampleCount,mipLevelCount:e.mipLevelCount,dimension:e.dimension,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},r=this._gpu.device.createTexture(t);return this._gpuSources[e.uid]=r,e.on("update",this.onSourceUpdate,this),e.on("resize",this.onSourceResize,this),e.on("destroy",this.onSourceDestroy,this),e.on("unload",this.onSourceUnload,this),this.managedTextures.push(e),this.onSourceUpdate(e),r}onSourceUpdate(e){let t=this.getGpuSource(e);!t||(this._uploads[e.uploadMethodId]&&this._uploads[e.uploadMethodId].upload(e,t,this._gpu),e.autoGenerateMipmaps&&e.mipLevelCount>1&&(this._mipmapGenerator||(this._mipmapGenerator=new Z(this._gpu.device)),this._mipmapGenerator.generateMipmap(t)))}onSourceUnload(e){let t=this._gpuSources[e.uid];t&&(this._gpuSources[e.uid]=null,t.destroy())}onSourceDestroy(e){e.off("update",this.onSourceUpdate,this),e.off("unload",this.onSourceUnload,this),e.off("destroy",this.onSourceDestroy,this),e.off("resize",this.onSourceResize,this),this.managedTextures.splice(this.managedTextures.indexOf(e),1),this.onSourceUnload(e)}onSourceResize(e){let t=this._gpuSources[e.uid];(t.width!==e.pixelWidth||t.height!==e.pixelHeight)&&(this._textureViewHash[e.uid]=null,this._bindGroupHash[e.uid]=null,this.onSourceUnload(e),this.initSource(e))}_initSampler(e){return this._gpuSamplers[e.resourceId]=this._gpu.device.createSampler(e),this._gpuSamplers[e.resourceId]}getGpuSampler(e){return this._gpuSamplers[e.resourceId]||this._initSampler(e)}getGpuSource(e){return this._gpuSources[e.uid]||this.initSource(e)}getTextureBindGroup(e){return this._bindGroupHash[e.id]??this._createTextureBindGroup(e)}_createTextureBindGroup(e){let t=e.source,r=t.uid;return this._bindGroupHash[r]=new b({0:t,1:t.style}),this._bindGroupHash[r]}getTextureView(e){let t=e.source;return this._textureViewHash[t.uid]??this._createTextureView(t)}_createTextureView(e){return this._textureViewHash[e.uid]=this.getGpuSource(e).createView(),this._textureViewHash[e.uid]}generateCanvas(e){let t=this._renderer,r=t.gpu.device.createCommandEncoder(),s=ae.ADAPTER.createCanvas();s.width=e.source.pixelWidth,s.height=e.source.pixelHeight;let i=s.getContext("webgpu");return i.configure({device:t.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:"premultiplied"}),r.copyTextureToTexture({texture:t.texture.getGpuSource(e.source),origin:{x:0,y:0}},{texture:i.getCurrentTexture()},{width:s.width,height:s.height}),t.gpu.device.queue.submit([r.finish()]),s}getPixels(e){let t=this.generateCanvas(e),r=se.getOptimalCanvasAndContext(t.width,t.height),s=r.context;s.drawImage(t,0,0);let{width:i,height:o}=t,a=s.getImageData(0,0,i,o),d=new Uint8ClampedArray(a.data.buffer);return se.returnCanvasAndContext(r),{pixels:d,width:i,height:o}}destroy(){for(let e of Object.keys(this._gpuSources)){let t=Number(e);this._gpuSources[t].destroy(),this._gpuSources[t]=null}for(let e of Object.keys(this._bindGroupHash)){let t=Number(e);this._bindGroupHash[t].destroy(),this._bindGroupHash[t]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}};W.extension={type:[u.WebGPUSystem],name:"texture"};var we=[..._e,L,E,W,D,I,V,k,H,M,A,w],Ee=[...xe,O,F],Me=[R,U,v],Pe=[],Se=[],Ce=[];P.handleByNamedList(u.WebGPUSystem,Pe);P.handleByNamedList(u.WebGPUPipes,Se);P.handleByNamedList(u.WebGPUPipesAdaptor,Ce);P.add(...we,...Ee,...Me);var Be=class extends le{constructor(){let e={name:"webgpu",type:de.WEBGPU,systems:Pe,renderPipes:Se,renderPipeAdaptors:Ce};super(e)}};export{Be as a};
